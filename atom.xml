<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KnowMyself</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-03T01:41:11.082Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Qiuyihao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理课堂笔记</title>
    <link href="http://yoursite.com/2018/05/03/%E7%AC%AC%E5%9B%9B%E7%AB%A0CPU--%E8%AE%A1%E7%BB%84%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-01/"/>
    <id>http://yoursite.com/2018/05/03/第四章CPU--计组课堂笔记-01/</id>
    <published>2018-05-03T00:53:04.206Z</published>
    <updated>2018-05-03T01:41:11.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU基础概念"><a href="#CPU基础概念" class="headerlink" title="CPU基础概念"></a>CPU基础概念</h2><p>CPU功能： 指令控制，操作控制，时间控制，数据加工</p><p>CPU控制方式：同步控制，异步控制，联合控制</p><p>CPU指令周期：取值时间+执行时间</p><p>CPU周期：机器周期，总线周期。</p><h2 id="CPU中断逻辑"><a href="#CPU中断逻辑" class="headerlink" title="CPU中断逻辑"></a>CPU中断逻辑</h2><ul><li><p>中断源： 人为设置的中断，程序性事故,  硬件故障，外部事件（比如断电）</p></li><li><p>中断分类：可屏蔽中断和不可屏蔽中断；内部中断和外部中断；软中断和硬中断。</p><p>​</p></li></ul><p>中断系统需要解决的7个问题：</p><ol><li><p>中断如何向CPU提出诉求</p></li><li><p>多个中断同时发生请求，CPU如何优先处理？</p><ol><li>硬件排队</li><li>软件轮询</li></ol></li><li><p>CPU响应中断的条件，时间，方式。</p><ol><li><p>中断服务程序入口地址的查找：硬件向量法和软件查询法</p></li><li><p>中断响应的条件：中断允许触发器必须为1</p></li><li><p>中断响应时间：当前<strong>指令周期结束</strong>。（而不是指令执行结束）</p><p>（2， 3 为中断响应的充分必要条件）</p></li></ol></li><li><p>CPU响应中断后如何保护现场  </p></li><li><p>中断响应结束之后如何阻止源程序的执行转入中断服务程序的入口地址</p></li><li><p>中断处理结束后，CPU如何恢复现场</p></li><li><p>中断处理结束过程中出现了新的中断请求,CPU该如何处理</p></li></ol><p><strong>处理办法</strong> ：中断处理系统中配置响应的软件和硬件</p><h4 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h4><ul><li><p>实现多重中断的条件：</p><ol><li><p>提前设置开中断指令 </p></li><li><p>优先级高的中断源有权屏蔽优先级别低的中断源</p></li></ol></li><li><p>中断屏蔽的结果</p><ol><li>屏蔽触发器与屏蔽字</li><li>改变中断优先登记以及运行轨迹的变化</li></ol></li><li><p>多重中断的断点保护</p><ol><li><strong>中断响应轨迹图</strong></li><li>设置中断屏蔽字改变中断响应优先级</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CPU基础概念&quot;&gt;&lt;a href=&quot;#CPU基础概念&quot; class=&quot;headerlink&quot; title=&quot;CPU基础概念&quot;&gt;&lt;/a&gt;CPU基础概念&lt;/h2&gt;&lt;p&gt;CPU功能： 指令控制，操作控制，时间控制，数据加工&lt;/p&gt;
&lt;p&gt;CPU控制方式：同步控制，异步控
      
    
    </summary>
    
    
      <category term="计组理论 CPU" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA-CPU/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库设计理论简介</title>
    <link href="http://yoursite.com/2018/05/02/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/05/02/关系数据库设计理论/</id>
    <published>2018-05-02T09:28:16.232Z</published>
    <updated>2018-05-03T01:00:16.508Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdn.net/20161228171824096?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFuZmFuNDU2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul><li>X→Y，表示Y依赖于X；</li><li>X→Y，且Y→X不成立，Y→Z，则X→Z，表示Z传递依赖于X。</li></ul><h4 id="函数依赖性质"><a href="#函数依赖性质" class="headerlink" title="函数依赖性质"></a>函数依赖性质</h4><ul><li><p>自反性</p></li><li><p>传递性</p></li><li><p>。。。。</p></li></ul><h4 id="函数依赖的种类"><a href="#函数依赖的种类" class="headerlink" title="函数依赖的种类"></a>函数依赖的种类</h4><p>（<strong>完全函数依赖</strong>：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y非函数依赖于X的子集，则称Y完全函数依赖于X。X  f &gt;Y）—&gt; Y依赖于X,但不依赖X的子集。</p><p>（<strong>部分函数依赖</strong>：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y函数依赖于X的子集）</p><p>（<strong>函数依赖</strong>：某个属性集决定另一个属性集时，例如学生学号属性集Sno决定学生姓名属性集Sname，称Sname函数依赖于Sname ）</p><p>（<strong>平凡函数依赖</strong>：Y函数依赖于X,并且Y包含于X，例如（Sno）-&gt;(Sno)、（Sno、Sname）-&gt;（Sno））</p><p>（<strong>非平凡函数依赖</strong>：Y函数依赖于X,并且Y不包含于X,例如(Sno,Sname）-&gt;（Ssex））</p><h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><p>候选键： 能够唯一表示一个元组，且不含多属性<br>超键： 是指能够唯一表示一个元组的属性集<br>主属性：表示候选键中的属性<br>非主属性：不包含在主键中的属性</p><p><strong>判断主键的方法</strong> ：若属性集为{ A , B, C}，A+ = ABC。 则A为主键。（属性闭包判断法） </p><h3 id="范式-Normal-Forms"><a href="#范式-Normal-Forms" class="headerlink" title="范式 Normal Forms"></a>范式 Normal Forms</h3><p>（1）第一范式1NF：关系中的所以属性值都是不可分割的原子值；<br>（2）第二范式2NF：如果关系是1NF，且每个非主属性都完全依赖于候选键；<br>（3）第三范式3NF：如果关系是1NF，且每个非主属性都不传递依赖于候选键；<br>（4）<strong>鲍依斯-科得(巴斯)范式</strong>BCNF范式：如果关系是1NF，且每个属性都不传递依赖于候选键。</p><h3 id="属性闭包"><a href="#属性闭包" class="headerlink" title="属性闭包"></a>属性闭包</h3><p>定义：闭包就是由一个属性直接或间接推导出的所有属性的集合。</p><p>表示：B的闭包用B+表示。</p><p>计算：关系R的属性集X的闭包的步骤如下： </p><ol><li>设最终将成为闭包的属性集是Y，把Y初始化为X；<br> .  检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将                 其加入到Y中； </li><li>重复第二步，直到没有属性可以添加到属性集Y中为止。 最后得到的Y就是X＋</li></ol><p>举例：</p><p>例1： R = {A,B,C,D,E}</p><p>​         F = {B→CD， D→E, B→A, E→C， AD→B }</p><p>​             则 B+ = B ;    B+ = BCD;  B+ = BCDA； B+ = BCDAE。（推导过程是属性依赖传递的过程。</p><p>​            所以最终B+ 包含了R中所有属性。 故<strong>B is a key for R。</strong></p><p>例2： 有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)闭包。 </p><p>(1) 令X={AE}，X(0)=AE</p><p>(2)在F中寻找尚未使用过的左边是AE的子集的函数依赖，结果是: A→D， E→C；所以 X(1)=X(0)DC=ACDE，     显然 X(1)≠X(0).</p><p>(3) 在F中寻找尚未使用过的左边是ACDE的子集的函数依赖， 结果是: CD→I；所以 X(2)=X(1)I=ACDEI。虽然X（2）≠X(1)，但F中寻找尚未使用过函数依赖的左边已经没有X（2）的子集，所以不必再计算下去，即(AE)+=ACDEI。</p><p>例3：f={a-&gt;b，b-&gt;c，a-&gt;d，e-&gt;f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}</p><h3 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h3><h4 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h4><p>R的无损分解为X Y，那么 x∩y →x  或者 x∩y → y.   </p><h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h3><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>在连接运算当中，一种最常用的连接是自然连接。如果关系R与S具有相同的属性组B，且该属性组的值相等时的连接称为自然连接，结果关系的属性集合为<strong>R的属性并上S减去属性B的属性</strong>集合。</p><p>参考的文章</p><p><a href="https://www.cnblogs.com/bewolf/p/4445027.html" target="_blank" rel="noopener">函数依赖集闭包、属性集闭包、超键、候选键和最小函数依赖集</a></p><p><a href="https://www.cnblogs.com/makeupforever-carrie/p/6837325.html" target="_blank" rel="noopener">四种范式的实例</a></p><p><a href="https://blog.csdn.net/fanfan4569/article/details/53910670" target="_blank" rel="noopener">函数依赖不懂看这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20161228171824096?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmFuZmFuNDU2OQ==/font/5a6L5L2T/fontsiz
      
    
    </summary>
    
    
      <category term="数据库理论" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ant,junit,vim,java</title>
    <link href="http://yoursite.com/2018/05/01/Leanring_report-ant-junit-vim-java/"/>
    <id>http://yoursite.com/2018/05/01/Leanring_report-ant-junit-vim-java/</id>
    <published>2018-05-01T08:35:48.000Z</published>
    <updated>2018-05-03T00:55:37.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编辑器之神–Vim"><a href="#编辑器之神–Vim" class="headerlink" title="编辑器之神–Vim"></a>编辑器之神–Vim</h1><h2 id="Vim简介"><a href="#Vim简介" class="headerlink" title="Vim简介"></a>Vim简介</h2><p>Vim是一款上古编辑器，被广大程序员成为编辑器之神，这与之强大的编辑功能和编辑效率是分不开的。和Emace一样都在代码行业享有盛誉。vim最为重要的一点就是一切操作几乎可以舍弃鼠标，熟悉了vim命令的话，光靠键盘指令可以使开发效率迅速提高。</p><h2 id="Vim的安装"><a href="#Vim的安装" class="headerlink" title="Vim的安装"></a>Vim的安装</h2><h3 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下"></a>Linux下</h3><p>在Ubuntu平台下控制台敲入下列指令即可自动安装。</p><blockquote><p>sudo apt-get install vim</p></blockquote><h3 id="Windows下"><a href="#Windows下" class="headerlink" title="Windows下"></a>Windows下</h3><p>去<a href="http://www.vim.org/" target="_blank" rel="noopener">官网</a> 直接下载使用。</p><h2 id="Vim常用指令和教程"><a href="#Vim常用指令和教程" class="headerlink" title="Vim常用指令和教程"></a>Vim常用指令和教程</h2><p>首先值得注意的一点就是其实vim是自带教程的Vimtutor,s使用方法是linux下输入命令<strong>vimtutor</strong>,即可开启教程，这属于官方教程，  最为详细，没有之一。</p><p>在这里介绍一些常用的vim命令，有利于快速上手vim。</p><h4 id="1-创建或打开文件-vim-filename"><a href="#1-创建或打开文件-vim-filename" class="headerlink" title="1. 创建或打开文件 vim filename"></a>1. 创建或打开文件 <code>vim filename</code></h4><blockquote><p>vim helloworld.java</p></blockquote><h4 id="2-添加内容"><a href="#2-添加内容" class="headerlink" title="2.添加内容"></a>2.添加内容</h4><p>一开始进入处于<strong>正常模式</strong>在编辑窗口直接输入<code>i,a,o</code>等字符可以进入<strong>输入模式</strong>，可以在屏幕下方看到<em>insert</em>单词。按左上角<code>Esc</code>键可以回到正常模式，使用各种方便的指令。以下指令均在<strong>正常模式</strong>下进行。</p><h4 id="3-删除内容"><a href="#3-删除内容" class="headerlink" title="3.删除内容"></a>3.删除内容</h4><p><code>dd</code>可以删除光标所在的一整行。</p><p><code>ndd</code>可以删除光标以下的n行</p><h4 id="4-复制内容"><a href="#4-复制内容" class="headerlink" title="4. 复制内容"></a>4. 复制内容</h4><p><code>yy</code>可以复制光标所在行的字符<br><code>nyy</code>可以复制光标以下的n行字符</p><h4 id="5-粘贴内容"><a href="#5-粘贴内容" class="headerlink" title="5.粘贴内容"></a>5.粘贴内容</h4><p><code>p/P</code>作用时粘贴字符，小写p将已复制的字符粘贴到光标以下，大写P将字符粘贴到光标以上。</p><h4 id="6-撤销内容"><a href="#6-撤销内容" class="headerlink" title="6. 撤销内容"></a>6. 撤销内容</h4><p>撤销指令使用<code>u</code>,类似于windows上的<code>ctrl z`</code>。</p><h4 id="7-保存文件"><a href="#7-保存文件" class="headerlink" title="7. 保存文件"></a>7. 保存文件</h4><p>先进入正常模式<code>Esc</code>，然后输入<code>:</code>。然后输入：</p><ul><li><code>q</code> 离开vim</li><li><code>w</code> 保存内容</li><li><code>wq</code> 保存内容并离开vim,回到命令行</li></ul><p>其他还有许多可以提高效率的指令在这里就不多赘述啦。</p><hr><p>​            </p><h1 id="Java知识入门"><a href="#Java知识入门" class="headerlink" title="Java知识入门"></a>Java知识入门</h1><p>###初探java</p><p>从hello world入门, 初步体会java这一门面向对象编程语言。在HelloWorld.java文件中键入以下代码。（注意文件名称必须和<strong>类名</strong>一致）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到的编译指令是</p><blockquote><p>javac HelloWorld.java</p></blockquote><p>命令行没有弹出其他消息，即为编译成功。</p><p>执行指令是</p><blockquote><p>java HelloWorld</p></blockquote><p>这里用到两个重要指令<code>javac</code> <code>java</code> ，分别是编译和执行指令。</p><p>###基础知识</p><p>由于已经学习过C++，java语言在一定程度上和C++是类似的，所以在Java入门学习上可以直接跳过基础语法，对象和类，基本数据类型，运算符，循环结构，分支结构。</p><h3 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h3><h3 id="java继承"><a href="#java继承" class="headerlink" title="java继承"></a>java继承</h3><p>java继承的概念和C++类似，同样是定义一个父类，然后定义一个子类，来继承父类的属性，和C++不同的是，java用关键字<code>extends</code> 来表示继承关系。继承格式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类  </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####继承的特性</p><ul><li><p>子类拥有父类非private的属性，方法。</p></li><li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。</p></li><li><p>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。</p></li><li><p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。</p><p>​</p></li></ul><p>####继承的关键字</p><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">extends</td><td style="text-align:center">单一继承</td></tr><tr><td style="text-align:center">implements</td><td style="text-align:center">继承多个父类</td></tr><tr><td style="text-align:center">super</td><td style="text-align:center">实现对父类父类成员的访问，引用父类</td></tr><tr><td style="text-align:center">this</td><td style="text-align:center">指向自己的引用</td></tr><tr><td style="text-align:center">final</td><td style="text-align:center">将自身定义为不可继承的类</td></tr></tbody></table><h3 id="java重写和重载"><a href="#java重写和重载" class="headerlink" title="java重写和重载"></a>java重写和重载</h3><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>#####重写含义</p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, <strong>返回值和形参</strong>都不能改变。<strong>即外壳不变，核心重写！</strong>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。。</p><h5 id="重写方法的原则"><a href="#重写方法的原则" class="headerlink" title="重写方法的原则"></a>重写方法的原则</h5><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li></ul><h5 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.move(); <span class="comment">// 应用super类的方法</span></span><br><span class="line">      System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象</span></span><br><span class="line">      b.move(); <span class="comment">//执行 Dog类的方法</span></span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是</p><blockquote><p>狗可以跑和走</p></blockquote><p>可以看到在Dog类中重写了move()方法，传入的参数和返回类型和原来父类的方法一致，但内部代码可以修改。</p><p>####重载</p><p>#####重载含义</p><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><h5 id="重载的规则"><a href="#重载的规则" class="headerlink" title="重载的规则"></a>重载的规则</h5><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h5 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下两个参数类型顺序不同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"returntest3"</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"returntest4"</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Overloading o = <span class="keyword">new</span> Overloading();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>,<span class="string">"test3"</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">"test4"</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是</p><blockquote><p>test1</p><p>test2</p><p>test3</p><p>test4</p></blockquote><p>从运行结果看，调用的传参不同的函数顺序执行。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态就是对象多种表现形式的体现。</p><p>#####多态存在的三个必要条件</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><p>这里提供一份代码以便理解。大意就是一个抽象父类声明但不定义一个方法，在其他子类中可以重写这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃鱼"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"抓老鼠"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"看家"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###java组件部分设计</p><h3 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h3><p>在本次实训实验中利用了Swing这个java的<strong>GUI工具包</strong>，以实现一个简单的计算器。其中的主要用途是引用这些包的相关控件，控件的相关接口，同时给这些控件注册事件，建立事件处理逻辑。</p><p>介绍控件，首先应提到<strong>JComponet</strong> 。</p><p><strong>JComponent</strong></p><p>Swing 的整个可视组件库的基础构造块是 JComponent。它是所有组件的父类。它是一个<strong>抽象类</strong>，所以不能创建 JComponent，但是作为类层次结构的结果，从字面意义来说它包含了数百个函数，Swing 中的每个组件都可以使用这些函数。</p><p>注意： 每一个控件都是一个类，具有许多接口函数，在eclipes这个IDE上可以轻松获取。使用方法：鼠标移动到某一个控件类名，按ctrl键点击类名，即可弹出这个控件类里头详细的函数定义。</p><h4 id="常用的控件集合"><a href="#常用的控件集合" class="headerlink" title="常用的控件集合"></a>常用的控件集合</h4><table><thead><tr><th>控件</th><th>用途</th></tr></thead><tbody><tr><td>JLabel</td><td>用作文本描述</td></tr><tr><td>JButton</td><td>按钮</td></tr><tr><td>JFrame</td><td>窗口</td></tr><tr><td>JPanel</td><td>控件容器</td></tr><tr><td>JTextField</td><td>文本输入框</td></tr><tr><td>JCheckBox</td><td>确认框</td></tr><tr><td>GridLayout</td><td>生成网格状的布局</td></tr></tbody></table><p><em>Tips: 任何一个控件都有Add()的方法，意味着每一个控件都可以添加到另外一个控件里。</em></p><h4 id="注册事件的方法"><a href="#注册事件的方法" class="headerlink" title="注册事件的方法"></a>注册事件的方法</h4><p>以下以button为例，进行两种常用方式的注册。</p><h5 id="方法1-匿名内部类实现"><a href="#方法1-匿名内部类实现" class="headerlink" title="方法1 匿名内部类实现"></a>方法1 匿名内部类实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(  </span><br><span class="line">        <span class="keyword">new</span> ActionListener()&#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;  </span><br><span class="line">                 System.out.println(<span class="string">"你按了按钮一"</span>);  </span><br><span class="line">             &#125;  </span><br><span class="line"> &#125;);   <span class="comment">//调用监听函数并定义监听事件</span></span><br></pre></td></tr></table></figure><h5 id="方法2-利用一般内部类实现"><a href="#方法2-利用一般内部类实现" class="headerlink" title="方法2 利用一般内部类实现"></a>方法2 利用一般内部类实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(<span class="keyword">new</span> Button2ActionListener()); </span><br><span class="line">     </span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Button1ActionListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;  </span><br><span class="line">           System.out.println(<span class="string">"你按了按钮一"</span>);     </span><br><span class="line">     &#125;     </span><br><span class="line"> &#125;  <span class="comment">//将事件处理为一个类事件</span></span><br></pre></td></tr></table></figure><p>用了以上的基础知识就可以解决一个简单计算器的实现啦。</p><h1 id="Junit-学习和使用"><a href="#Junit-学习和使用" class="headerlink" title="Junit 学习和使用"></a>Junit 学习和使用</h1><p>###Junit是什么</p><p>JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。</p><p><strong>JUnit提供：</strong></p><ul><li>断言测试预期结果。</li><li>测试功能共享通用的测试数据。</li><li>测试套件轻松地组织和运行测试。</li><li>图形和文本测试运行。</li></ul><p><strong>JUnit用于测试：</strong></p><ul><li><p>整个对象</p></li><li><p>对象的一部分 - 交互的方法或一些方法</p></li><li><p>几个对象之间的互动(交互)</p><p>​</p></li></ul><p>###JUnit的特点</p><ul><li>JUnit是用于编写和运行测试的开源框架。</li><li>提供了注释，以确定测试方法。</li><li>提供断言测试预期结果。</li><li>提供了测试运行的运行测试。</li><li>JUnit测试让您可以更快地编写代码，提高质量</li><li>JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。</li><li>JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。</li><li>JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。</li><li>Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。</li></ul><table><thead><tr><th><strong>注解</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>@Test</strong>public void method()</td><td>测试注释指示该公共无效方法它所附着可以作为一个测试用例。</td></tr><tr><td><strong>@Before</strong>public void method()</td><td>Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。</td></tr><tr><td><strong>@BeforeClass</strong>public static void method()</td><td>BeforeClass注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。</td></tr><tr><td><strong>@After</strong>public void method()</td><td>After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等)</td></tr><tr><td><strong>@AfterClass</strong>public static void method()</td><td>当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于BeforeClass)的方法必须定义为静态。</td></tr><tr><td><strong>@Ignore</strong>public static void method()</td><td>当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为@Ignore的方法将不被执行。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编辑器之神–Vim&quot;&gt;&lt;a href=&quot;#编辑器之神–Vim&quot; class=&quot;headerlink&quot; title=&quot;编辑器之神–Vim&quot;&gt;&lt;/a&gt;编辑器之神–Vim&lt;/h1&gt;&lt;h2 id=&quot;Vim简介&quot;&gt;&lt;a href=&quot;#Vim简介&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="编程软件 vim java" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%BD%AF%E4%BB%B6-vim-java/"/>
    
  </entry>
  
  <entry>
    <title>Verilog 设计初步</title>
    <link href="http://yoursite.com/2018/04/30/Verilog%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/04/30/Verilog设计初步/</id>
    <published>2018-04-29T16:37:36.125Z</published>
    <updated>2018-05-03T00:56:27.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog设计初步"><a href="#Verilog设计初步" class="headerlink" title="Verilog设计初步"></a>Verilog设计初步</h1><p>##Verilog 代码模板</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句关键字字母都为小写字母，大小写敏感</span></span><br><span class="line"><span class="comment">//硬件思维来写代码</span></span><br><span class="line"><span class="comment">//命名不能以数字开头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> &lt;顶层模块名&gt; (输入输出端口列表) <span class="comment">//定义输入输出端口列表</span></span><br><span class="line"><span class="keyword">output</span> 输出端口列表；  <span class="comment">//输出端口生声明</span></span><br><span class="line"><span class="keyword">input</span>  输入端口列表；      <span class="comment">//输入输出端口生命 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*定义数据类型，功能定义，函数实现*/</span></span><br><span class="line">    <span class="keyword">reg</span>  信号名；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逻辑功能定义</span></span><br><span class="line"><span class="keyword">assign</span>&lt;结果信号名&gt; = &lt;表达式&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用always块描述逻辑功能</span></span><br><span class="line">    <span class="keyword">always</span> @(&lt;敏感信号&gt;)   </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//过程赋值运算</span></span><br><span class="line">            <span class="comment">//语句，if else while task</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//调用其他模块</span></span><br><span class="line">    &lt;调用模块名module_name&gt;&lt;例化模块名&gt;(&lt;端口列表&gt;)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//门元件例化</span></span><br><span class="line">    门元件关键字&lt;例化门元件名&gt;(&lt;端口列表port_list&gt;);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>四位选择器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux4_1(out,in0, in1, in2,in4,sel);</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">input</span> in0,in1,in2,in3;</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">1</span>:<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">reg</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @（in0 <span class="keyword">or</span> in1 <span class="keyword">or</span> in2 <span class="keyword">or</span> in3 <span class="keyword">or</span> sel)</span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            <span class="keyword">case</span>(sel)</span><br></pre></td></tr></table></figure><h2 id="数据类型及运算符"><a href="#数据类型及运算符" class="headerlink" title="数据类型及运算符"></a>数据类型及运算符</h2><ul><li>整数类型<ul><li>构成是：字符宽度+进制+数值。</li><li>例如：2’0xd5;  宽度为2的十六进制d5。</li></ul></li><li>逻辑类型<ul><li>高低电平 1 0，电路里体现为电压的区间</li><li>x：未知</li><li>z:   高阻</li></ul></li><li>net类型<ul><li>常用的是wire。用法是 wire[7:0] databus。 //databus宽度8</li></ul></li><li>寄存器类型<ul><li>reg </li><li>integer</li><li>time</li><li>real</li><li>realtime</li></ul></li><li>parameter参数 <ul><li>用来定义符号常量。 parameter sel = 8’ha3。</li></ul></li><li>向量类型</li><li>逻辑运算符</li><li>位运算符</li><li>三目运算</li><li>位拼接运算符</li></ul><p>下例采用数据流方式描述1位全加器。</p><p>在本例中，有两个连续赋值语句。这些赋值语句是并发的，与其书写的顺序无关。只要<br>连续赋值语句右端表达式中操作数的值变化(即有事件发生), 连续赋值语句即被执行。如果A<br>变化，则两个连续赋值都被计算，即同时对右端表达式求值，并将结果赋给左端目标。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul><li>initial</li><li>always @（敏感信号）<ul><li>@ (posedge clk) 上升沿</li><li>@ (negedge clk) 下降沿触发</li></ul></li><li>赋值语句<ul><li>连续赋值语句assign 只要连续赋值语句右端表达式中操作数的值变化, 连续赋值语句即被执行。</li><li>阻塞赋值 a = b;         ————-非时序赋值（组合）</li><li>非阻塞赋值  a&lt;=b      ————时序赋值中使用  </li><li>时序和组合在电路上的表现是时序赋值过程中需要等待时钟沿来触发。</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="设计特点"><a href="#设计特点" class="headerlink" title="设计特点"></a>设计特点</h2><h4 id="层次化模块化"><a href="#层次化模块化" class="headerlink" title="层次化模块化"></a>层次化模块化</h4><p>顶层模块和底层模块的设计方法，将模块细分为若干个子模块，在底层实现子模块功能，在顶层组合各个子模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Verilog设计初步&quot;&gt;&lt;a href=&quot;#Verilog设计初步&quot; class=&quot;headerlink&quot; title=&quot;Verilog设计初步&quot;&gt;&lt;/a&gt;Verilog设计初步&lt;/h1&gt;&lt;p&gt;##Verilog 代码模板&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="verilog 计组实验" scheme="http://yoursite.com/tags/verilog-%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
