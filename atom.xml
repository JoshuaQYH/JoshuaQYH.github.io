<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KnowMyself</title>
  <icon>https://www.gravatar.com/avatar/040d8fc733a154c9e497a47d7ba2f04b</icon>
  <subtitle>QiuYH&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joshuaqyh.github.io/"/>
  <updated>2019-06-04T17:44:25.732Z</updated>
  <id>https://joshuaqyh.github.io/</id>
  
  <author>
    <name>Qiuyihao</name>
    <email>576261090@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习 | SSD 目标检测思想总结</title>
    <link href="https://joshuaqyh.github.io/2019/06/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-SSD-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%80%9D%E6%83%B3%E6%80%BB%E7%BB%93/"/>
    <id>https://joshuaqyh.github.io/2019/06/05/深度学习-SSD-目标检测思想总结/</id>
    <published>2019-06-04T17:10:06.000Z</published>
    <updated>2019-06-04T17:44:25.732Z</updated>
    
    <content type="html"><![CDATA[<p>本文不赘述SSD的算法流程，主要总结SSD的几处重点做总结。</p><ul><li><strong>多尺度特征图进行预测</strong></li></ul><p>SSD使用多个尺度的特征图进行检测，其目的是使用大的特征图检测相对较小的目标，小的特征图主要负责检测大的目标。</p><p>那么问题来了，大的特征图对检测较大目标的贡献是否大于小的特征图呢。</p><p>应该不会，模型给每个单元设置了一个比较小的先验框，并不是很大，先验框的感受野并不会占图片太大的比例，即便是偏移值也不会偏移较大。</p><ul><li><strong>采用卷积层进行预测</strong></li></ul><p>与YOLO层最后采用全连接不同，SSD直接采用卷积后的特征图来代表检测值。</p><ul><li><strong>设置先验框。</strong></li></ul><p>基于anchor的理念，在每个单元设置尺度或者长宽比不同的先验框，对于每一个先验框都有对应的一套检测值（边界框的中心位置和相对先验框位置偏移量，以及边界框的偏移量）。在实验中，先验框的数目高达9000+。</p><ul><li><strong>hard negative mining 解决正负样本不均衡的问题</strong> </li></ul><p>anchor的方法的坏处就是会cover许多背景，这些背景属于负样本，在训练过程中将会造成样本严重不均衡的问题。后续提出的focal loss对缓解该问题有一定的帮助，而SSD算法则是采用的hard negative mining的技术，对负样本进行抽样，抽样时按照置信度误差（置信度为0~1，误差越大，置信度越小）进行降序排列，选取误差较大的top - k 作为训练的负样本，以保证正负样本的比例接近1：3，减少负样本的数目。</p><ul><li><strong>先验框匹配原则。</strong> <ul><li>ground truth box 与 IOU最大的先验框匹配，这个得到匹配的先验框被成为正样本先验框，但是gt box毕竟数目很少，会有很多的先验框作为负样本。</li><li>除了使用困难样本挖掘技术之外，SSD增加了一条匹配原则，就是某个负样本先验框如果与gt box 的IOU的大于某个阈值（一般为0.5）的话，那么这个负样本就被认为是正样本。</li></ul></li></ul><p>其实第一条原则只是第二条原则的一个特例而已，一般来说，有了第二个原则，那么第一个原则就成立了（不过实际代码还是都实现了这两个原则）。</p><p>问题又来了，这样匹配就会出现一个gt box对应多个先验框，这样一个gt box就会有多个预测框。我们使用NMS（非最大化抑制）来去除重复多余的框。</p><ul><li><strong>数据扩增</strong></li></ul><p>主要采用的技术有水平翻转（horizontal flip），随机裁剪加颜色扭曲（random crop &amp; color distortion），随机采集块域（Randomly sample a patch）（获取小目标训练样本），</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文不赘述SSD的算法流程，主要总结SSD的几处重点做总结。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多尺度特征图进行预测&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SSD使用多个尺度的特征图进行检测，其目的是使用大的特征图检测相对较小的目标，小的特征图主要负责检测大
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>工作流 | 云系统中基于协同多种群优化算法的多目标工作流调度</title>
    <link href="https://joshuaqyh.github.io/2019/06/04/%E8%AE%BA%E6%96%87-%E4%BA%91%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E5%A4%9A%E7%A7%8D%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%B0%83%E5%BA%A6/"/>
    <id>https://joshuaqyh.github.io/2019/06/04/论文-云系统中基于协同多种群优化算法的多目标工作流调度/</id>
    <published>2019-06-04T00:03:04.000Z</published>
    <updated>2019-06-11T11:56:35.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 论文：Multi-objective workflow scheduling in cloud system based on cooperative multi-swarm optimization algorithm</p><p>作者：YAO Guang-shun(姚光顺) DING Yong-sheng(丁永生) HAO Kuang-rong(郝矿荣)</p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本算法名为多种群多目标优化算法（MSMOOA），其目的就是提高云系统中工作流调度的性能。该算法受物种划分为种群的思想启发，物种可根据不同目标划分得到不同的种群，但同时种群有具备一定的信息共享。基于此，数据中心的每一个物理机都可认为是一个种群，均采用多目标粒子群群优化算法来搜寻单一目标的非支配解。每一个种群中的粒子都可以被划分为两个类别，采用不同的策略进行协同进化。</p><p>其中一类可以与多个种群进行同步通信，提高种群间的信息共享程度，另一类粒子则负责在同一个种群内部进行交换信息。</p><p>而且，为了避免弹性可用资源的影响，本文采用了一个管理服务器来收集云数据中心中用于调度的可用资源。</p><p>本文使用混合并行的工作流应用来评估本算法，并和其他相关的方法进行对比。结果显示采用本算法有更好的性能提升。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>工作流技术应用于对科学和工业应用的建模。一个工作流任务通常具备许多具有优先约束的子任务。其中任务的输入输出之间具有依赖关系。</p><p>在分布式异构计算系统中，如何将工作流的任务调度到可用的计算资源中 np完全问题，是一个主要的挑战。当下学界已经提出了许多针对分布式计算系统中不同目标、不同视角下工作流调度的有效算法。</p><p>最近，云计算成为一种革命性的范式，适合于以即付即用的模式改变向客户提供异构服务和计算资源的方式。有了云计算，客户可以在瞬间扩展到巨大的容量，而无需支付软件许可证和投资新的基础设施。</p><p>云计算背景下的工作流调度难点在于要考虑多种不同的因素。第一，消费者和云服务供应商的目标不同，客户通常对最小化完工时间和应用程序的成本感兴趣，而云服务供应商通常对最大化资源利用率、最小化能源消耗或用户公平性感兴趣。</p><p>所以调度问题必须处理为一个多目标优化问题(MOOP)，其目标是优化多个可能存在冲突的准则，其中不可能找到所有目标的全局最优解。此外，云数据中心通过虚拟化技术以虚拟机(VM)的形式为客户提供服务，运行的VM可以根据系统的工作负载动态伸缩。因此，调度策略应该能够在更改发生后尽快检查可用的计算资源。</p><p>当前工作的缺陷主要有：1. 通过把所有的目标集中在一个分析函数中的单目标问题。计算出的解决方案依赖于所选的权重，而这些权重通常是由先验决定的，不需要了解工作流、基础设施，通常也不需要了解要解决的问题。因此，如果权重不能准确地捕捉用户的偏好，计算出的解决方案可能不能满足所解决问题的要求。2. 其他方法基于按顺序方式对不同的目标进行排序。但是，目标的数量是有限的，目标优化的顺序需要某种优先信息，而这些信息可能很难得到。</p><p>近年来，基于帕累托的多目标任务调度方法得到了广泛的应用。主要有：1. 基于实例库和帕累托解的混合遗传算法求解最大完工时间和能耗优化问题的帕累托解；2. 基于帕累托的启发式列表调度算法，为客户提供了一套关于完工时间和能耗的折衷最优解。但是局限在于只关注两个目标。上述方法都没有集成到云数据中心的结构中，云数据中心由多个物理机器(PMs)组成，可以通过内部网在这些PMs之间共享信息，而且未能考虑云计算环境下计算资源的动态变化。</p><p>在这项工作中，我们也采取了三个目标(<strong>时间、成本和能源</strong>）。并设计了一种用于云计算工作流调度的多群多目标优化算法(MSMOOA)。</p><p>为了获得调度所需的计算资源，首先设计了一个数据中心模型。该模型采用manager服务器接收客户提交的工作流后收集可用计算资源的信息，有效地避免了弹性资源对调度结果的影响。MSMOOA利用云数据中心的结构来搜索非主导调度方案。在MSMOOA中，每个可用的PM都被看作是一个群，并采用改进的多目标粒子群优化算法(MOPSOA)来寻找一个目标的非优势解。通过PMs之间的内部网连接，一个群中的一些粒子可以从其他群中获取信息，这些粒子的速度更新也受到其他群状态的影响，促进了群之间的信息共享与协作。我们还设计了一些新的更新策略来提高粒子的搜索能力。</p><p>我们的主要贡献在于：</p><ol><li>提出了一种新的多群协同机制，并对该机制中粒子速度的更新进行了修正。粒子速度的更新不仅受个体和全局最优的影响，而且受群体最优的影响。</li><li>提出的MSMOOA算法用于云系统中的多目标工作流调度，是第一个考虑云数据中心结构特点的工作流调度算法。</li></ol><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><h2 id="多目标问题概念"><a href="#多目标问题概念" class="headerlink" title="多目标问题概念"></a>多目标问题概念</h2><p>现实世界中的大多数工程问题都是多目标优化问题。MOOP的目标是找到一组好的权衡解决方案，决策者可以根据自己的偏好从中选择一个。由于Pareto给出了多目标优化中最常见的最优定义，因此提出了许多求解MOOPs的研究工作。</p><p>由于MOOP涉及多个目标，所以对于所有目标，不存在单一的最优解决方案。应该找到在所有目标之间具有权衡或良好折衷的解决方案，通常采用帕累托最优。相关的帕累托概念如下：</p><ol><li><p>帕累托支配。</p></li><li><p>帕累托最优。</p></li><li><p>帕累托最优集合。</p></li><li><p>pareto最优前沿</p><p>见Definition 1~4.</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190604090616.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="云数据中心模型"><a href="#云数据中心模型" class="headerlink" title="云数据中心模型"></a>云数据中心模型</h2><p>本工作中使用的云数据中心提供了云服务提供商以VM的形式提供的一组资源，该资源采用即付即用模型。在我们的模型中，云数据中心由一组PMs组成。</p><p>根据以上情景，我们可以抽象出两种对象，一个是数据中心由多个物理机组成，而一个物理机因为虚拟化技术的原因，可以建模成不同的虚拟机：</p><ol><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605143320.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605143240.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><p>每个PM都可以通过内部网与位于同一数据中心的其他PM通信，所有这些与manager服务器连接的PM组成了云数据中心。每个PM都可以通过内部网与位于同一数据中心的其他PM通信，所有这些与manager服务器连接的PM组成了云数据中心。云数据中心通过manager服务器通过Internet向客户提供服务，manager服务器保存云数据中心中可用资源的信息，接收客户提交的工作流，并存储发现的非主导解决方案。manager 服务器接受来自客户的工作流，首先第一步将会检查VM和PM的可用信息。</p><p><strong>该模型不允许抢占情况的发生，一旦一个任务开始就不会被中断。每一个VM一次只能执行一个任务。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605151814.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="云应用模型"><a href="#云应用模型" class="headerlink" title="云应用模型"></a>云应用模型</h2><p>我们使用DAG 有向无环图来表示用户工作流应用提交到云计算系统的过程。</p><p>DAG = V = （T，E）T 代表任务节点，E 代表任务控制连接和数据流关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605152858.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>任务之间的关系有串行，并行，选择进行等关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605152928.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们使用$pred(t_i)$ 和 $succ(t_i)$ 来表示当前任务的前继任务和后继任务。</p><p>而每个任务则使用$len(t_i)$  任务的长度来表示。长度可以通过执行的指令数来度量，目的是反映该任务的执行时间和能源消耗。</p><h2 id="调度模型"><a href="#调度模型" class="headerlink" title="调度模型"></a>调度模型</h2><h3 id="Makespan-完成时间"><a href="#Makespan-完成时间" class="headerlink" title="Makespan 完成时间"></a>Makespan 完成时间</h3><p>我们模型的第一个objective O1，是指运行在一个VM上的一个任务的完成时间，我们可以计算为最长输入传输时间的和任务计算时间的总和。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605154150.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>$sched(t_p)$ 代表执行任务tp的VM；</p><p>$Data_{pr}$ 是从任务 $t_p$ 传输到 任务$t_r$ 的数据大小。</p><p>$b_{sched(t_p) -&gt; ij}$ 代表$sched(t_p)$ VM到$ij$ VM 的带宽大小。</p><p>$len(t_r)$  代表任务$p_r$ 的长度。</p><p>$s_{ij}$ 是VM的计算速度。</p><p>如果考虑任务之间前后的关系，那么实际完成时间建模如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605155846.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>整个DAG任务的完成时间取所有任务的最长完成时间。（？？为啥不是加起来。。。</p><h2 id="经济费用"><a href="#经济费用" class="headerlink" title="经济费用"></a>经济费用</h2><p>现在云服务商主要采用两种付费模式，一个是按流量付费，一个是使用时间付费，即付即用。</p><p>于是有了我们模型的第二个objective 经济费用 O2。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605161753.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="能源消耗"><a href="#能源消耗" class="headerlink" title="能源消耗"></a>能源消耗</h2><p>以下是第三个目标，能源消耗。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605162343.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="调度模型-1"><a href="#调度模型-1" class="headerlink" title="调度模型"></a>调度模型</h2><p>综合以上三个目标，本文建立的多目标优化调度模型如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605163511.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="基于多种群优化算法的多目标工作流调度"><a href="#基于多种群优化算法的多目标工作流调度" class="headerlink" title="基于多种群优化算法的多目标工作流调度"></a>基于多种群优化算法的多目标工作流调度</h1><h2 id="粒子群优化算法PSO"><a href="#粒子群优化算法PSO" class="headerlink" title="粒子群优化算法PSO"></a>粒子群优化算法PSO</h2><p>在本模型中，候选的解决方法视为粒子，多个解决方法作为一个种群。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190605170505.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一个粒子在当前搜索空间的位置都是表示一个潜在的解，需要在不断的迭代中更新解。</p><p>在每一个迭代中，每一个粒子依据公式14，15来进行位置和速度的更新。</p><h2 id="多群多目标优化-MSMOOA"><a href="#多群多目标优化-MSMOOA" class="headerlink" title="多群多目标优化 MSMOOA"></a>多群多目标优化 MSMOOA</h2><p>一个数据中心包含多个物理机（多集群群），而一个物理机就包括多个VM（粒子）。然后加以上述三个约束目标。</p><p>每一个集群的粒子被分为两类：</p><ol><li>该粒子群只属于一个粒子群，按照粒子群的规则发展；</li><li>第二类粒子群与多个群通信，并与这些群获取进化信息，这些粒子的速度和位置的更新不受群规则的影响。</li></ol><p>每个粒子群利用单群多目标优化算法MOPSO寻找单目标非优势粒子，然后不同集群获得的所有非优势粒子协同工作，最终得到全局非优势解。</p><p>与大多数现有的MOPSO算法一样，具有最大容量的外部存档称为每个PM中的本地外部存档(LEA)和全局外部存档(GEA)</p><h3 id="粒子表示"><a href="#粒子表示" class="headerlink" title="粒子表示"></a>粒子表示</h3><p>每个粒子都用一个由n个元素组成的向量表示(n是DAG中的任务总数)，每个元素都有三个整数值，分别表示DAG中的任务数量、PM的数量和VM的数量。</p><p>这个粒子表示任务1被调度到第一个PM中的第二个VM，任务2被调度到第二个PM中的第一个VM，以此类推。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611192504.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611192437.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="使用MSMOOA-处理工作流调度"><a href="#使用MSMOOA-处理工作流调度" class="headerlink" title="使用MSMOOA 处理工作流调度"></a>使用MSMOOA 处理工作流调度</h3><p>我们的工作有三个适应度函数:1) 根据式(8)最小化最大完工时间O1(V)，根据式(10)最小化经济成本O2(V)，根据式(12)最小化能耗O3(V)。</p><p>由于粒子分类，第一类遵循自身种群规则的的粒子更新速度计算为：(svi第i个粒子在第s个粒子群中的速度）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611193136.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>就像一些个体可以与自然界中的其他群体交流一样，MSMOOA中的另一类粒子也可以在其他群体中迁移，并从这些群体中获得信息。其速度更新为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611193335.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是粒子的的位置更新一样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611193429.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>更新一个粒子的最佳position best。如果当前值与先前位置不能相互支配，则选择该群体目标值最小的位置作为新的pbest。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611194209.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="2"><li>更新LEA和sbest（最优解），通过三种适应度函数对群体和LEA中的所有粒子进行评估，并通过基于帕累托优势的物种技术将非优势解加入到LEA中。如果LEA不是满的，所有非支配解都保存在LEA中。</li></ol><p>更新机制：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611194523.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="3"><li><p>为第二类粒子更新osbest。第二类粒子可以通过内部网与不同的群通信，获得这些群的sbest。对于第二类中的每个粒子，如果其中一个粒子优于其他粒子，则选择它为osbest。否则，选择粒子所属群体目标值最小的sbest作为osbest</p></li><li><p>新GEA和gbest的所有粒子。GEA是MSMOOA的输出，由所有LEAs的解组成。在更新所有LEAs之后，将这些LEAs中的解决方案添加到GEA中，并删除主导解决方案。如果归档文件的大小超过GEA的最大容量，则根据元素的密度进行截断，以保持输出的高性能。采用拥挤距离[35]估计各单元的密度。拥挤距离值越大，表示解越好。</p></li></ol><p>GEA中的所有解首先根据不同目标的适应度进行多队列排序。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190611195404.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 论文：Multi-objective workflow scheduling in cloud system based on cooperative multi-swarm optimization algorithm&lt;/p&gt;
&lt;p&gt;作者：YA
      
    
    </summary>
    
    
      <category term="工作流技术导论" scheme="https://joshuaqyh.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 领域模型入门</title>
    <link href="https://joshuaqyh.github.io/2019/05/24/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://joshuaqyh.github.io/2019/05/24/软件工程-领域模型入门/</id>
    <published>2019-05-24T02:52:22.000Z</published>
    <updated>2019-05-24T04:49:58.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="领域模型初步认识"><a href="#领域模型初步认识" class="headerlink" title="领域模型初步认识"></a>领域模型初步认识</h1><p>领域模型是常见的业务建模过程中的一个重要制品，那么领域模型在UP中制品地位如何？请看下图。</p><p>&lt;img src=”<a href="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524105602.png&quot;/" target="_blank" rel="noopener">https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524105602.png&quot;/</a> align=’center’&gt;</p><p>下面给出一个实例，我们从下图可知道，领域建模通常可以用UML类图的形式来表达。我们通常会提炼出领域内的几个重要概念类。</p><p>而确定一组概念类则是面向对象分析的核心。</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524110030.png"></p><p>我们可以看到，领域模型涵盖了概念，关联和属性，是一种可视化的字典。</p><p>概念：描述概念类的名称</p><p>属性：概念类包含的属性</p><p>关联：表示不同概念类之间的关联关系</p><h1 id="领域模型的概念"><a href="#领域模型的概念" class="headerlink" title="领域模型的概念"></a>领域模型的概念</h1><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524110537.png"></p><p>概念类是领域模型中的一个核心组件。表示领域中的思想，事物或对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524111233.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们必须认识的是，领域建模虽然使用了UML类图来进行设计，但是领域模型却不是设计模型，是一种业务模型，它对设计模型有所启发。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524111518.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="创建领域模型"><a href="#创建领域模型" class="headerlink" title="创建领域模型"></a>创建领域模型</h1><h2 id="找到概念类"><a href="#找到概念类" class="headerlink" title="找到概念类"></a>找到概念类</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524112121.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>概念类名必须是<strong>名词</strong> 。</p><p> 经过一番查找，我们可以大致确定一些概念类，并简单绘制。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524113641.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="确定属性"><a href="#确定属性" class="headerlink" title="确定属性"></a>确定属性</h2><p>一个对象里头包含的值就是属性。属性有普通属性和推导属性。</p><p>关于推导属性的界定，我们可以通过一个例子来理解。</p><p>比如在前端开发中，对于用户可见的一些数值，有时是需要在后端经过<strong>较为复杂的计算</strong>得到的，这些数值对应的属性就是推导属性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524113813.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="确定描述类"><a href="#确定描述类" class="headerlink" title="确定描述类"></a>确定描述类</h2><p>在“描述”类的过程是简化一个类的过程。</p><p>以下给出一个简单的实例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524114023.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>简单来说就是一个类里头如果有某一个属性较为复杂，那么我们就可以将这个属性抽象建模为一个新的描述类，搭配原来的类来对对象进行描述。</p><h2 id="确定关联"><a href="#确定关联" class="headerlink" title="确定关联"></a>确定关联</h2><p>关联表示的是类之间的关系，表示有意义或值得关注的连接，但是我们应该避免加入大量关联。</p><p>关联的可视化形式是类之间的一条连线，同时有以首字母大写的关联名称。</p><h3 id="关联名称"><a href="#关联名称" class="headerlink" title="关联名称"></a>关联名称</h3><p>名称的命名规则需要注意：以“类名 + 动词短语 + 类名”的格式命名。（但有时并不这样命名。。）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524124608.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="关联的多重性"><a href="#关联的多重性" class="headerlink" title="关联的多重性"></a>关联的多重性</h3><p>应用关联线的时，我们需要明确关联两个类之间的多重性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524124732.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在某些复杂的情况之下，两个类还有多重关联。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\Qiuyh\AppData\Roaming\Typora\typora-user-images\1558673328661.png" alt="1558673328661" title="">                </div>                <div class="image-caption">1558673328661</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;领域模型初步认识&quot;&gt;&lt;a href=&quot;#领域模型初步认识&quot; class=&quot;headerlink&quot; title=&quot;领域模型初步认识&quot;&gt;&lt;/a&gt;领域模型初步认识&lt;/h1&gt;&lt;p&gt;领域模型是常见的业务建模过程中的一个重要制品，那么领域模型在UP中制品地位如何？请看下图。&lt;
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统分析与设计" scheme="https://joshuaqyh.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 系分作业五</title>
    <link href="https://joshuaqyh.github.io/2019/05/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E7%B3%BB%E5%88%86%E4%BD%9C%E4%B8%9A%E4%BA%94/"/>
    <id>https://joshuaqyh.github.io/2019/05/18/软件工程-系分作业五/</id>
    <published>2019-05-18T05:32:22.000Z</published>
    <updated>2019-05-24T10:04:06.121Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用 <code>UMLet</code> 建模.</strong> </p><p><strong>1、根据订旅馆建模文档，<a href="https://sysu-swsad.github.io/swad-guide/material/Asg_RH.pdf" target="_blank" rel="noopener">Asg-RH.pdf</a></strong></p><ul><li><p>绘制用例图模型（到子用例）</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/%E6%97%85%E9%A6%86%E7%94%A8%E4%BE%8B%E5%9B%BE-%E4%BD%9C%E4%B8%9A5.jpg" alt="图片链接"></p><p>若图片过大无法加载，请点击<a href="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/%E6%97%85%E9%A6%86%E7%94%A8%E4%BE%8B%E5%9B%BE-%E4%BD%9C%E4%B8%9A5.jpg" target="_blank" rel="noopener">图片链接</a></p></li><li><p>给出 <code>make reservation</code> 用例的活动图。</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/%E6%97%85%E9%A6%86%E9%A2%84%E8%AE%A2%E6%B4%BB%E5%8A%A8%E5%9B%BE-%E4%BD%9C%E4%B8%9A4.png" alt=""></p><p>若图片过大无法加载，请点击<a href="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/%E6%97%85%E9%A6%86%E9%A2%84%E8%AE%A2%E6%B4%BB%E5%8A%A8%E5%9B%BE-%E4%BD%9C%E4%B8%9A4.png" target="_blank" rel="noopener">图片链接</a></p></li></ul><hr><p><strong>2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景</strong></p><p><strong>2.1 分别用多泳道图建模三个场景的业务过程</strong></p><p>2.1.1 x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524165828.png" alt=""></p><hr><p>2.1.2  随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524171245.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>2.1.3 x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。</p><p>  <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524172509.png" alt=""></p><hr><p><strong>2.2 根据上述流程，给出快递柜系统最终的用例图模型</strong></p><p>2.2.1 用正常色彩表示第一个业务流程反映的用例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524180105.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>2.2.2  用绿色背景表述第二个业务场景添加或修改的用例，以及支持 <code>Actor</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524175229.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>2.2.3 用黄色背景表述第三个业务场景添加或修改的用例，以及支持 <code>Actor</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190524180400.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;UMLet&lt;/code&gt; 建模.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、根据订旅馆建模文档，&lt;a href=&quot;https://sysu-swsad.github.io/swad-guide/material/Asg_RH.p
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统分析与设计" scheme="https://joshuaqyh.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 系分作业四</title>
    <link href="https://joshuaqyh.github.io/2019/05/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E7%B3%BB%E5%88%86%E4%BD%9C%E4%B8%9A%E5%9B%9B/"/>
    <id>https://joshuaqyh.github.io/2019/05/17/软件工程-系分作业四/</id>
    <published>2019-05-17T05:32:11.000Z</published>
    <updated>2019-05-22T03:16:15.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Student ID： 16340186</p><p>Name： 邱奕浩</p></blockquote><h2 id="一、简单题"><a href="#一、简单题" class="headerlink" title="一、简单题"></a>一、简单题</h2><h3 id="1-用例的概念"><a href="#1-用例的概念" class="headerlink" title="1. 用例的概念"></a>1. 用例的概念</h3><p>用例就是一组相关的成功和失败场景的集合，用来描述参与者如何使用系统实现其目标。</p><p>需要注意的是，用例是文本文档，而非图形。</p><h3 id="2-用例和场景的关系？什么是主场景或Happy-path？"><a href="#2-用例和场景的关系？什么是主场景或Happy-path？" class="headerlink" title="2. 用例和场景的关系？什么是主场景或Happy path？"></a>2. <strong>用例和场景的关系？什么是主场景或Happy path？</strong></h3><p>场景是参与者与系统交互的特定过程，也称为用例实例，是使用系统一个特定用例的一条执行路径；用例通常包括了一系列的场景：主场景或其他可选场景。</p><p>主场景指的是最常用的一个主要的基础业务场景，能够基本满足<code>Actors</code>需求以及实现其基本目标。</p><h3 id="3-用例有哪些形式？"><a href="#3-用例有哪些形式？" class="headerlink" title="3.用例有哪些形式？"></a>3.<strong>用例有哪些形式？</strong></h3><p>用例主要有以下三种常用的形式：</p><ul><li>摘要：简洁的一段式概要，通常应用于主场景的描述，一般在早期需求分析过程中为快速了解主题和范围而使用。</li><li>非正式的段落格式：用几个段落的文字覆盖不同场景。</li><li>详述：详细编写所有的步骤和各种变化，同时具有补充部分，如前置条件和成功保证。</li></ul><h3 id="4-对于复杂业务，为什么编制完整用例非常难？"><a href="#4-对于复杂业务，为什么编制完整用例非常难？" class="headerlink" title="4.对于复杂业务，为什么编制完整用例非常难？"></a>4.<strong>对于复杂业务，为什么编制完整用例非常难？</strong></h3><p>对于复杂的业务，将会涉及到诸多的复杂场景，每个场景之间可能还有依赖关系，所以编写完整准确的用例将会非常难。但是编写完整的用例仍具有重要意义，流程清晰有利于后续业务的增添删改。</p><h3 id="5-什么是用例图？"><a href="#5-什么是用例图？" class="headerlink" title="5. 什么是用例图？"></a>5. <strong>什么是用例图？</strong></h3><p>用例图是一种优秀的系统语境图，用例图能够展示系统边界与边界之外的事物以及系统如何被使用。</p><h3 id="6-用例图的基本符号与元素？"><a href="#6-用例图的基本符号与元素？" class="headerlink" title="6.用例图的基本符号与元素？"></a>6.<strong>用例图的基本符号与元素？</strong></h3><p>基本符号如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190517143928.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>主要元素有：</p><ul><li>参与者 <code>Actors</code></li><li>系统边界</li><li>用例 <code>Use Case</code></li><li>关系</li></ul><h3 id="7-用例图的画法与步骤"><a href="#7-用例图的画法与步骤" class="headerlink" title="7. 用例图的画法与步骤"></a>7. <strong>用例图的画法与步骤</strong></h3><p>一个简单而完整的用例图的画法和步骤组织如下：</p><ol><li><p><strong>选择系统边界。</strong>确定用例图的中待研究的系统，使用一个<code>System</code>框来表示它，同时为其正确命名，如<code>Hotel Reservation System</code>。如下图：</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190522101435.png" alt=""></p><p>​</p></li><li><p><strong>识别和确定系统的参与者和目标</strong>。这包括明确系统的主要参与者以及识别系统所依赖的外部系统。主要参与者使用<code>actor</code>符号表示，通常放在<code>system</code>框的左边；使用<code>Neighbourssystem</code>框表示用例所依赖的外部系统、服务、设备等，使用构造性识别。如下图：</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190517145630.png" alt=""></p></li><li><p><strong>识别用例以及处理好用例之间的关系。</strong> 用例包括用户级别的用例和子功能级别的用例。前者以主要参与者的目标驱动，涉及主要参与者的业务事件；后者具备业务复用和扩展创新的特征。我们需要正确表示用例和子用例之间的关系表示。我们使用<code>&lt;&lt;include&gt;&gt;</code> 表示子用例是父用例的一部分，箭头指向子用例，<code>&lt;&lt;extend&gt;&gt;</code></p><p>箭头指向父用例，箭头表示依赖关系。例子如下：</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190517151421.png" alt=""></p><p>这些用例及其连线都需要放置在<code>System</code>框中。</p></li><li><p><strong>确定参与者之间的关系</strong>，即泛化关系。</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190517153733.png" alt=""></p><p>​</p></li><li><p>确立<code>Actor</code>和<code>Use Cases</code>之间的关联，使用无方向连线，表示两者之间双向交互的关系。如下图：</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190517151612.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="5"><li>最终的结果大致如下图：</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190517151830.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="8-用例图给利益相关人与开发者的价值有哪些？"><a href="#8-用例图给利益相关人与开发者的价值有哪些？" class="headerlink" title="8.用例图给利益相关人与开发者的价值有哪些？"></a>8.<strong>用例图给利益相关人与开发者的价值有哪些？</strong></h3><p>用例图对于利益相关人来说，可以直观地看到系统的运行过程和结果，以及相对应的用户功能使用体验。</p><p>对开发者来说，用例图是反映系统和参与者交互的过程，是设计者的用例模型可视化表示，，能直观的向开发者表达系统逻辑，是良好的交流工具。</p><h2 id="二、建模练习题"><a href="#二、建模练习题" class="headerlink" title="二、建模练习题"></a>二、建模练习题</h2><ul><li>选择<code>2-3</code>个你熟悉的类似业务的在线服务系统（或移动 <code>APP</code>），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：<ul><li>请使用用户的视角，描述用户目标或系统提供的服务</li><li>粒度达到子用例级别，并用<code>include</code> 和 <code>exclude</code> 关联它们</li><li>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例</li><li>尽可能识别外部系统和服务</li></ul></li></ul><p>以携程预订火车票的服务系统以及美团外卖订餐系统为例，进行用例图的绘制。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190518014619.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190518012238.png" alt=""></p><ul><li><p>回答下列问题：</p><ol><li><p>为什么相似系统的用例图是相似的？</p><p><strong>因为对于相似的系统具备相似的基本业务流程和场景，对应的参与者的功能需求是基本一致的，因此用例图是相似的。</strong></p></li><li><p>如果是定旅馆业务，请对比 <code>Asg_RH</code> 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术。</p><p><strong>非订旅馆业务，此处不作解答。</strong></p></li><li><p>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用。</p><p><strong>可使用鲜明的颜色背景表示创新点的相关用例进行标注。</strong></p></li><li><p>请使用 <code>SCRUM</code> 方法，选择一个用例图，编制某定旅馆开发的需求<code>（backlog）</code>开发计划表。</p><p>使用<code>Asg_RH</code>的用例图进行编制。</p><p>| ID   | Name         | Imp  | Est  | How to demo                              | Notes              |<br>| — | ———— | — | — | ————————————– | —————— |<br>| 1    | 搜寻酒店     | 10   | 6    | 定位酒店城市，具体地点，目标酒店信息陈列 | 选做智能输入匹配   |<br>| 2    | 预订酒店房间 | 20   | 10   | 选择房间类型，填写入住退订时间           | 步骤先后进入       |<br>| 3    | 搜索结果排序 | 15   | 7    | 按匹配，评分、价格，距离等不同方式排序   | 优先按匹配方式显示 |<br>| 4    | 支付确认订单 | 10   | 3    | 接入外部支付系统付款，确认订单           | 微信，支付宝支付等 |<br>| 5    | 订单管理     | 10   | 5    | 订单浏览，增删改查                       | 用户相关           |</p></li><li><p>根据任务<code>4</code>，参考 <a href="https://www.ibm.com/developerworks/cn/rational/edge/09/mar09/collaris_dekker/index.html" target="_blank" rel="noopener">使用用例点估算软件成本</a>，给出项目用例点的估算</p></li></ol></li></ul><table><thead><tr><th>用例</th><th>#业务</th><th>#计算</th><th>原因</th><th>UC比重</th></tr></thead><tbody><tr><td>搜寻酒店</td><td>3</td><td>2</td><td></td><td>简单</td></tr><tr><td>预订酒店房间</td><td>6</td><td>4</td><td></td><td>平均</td></tr><tr><td>搜索结果排序</td><td>4</td><td>5</td><td></td><td>简单</td></tr><tr><td>支付确认订单</td><td>4</td><td>3</td><td></td><td>简单</td></tr><tr><td>订单管理</td><td>2</td><td>3</td><td></td><td>简单</td></tr></tbody></table><p>  ​</p><p>  ​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Student ID： 16340186&lt;/p&gt;
&lt;p&gt;Name： 邱奕浩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、简单题&quot;&gt;&lt;a href=&quot;#一、简单题&quot; class=&quot;headerlink&quot; title=&quot;一、简单题&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统分析与设计" scheme="https://joshuaqyh.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 目标检测概述-旷视分享</title>
    <link href="https://joshuaqyh.github.io/2019/05/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0-%E6%97%B7%E8%A7%86%E5%88%86%E4%BA%AB/"/>
    <id>https://joshuaqyh.github.io/2019/05/17/深度学习-目标检测概述-旷视分享/</id>
    <published>2019-05-16T17:51:00.000Z</published>
    <updated>2019-05-16T17:54:13.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标检测概述"><a href="#目标检测概述" class="headerlink" title="目标检测概述"></a>目标检测概述</h1><p>思维导图内容来自旷视科技R talk，全文见<a href="https://zhuanlan.zhihu.com/p/38154492" target="_blank" rel="noopener">知乎链接</a>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/%E6%97%B7%E8%A7%86%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目标检测概述&quot;&gt;&lt;a href=&quot;#目标检测概述&quot; class=&quot;headerlink&quot; title=&quot;目标检测概述&quot;&gt;&lt;/a&gt;目标检测概述&lt;/h1&gt;&lt;p&gt;思维导图内容来自旷视科技R talk，全文见&lt;a href=&quot;https://zhuanlan.zhihu.
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机视觉" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | Mask Scoring RCNN Paper Summary-2</title>
    <link href="https://joshuaqyh.github.io/2019/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Mask-Scoring-RCNN-Paper-Summary-2/"/>
    <id>https://joshuaqyh.github.io/2019/05/16/深度学习-Mask-Scoring-RCNN-Paper-Summary-2/</id>
    <published>2019-05-16T13:58:53.000Z</published>
    <updated>2019-05-16T14:45:33.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mask-Scoring-R-CNN"><a href="#Mask-Scoring-R-CNN" class="headerlink" title="Mask Scoring R-CNN"></a>Mask Scoring R-CNN</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>​    The instance segmentation task pursues the accurate classification on pixel-level in object detection. It requires more detailed labels and more delicate network structures. <strong>However, the exiting instance mask methods, such as Mask R-CNN and MaskLab, simply regard the box-level classification confidence predicted by a classifier applied on the proposal feature as the score of the instance mask.</strong> It is improper and inaccurate to use the classification scores of proposals to measure the mask quality, which may cause the mask incompleteness and a decrease of AP if not properly scored. That means it is possible to get high box confidence score but low mask quality. <strong>To tackle the problem of the misalignment between classification confidence and mask quality,</strong> the authors put forward a novel and effective model named Mask Scoring R-CNN to <strong>learn to score the mask.</strong></p><p>​    The mask scoring strategy is inspired by the AP metric to use pixel-level Intersection-over-Union between predicted mask and its ground truth mask, denoted by Mask IoU. Mask Scoring R-CNN’s implementation is conceptually simple: <strong>Mask R-CNN with a MaskIoU prediction network named MaskIoU Head, taking both the output of the mask head and RoI align feature as input</strong> <strong>and trained using a simple regression loss on MaskIoU.</strong> And Following Mask R-CNN, Mask Scoring R-CNN includes two stages: the first is the Region Proposal Network (<strong>RPN</strong>) that proposes candidate object bounding boxes regardless of object categories and the second is the <strong>R-CNN</strong> which extracts features using RoIAlign for each proposal and finishes multi-tasks: proposal classification,bounding boxes regression and mask predicting. <strong>The difference is that selecting top-k boxes by SoftNMS from R-CNN head is to fed into the Mask head to generate multi-class tasks.</strong></p><p>​      The innovation of this model is that <strong>it designs a concise and effective mask scoring mechanism.</strong> The authors considered that the final mask score (defined as <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="file:///C:/Users/Qiuyh/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img](file:///C:/Users/Qiuyh/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png))should reflect two tasks: the mask classification and the MaskIoU regression. Therefore,the mask score learning task is decomposed into two parts, denoted as ![img](file:///C:/Users/Qiuyh/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png). Thebox classification in R-CNN head predicts the ![img](file:///C:/Users/Qiuyh/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png) and the MaskIoU head predicts the ![img" title="">                </div>                <div class="image-caption">img](file:///C:/Users/Qiuyh/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png))should reflect two tasks: the mask classification and the MaskIoU regression. Therefore,the mask score learning task is decomposed into two parts, denoted as ![img](file:///C:/Users/Qiuyh/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png). Thebox classification in R-CNN head predicts the ![img](file:///C:/Users/Qiuyh/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png) and the MaskIoU head predicts the ![img</div>            </figure><em>.</em></p><p>​    The MaskIoU head consists of 4 convolution layers and 3 fully connected layers.Aiming to regress the MaskIoU, <strong>the concatenation of feature from RoI Align layers and the single predicted mask layer using max pooling layer to reduce the size by half as the input of MaskIoU head.</strong> And the output of final full connected layer will predict <strong>the score of C classes MaskIoU.</strong> For training MaskIoU head, the author adopts<strong>L2 loss</strong> for regressing between predicted MaskIoU and the matched MaskIoU target. The whole network is end to end trained (Fig. 1). </p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190516221225.png" alt=""></p><p>Fig.1: Mask Scoring Network Structure Overview.</p><p>​    The authors conducted extensive experiments on the COCO dataset with 80 object categories,and used COCO evaluation metrics <strong>AP </strong>to report the results. The experiment’s results on <strong>different backbone networks including ResNet-18/50/101 and the same framework (FPN)</strong> demonstrates that adding MaskIoU head is able to <strong>bring noticeable and stable AP improvements</strong> in instance segmentation and the method is <strong>insensitive to different backbone networks.</strong>Furthermore, the authors reported the results on <strong>the same backbone (ResNet-101) and different frameworks</strong> including Faster R-CNN, FPN, DCN+FPN, proving that the proposed MaskIoU head brings consistent improvement.</p><p>​    To evaluate the MaskIoU method comprehensively, the authors used ResNet-18 FPN forall the ablation study experiments. First, the study on different design choices of MaskIoU head input (Fig .2) shows that the best plan is <strong>concatenating the target score map and RoI feature</strong> <strong>obtains the best results</strong>,so it is used as the default choice. Besides, the authors also explored the choices of the training target and found that <strong>the strategy of learning the MaskIoU of the target category gets the best performance</strong>.</p><p>Finally, they discussed how to selecttraining samples and the results show that<strong>training using all examples</strong> without the box-level IoU threshold filterobtains the best performance. </p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190516221154.png" alt=""></p><p>Fig.2 Different design choices of the MaskIoU head input.</p><p>For further discussion, the experiments show MaskIoU predictions <strong>have good correlation with the ground truth</strong>.And the upper bound performance of the model is discussed and it outperforms Mask R-CNN consistently, which gets <strong>about 2% MaskIoU AP increase</strong> and still have a room to improve. In addition, the MaskIoU head has <strong>a small 0.39G FLOPs model size</strong> for every proposal. Even better, <strong>the computation cost of MaskIoU is negligible.</strong> </p><p>The MaskIoU head, proposed in this paper, effectively achieves the alignment of mask scores with MaskIoU and surpasses the state-of-the-art methods. It also can easily be applied to other instance segmentation networks and is a new direction to improve instance segmentation. Nonetheless,MS R-CNN is still a lot of room to explore and extend. Find a more effective loss function to help to improve the performance of small objects segmentation is a noteworthy direction. Besides, how to reduce the network branch or make network parallel based on the MaskIoU regression is worth considering for the tradeoff between precision and speed.   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mask-Scoring-R-CNN&quot;&gt;&lt;a href=&quot;#Mask-Scoring-R-CNN&quot; class=&quot;headerlink&quot; title=&quot;Mask Scoring R-CNN&quot;&gt;&lt;/a&gt;Mask Scoring R-CNN&lt;/h1&gt;&lt;h2 id=&quot;S
      
    
    </summary>
    
    
      <category term="Writing" scheme="https://joshuaqyh.github.io/tags/Writing/"/>
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机视觉" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="Paper" scheme="https://joshuaqyh.github.io/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 利用focal loss来解决样本不均衡的问题</title>
    <link href="https://joshuaqyh.github.io/2019/05/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%88%A9%E7%94%A8focal-loss%E6%9D%A5%E8%A7%A3%E5%86%B3%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://joshuaqyh.github.io/2019/05/04/深度学习-利用focal-loss来解决样本不均衡的问题/</id>
    <published>2019-05-04T11:18:14.000Z</published>
    <updated>2019-05-16T14:14:19.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="focal-loss-简述"><a href="#focal-loss-简述" class="headerlink" title="focal loss 简述"></a>focal loss 简述</h1><p>论文地址来自<a href="https://arxiv.org/pdf/1708.02002v2.pdf" target="_blank" rel="noopener">arxiv</a></p><p>先放focal loss（FL）和cross entropy（CE）两个函数的数学定义。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190504194213.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190504194241.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>focal loss 称为焦点损失函数，通过改进标准的二元交叉熵损失函数来控制对正负样本的训练，为了解决在one-stage目标检测中正负样本严重不均衡的一种策略。该损失函数的设计思想类似于boosting，降低容易分类的负样本对损失函数的影响，注重较难分类的正样本的训练。</p><p>在常规的交叉熵函数的基础上，添加一个系数项，当较容易训练负样本的预测分数较高时，其计算所得的loss将变小，而较难训练的正样本则计算得到更大的loss值，但整体来看计算得到的总loss值比标准的交叉熵计算得到得结果loss更小。从下图曲线得以看出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190504193353.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="公式探讨"><a href="#公式探讨" class="headerlink" title="公式探讨"></a>公式探讨</h1><p>当我们考虑类别的比重不相同时，我们可以给各个类别添加一个权重常数$\alpha$ ，比如正样本权重为0.8，则负样本就为0.2，然后该权重常数乘以对应类别的交叉熵计算中得以生效。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190504194446.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这样就能够平衡正负样本的重要性。但是要解决简单分类和困难分类样本的问题则需要依赖 $\lambda$, $\lambda$ 越大，损失值计算结果越小，这能够实现对容易样本降低权重的平滑调节。对于物体检测，实验发现 $\lambda = 2$时最优。</p><p>个人认为该损失函数的设计思想可以应用于其他同样有样本不均衡特点的分类任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;focal-loss-简述&quot;&gt;&lt;a href=&quot;#focal-loss-简述&quot; class=&quot;headerlink&quot; title=&quot;focal loss 简述&quot;&gt;&lt;/a&gt;focal loss 简述&lt;/h1&gt;&lt;p&gt;论文地址来自&lt;a href=&quot;https://arx
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Paper" scheme="https://joshuaqyh.github.io/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | Scrum开发框架入门学习</title>
    <link href="https://joshuaqyh.github.io/2019/04/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-Scrum%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://joshuaqyh.github.io/2019/04/19/软件工程-Scrum开发框架入门学习/</id>
    <published>2019-04-19T02:11:27.000Z</published>
    <updated>2019-05-16T14:14:15.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scrum-概述"><a href="#Scrum-概述" class="headerlink" title="Scrum 概述"></a>Scrum 概述</h1><p><code>Scrum</code>是一种开发框架，不是方法学！！是关于制定开发流程和人员事项的，内容无法干涉。</p><h2 id="产品-backlog"><a href="#产品-backlog" class="headerlink" title="产品 backlog"></a>产品 backlog</h2><p>产品 <code>backlog</code> 从根本上说，就是一个需求，或故事，或特性组成的列表，按<strong>重要性级别进行排序</strong>。</p><p><code>backlog</code>当中包括的是一个个的故事<code>story</code> ,有时也称为<code>backlog</code> 条目。</p><p>一个故事包括一些字段：</p><ul><li><code>ID</code>：同一标识符，自增长的数字。</li><li><code>Name</code>: 简短的，描述性的故事名。</li><li><code>Importance</code>: 重要性，评价该项目的优先级。</li><li><code>Initial estimate</code>: 初始估算。跟其他故事相比，完成该项故事所需要的工作量。单位一般描述为故事点<code>story point</code> </li><li><code>how to demo</code>: 如何演示。大略描述了故事应该如何在sprint演示上进行示范。</li><li><code>Notes</code>：注解。相关信息，解释说明和对其他资料的引用。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190419110312.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要注意产品 <code>backlog</code>停留在业务层面！</p><h2 id="Sprint-计划"><a href="#Sprint-计划" class="headerlink" title="Sprint 计划"></a>Sprint 计划</h2><p>！ 计划开始之前是 产品 <code>backlog</code> 必须存在。</p><p><code>sprint</code>计划会议是为了团队 获得充足的信息，能够在几个星期内不受干扰地工作，增强产品负责人的自信心。</p><p><code>Sprint</code> 计划会议产生的成果：</p><ul><li><code>sprint</code> 目标</li><li>团队成员名单，以及投入程度</li><li><code>sprint backlog</code>。即<code>sprint</code> 中包括的故事列表。</li><li>确定好<code>sprint</code>演示日期。</li><li>确定好时间地点。供举行每日<code>scrum</code>会议。</li></ul><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190419113236.png" alt=""></p><p>产品负责人必须参加！产品负责人的职责：</p><ol><li>会议达成的目标</li><li>组织团队讨论故事</li><li>估算时间。</li></ol><p>上述忽视了第四个变量——质量。质量分为内部和外部质量。</p><ul><li>外部质量是系统用户可以感知的。运行缓慢、让人迷糊的用户界面就属于外部质量低劣。</li><li>内部质量一般指用户看不到的要素，它们对系统的可维护性有深远影响。可维护性包括系统设计的一致性、测试覆盖率、代码可读性和重构等等。</li></ul><p>内部质量不可让步，内部质量决定上层基础。</p><h3 id="Spring-计划会议日程"><a href="#Spring-计划会议日程" class="headerlink" title="Spring 计划会议日程"></a>Spring 计划会议日程</h3><ul><li>目标</li><li>故事</li><li>估算</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scrum-概述&quot;&gt;&lt;a href=&quot;#Scrum-概述&quot; class=&quot;headerlink&quot; title=&quot;Scrum 概述&quot;&gt;&lt;/a&gt;Scrum 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Scrum&lt;/code&gt;是一种开发框架，不是方法学！！是关于制定开发流程和人员事
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统分析与设计" scheme="https://joshuaqyh.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>论文summary注意事项</title>
    <link href="https://joshuaqyh.github.io/2019/04/18/%E8%AE%BA%E6%96%87summary%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://joshuaqyh.github.io/2019/04/18/论文summary注意事项/</id>
    <published>2019-04-18T06:53:16.000Z</published>
    <updated>2019-05-16T14:04:55.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summarize-a-Paper"><a href="#Summarize-a-Paper" class="headerlink" title="Summarize a Paper"></a>Summarize a Paper</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190418145421.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190418145446.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>内容来源于中山大学深度学习课程——王瑞轩老师PPT</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Summarize-a-Paper&quot;&gt;&lt;a href=&quot;#Summarize-a-Paper&quot; class=&quot;headerlink&quot; title=&quot;Summarize a Paper&quot;&gt;&lt;/a&gt;Summarize a Paper&lt;/h1&gt;&lt;figure class
      
    
    </summary>
    
    
      <category term="Writing" scheme="https://joshuaqyh.github.io/tags/Writing/"/>
    
      <category term="paper" scheme="https://joshuaqyh.github.io/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 概率图模型之主题模型</title>
    <link href="https://joshuaqyh.github.io/2019/04/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://joshuaqyh.github.io/2019/04/15/机器学习-概率图模型之主题模型/</id>
    <published>2019-04-15T08:27:37.000Z</published>
    <updated>2019-04-15T09:27:47.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主题模型概述"><a href="#主题模型概述" class="headerlink" title="主题模型概述"></a>主题模型概述</h2><p>主题模型也是话题模型，是一族生成式有向图模型，主要应用于处理离散数据（如文本），在信息检索和自然语言处理中广泛应用。</p><p>例：给定一组主题，存在多个词汇，我们需要通过主题模型来挖掘每个词汇属于某个主题的概率分布情况。</p><p>在认识主题模型之前，我们先知道有词，文档，主题这些概念。我们需要通过文档内部的词，推测出文档属于各主体的概率分布情况。需要注意的是，文档可以属于任何主题，只不过某些不相关的主题的概率近似或者等于0。</p><p>主题模型的目标</p><ol><li>降维：一个文档可以用几个主题来描述，而不是许多单词。</li><li>发现隐藏主题：在人为归纳的基础上，挖掘出新的主题。</li><li>帮助理解标注文档：文档标注工作自动化。</li></ol><p>推测的算法可以有监督和无监督算法。典型模型有<strong>隐迪利克雷分配模型（LDA）。</strong></p><h3 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h3><p>在理解模型之前可以先了解一些常用分布及其概率质量函数。</p><ol><li>伯努利分布。</li><li>二项式分布。</li><li>多项式分布。</li></ol><p>伯努利分布是为了描述一个只能发生两种结果的事件的概率分布情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">f = p</span><br><span class="line"><span class="keyword">elif</span> k == <span class="number">0</span></span><br><span class="line">   f = <span class="number">1</span> - p</span><br><span class="line">k 表示事件发生结果变量，f表示概率质量函数，p表示概率。</span><br><span class="line">精简表达概率质量函数，结果为 f(k; p) = pk + (<span class="number">1</span> - p)(<span class="number">1</span>- k)</span><br></pre></td></tr></table></figure><p>二项式分布是为了描述一个二元事件连续发生多次时概率分布的情况。<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%88%86%E4%BD%88" target="_blank" rel="noopener">wiki</a>，但事件发生次数为1次的时候，等于伯努利分布。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190415171049.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>多项式分布是二项分布的推广。二项分布每次事件发生的情况只有两种，而多项式分布却有 k 种。（k &gt; 0）<a href="https://en.wikipedia.org/wiki/Multinomial_distribution" target="_blank" rel="noopener">wiki</a></p><p>当事件发生 n 次后，每种情况发生的次数已知，概率质量函数结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190415171404.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="文本建模"><a href="#文本建模" class="headerlink" title="文本建模"></a>文本建模</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190415172609.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190415172702.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主题模型概述&quot;&gt;&lt;a href=&quot;#主题模型概述&quot; class=&quot;headerlink&quot; title=&quot;主题模型概述&quot;&gt;&lt;/a&gt;主题模型概述&lt;/h2&gt;&lt;p&gt;主题模型也是话题模型，是一族生成式有向图模型，主要应用于处理离散数据（如文本），在信息检索和自然语言处理中广
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>量化交易 | 多因子模型之单因子测试总结</title>
    <link href="https://joshuaqyh.github.io/2019/04/13/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93-%E5%A4%9A%E5%9B%A0%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%95%E5%9B%A0%E5%AD%90%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://joshuaqyh.github.io/2019/04/13/量化交易-多因子模型之单因子测试总结/</id>
    <published>2019-04-12T17:04:33.000Z</published>
    <updated>2019-04-13T03:13:55.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单因子测试总结"><a href="#单因子测试总结" class="headerlink" title="单因子测试总结"></a>单因子测试总结</h1><h2 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h2><p>根据APT套利定价模型，单因子测试的含义就是, 在每一个时间截面上，也就是站在一年中的某一天关注所有股票的下一期收益率 r 和股票当期相应的因子暴露值 x 之间的关系：</p><p>$$ r  = a x + b $$ </p><p>也就是在某一个时间点，对每一只股票的收益率和该股票的因子暴露值做一个简单的线性回归，其中  a 为因子的收益率，b 为独立于市场的残差收益率。</p><p>《主动投资组合》书中定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190413012250.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在单因子测试报告中，提出了一种拓展。增加了行业虚拟变量和流通市值，以及相应的因子收益率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411112929.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="大概思路"><a href="#大概思路" class="headerlink" title="大概思路"></a>大概思路</h2><p>我们就是要利用现有的数据 股票收益率r 和 因子暴露值 x，去进行每一个时间横截面的线性回归，得到 a，b，然后利用这  a x + b = r* 求出因子预测的股票收益率。</p><h3 id="股票收益率计算"><a href="#股票收益率计算" class="headerlink" title="股票收益率计算"></a>股票收益率计算</h3><p>这里得先来了解股票收益率的计算方法</p><p>我们可以通过每一只股票的 K 线数据（get_kdata 的方式获取，如下），我们如果以1天为1期的话，那么有：</p><p>股票收益率  = 第二天股票收盘价格 / 第一天股票收盘价格 - 1  （收盘价格就是下列的 close 字段） </p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411104316.png" alt=""></p><p>然后在每个时间截面获取每一个的股票收益率情况，利用成分股的权重，加权求和得到在该时间点上的股票市场整体收益率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411105526.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="因子暴露值"><a href="#因子暴露值" class="headerlink" title="因子暴露值"></a>因子暴露值</h3><p>每一只股票在每一时刻都有对应的因子暴露值，获取方法如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411110021.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们需要对因子进行预处理，一般是</p><ol><li>中位数去极值法去除异常值。</li><li>缺失值处理，可剔除或者均值填充。</li><li>z-score 规范化，使之标准差为 1，均值为0。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411111930.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="计算夏普率"><a href="#计算夏普率" class="headerlink" title="计算夏普率"></a>计算夏普率</h3><p>到这里我们可以在每一个时间面上对所有股票的收益率和因子值进行回归，得到 因子收益率 a 和残差收益率 b。</p><p>然后重新预测所有股票的收益率。先对所有成分股的权重求和，然后每个权重除以总权重得到新的权重，使用加权求和的方式计算在该时间点的股票池中的总体收益率。</p><p>在每个时间点上重复上述计算就可以得到一个产品收益率的时间序列。然后就可以计算超额收益率序列，从而计算夏普比率。）这里的无风险收益率一般取 4 % 。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411111149.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>利用上述数据也可以计算 IC值，年化收益率，IR值，t 检验结果等等。</p><blockquote><p>更新补充：</p><p>由于是每一个月初开始调仓（近似于买入卖出股票），那么我们就可以把每一期预测的周期视为一个月。一年划分成十二个时间截面来回归。回归的自变量是月初当天的每个股票对应的因子，因变量是这一个月内的日平均收益率或者日平均对数收益率（计算方法是月末-月初/月初股票的收盘价格）。接着拟合十二个回归模型。</p><p>接下来计算超额收益率平均值思路是：</p><p>在每一个拟合好的时间模型上，计算每只股票的收益率，然后通过个股权重，加权组合求得当月股票池的总平均收益率。然后使用这12个月的时序产品总平均收益率序列，作为产品收益率序列数据来计算夏普比率。此时 n = 12</p><p>思路主要来自于<a href="https://zhuanlan.zhihu.com/p/21275919" target="_blank" rel="noopener">知乎文章</a></p><p>个人理解：emmm 不就是使用月初因子作为训练数据，平均收益率作为训练标签，使用线性回归模型进行拟合么。应该可以引入惩罚项吧？或者使用其他机器学习模型来训练？？</p></blockquote><h2 id="共线性筛选"><a href="#共线性筛选" class="headerlink" title="共线性筛选"></a>共线性筛选</h2><p>我们使用上述方法可以得到每一个因子的年化夏普率，然后挑选较优的各大类因子，得到一个列表。但此时依旧需要解决因子之间的共线性问题，如果两个因子的线性关系较为明显（相关系数为1正相关，相关系数为-1负相关），我们应该剔除，保留其中一个，或者合成新的因子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411112406.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>利用相关性矩阵来计算的结果如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411112016.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="分层回测"><a href="#分层回测" class="headerlink" title="分层回测"></a>分层回测</h2><p>分层就是将全体股票池按市值等分为大、中、小股票池。然后分别对每个池进行上述的测试。题目里头也有提及到不同市值的股票风格不同，所以觉得这个可能还是有点必要的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190411112754.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="总体过程"><a href="#总体过程" class="headerlink" title="总体过程"></a>总体过程</h2><ol><li>确定测试的开始和结束日期；</li><li>股票日频数据采集，构成股票池；（所有股票的K线时序数据）（此处可按市值进行分层）</li><li>利用K线数据计算所有股票的每期收益率；（收益率时序数据）</li><li>确定候选的测试因子集合；</li><li>获取股票池中每个股票的候选因子，也就是股票对因子的暴露值；（因子时序数据）</li><li>对每个因子进行预处理；</li><li>每一个时间截面（每一天）对当期的因子暴露值和股票的下期收益率进行回归，得到因子收益率和残差收益率。</li><li>利用回归得到的因子收益率和残差收益率和因子暴露值，计算股票的预测收益率</li><li>每个时间截面计算整体股票池的预测收益率，得到一个收益率序列。</li><li>根据收益率序列计算夏普率，筛选较好的因子。</li><li>使用相关性矩阵，剔除相关性较强的因子，得到最后的因子集合。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单因子测试总结&quot;&gt;&lt;a href=&quot;#单因子测试总结&quot; class=&quot;headerlink&quot; title=&quot;单因子测试总结&quot;&gt;&lt;/a&gt;单因子测试总结&lt;/h1&gt;&lt;h2 id=&quot;数学模型&quot;&gt;&lt;a href=&quot;#数学模型&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="量化交易" scheme="https://joshuaqyh.github.io/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 系分作业三</title>
    <link href="https://joshuaqyh.github.io/2019/04/12/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E7%B3%BB%E5%88%86%E4%BD%9C%E4%B8%9A%E4%B8%89/"/>
    <id>https://joshuaqyh.github.io/2019/04/12/软件工程-系分作业三/</id>
    <published>2019-04-12T03:28:48.000Z</published>
    <updated>2019-04-12T07:57:15.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Student ID：16340186</p><p>Name: 邱奕浩</p></blockquote><h3 id="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）"><a href="#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）" class="headerlink" title="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）"></a>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）</h3><p><strong>瀑布模型</strong></p><p>简述：</p><p>瀑布模型将软件生命周期各个阶段的活动规定为按顺序相连接的多阶段工作，涵盖需求，设计，编码，测试，到软件发布和维护等阶段，每个阶段都会产生循环反馈，产出的相关成果制品将作为下一阶段活动的输入，若某阶段存在某些问题，需要回退到之前的某个阶段进行修改，然后重新进行流动。</p><p>优点：</p><ul><li>降低软件开发的复杂度，提高软件开发过程透明性；</li><li>提高了软件开发过程的可管理性，适用于规模较小，较为稳定的项目开发；</li><li>各个阶段正确衔接，能够及时发现并纠正开发过程存在的缺陷。</li></ul><p>缺点：</p><ul><li>过分强调过程活动的线性顺序，缺乏灵活性，对前面步骤依赖程度高，流程可逆性差；</li><li>风险控制能力较弱，当某一个阶段产生错误时，需要回归到前几个阶段重新开始；</li><li>鉴于其文档驱动的性质，当阶段之间规定文档较多时，将极大的增加人员和系统的工作量。</li></ul><p><strong>增量模型</strong></p><p>简述：</p><p>增量模型从一组给定的需求开始，将软件项目系统模块化，通过构造一系列可执行的组件模块，分批次地进行分析，设计，构造和测试等增量组件。第一个中间版本满足部分需求，下一个版本又纳入新的更多的需求，每个版本会有相应的子产品交付，依此类推，直到系统完成。</p><p>优点：</p><ul><li>由于其增量组件化的性质，人员分工较为灵活，可以同时进行多个组件的开发，人员利用率较高；</li><li>每个增量组件的交付后会收到用户反馈，增加用户参与度，降低用户使用风险；</li><li>模块化分解项目，提高系统稳定性，适用于规模较大，较为复杂，易变性低的软件开发。</li><li>开发初期不要求投入较大人力资源，可优先推出核心功能，根据市场反映实现下一个增量。</li></ul><p>缺点：</p><ul><li>各个增量组件加入已有的软件体系结构，必须不破坏已有的结构，这要求具备开放式的体系结构；</li><li>需求变化频繁时，增量模型灵活性容易丧失，使得软件过程控制较为复杂；</li><li>必须妥善处理增量组件之间的关系，若增量组件之间关系存在相交等情况，需要全盘系统分析。</li></ul><p><strong>螺旋模型（含原型方法）</strong></p><p>螺旋模型是一种演化软件开发过程模型，兼顾了快速原型的迭代特征和瀑布模型的系统化和严格监控。同时引入了风险分析，使软件在无法排除重大风险时有机会停止。主要步骤有1. 决定目标、方案限制，进行需求计划；2. 评估方案，识别解决风险，进行风险分析，应用原型方法；3. 开发，验证下一级产品，；4. 计划下一阶段。一般适用于大型昂贵的系统级软件系统。</p><p>优点：</p><ul><li>通过原型建立，使得软件开发在每个迭代有最初明确的方向；</li><li>引入风险分析，最大程度地降低软件失败造成损失的可能；</li><li>过程灵活性高，在开发过程易于应对变化；</li><li>多个迭代阶段累计开发成本，易于掌握支出状况。</li></ul><p>缺点：</p><ul><li>过度依赖风险分析经验与技术，一旦风险分析过程出现偏差将导致重大损失；</li><li>只适用于大型软件，过多的风险管理支出将会影响客户的最终收益。</li></ul><hr><h3 id="简述统一过程三大特点，与面向对象的方法有什么关系？"><a href="#简述统一过程三大特点，与面向对象的方法有什么关系？" class="headerlink" title="简述统一过程三大特点，与面向对象的方法有什么关系？"></a>简述统一过程三大特点，与面向对象的方法有什么关系？</h3><p>三大特点：</p><ul><li><strong>以体系为中心。</strong>软件体系结构提供开发的核心架构，要求体系结构有良好弹性，适应变化，易于理解，可重用；</li><li><strong>用例<code>Use Case</code> 驱动和风险<code>Risk</code>驱动相结合</strong>在迭代早起要识别和降低风险，并快速构造满足客户核心需求的产品。</li><li><strong>迭代及增量。统一过程具有周期性，</strong>可量化性，在每一轮迭代开发中进行软件分析，设计，构造，测试和反馈。</li></ul><p>统一过程<code>UP</code>是面向对象设计与开发的重要方法，是迭代，敏捷开发实践的重要代表。</p><hr><h3 id="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"><a href="#简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？" class="headerlink" title="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"></a><strong>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</strong></h3><p>统一过程四个阶段按时间维度分解是：初始阶段，精化阶段，构建阶段和产品阶段。</p><p>其划分准则是：每个阶段结束的时候产生一个里程碑，并在结尾执行一次评估确定该阶段的目标是否满足，如果评估结果令人满意，那么项目进入下一阶段。</p><p>每个阶段的关键里程碑分别是：</p><ul><li><strong>初始阶段：生命周期目标里程碑。</strong>包括重要的文档，如项目构想，原始用力，原始业务风险评估，原始业务案例等。通过对文档的评审确定用例需求理解是否正确，项目风险评估是否合理，阶段计划是否可行，</li><li><strong>精化阶段：生命周期结构里程碑。</strong>包括风险分析文档， 软件体系结构基线，项目计划，可执行的原型，初始版本的用户手册。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。</li><li><strong>构建阶段：初始功能里程碑。</strong>包括可运行的软件产品，用户手册等，决定了产品是否可在测试环境中进行部署。</li><li><strong>产品阶段：产品发布里程碑。</strong> 确定最终目标是否实现，是否应该开始产品下一个版本或下一轮迭代。</li></ul><hr><h3 id="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"><a href="#软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？" class="headerlink" title="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"></a><strong>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong></h3><p>软件企业采用迭代式的方法来生产，每轮迭代具有固定的周期和明确的里程碑目标，同时软件项目管理人员能够利用软件产品范围的弹性，合理规划软件的范围（20%业务决定80%的满意度），由此软件产品的生产、发布可以按固定节奏和周期进行。</p><p>固定节奏生产，固定周期发布产品有助于企业量化生产过程，个人贡献度，人力资源利用率等数据，以便更好地监督，控制，调整，评估整个生产过程和结果。同时又能及时地收集产品反馈，了解项目的不足，进一步做出项目的优化措施，降低项目风险，提高软件质量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Student ID：16340186&lt;/p&gt;
&lt;p&gt;Name: 邱奕浩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统分析与设计" scheme="https://joshuaqyh.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 软件复杂性分析</title>
    <link href="https://joshuaqyh.github.io/2019/04/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <id>https://joshuaqyh.github.io/2019/04/10/软件工程-软件复杂性分析/</id>
    <published>2019-04-10T02:14:28.000Z</published>
    <updated>2019-04-10T03:39:41.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件复杂性概述"><a href="#软件复杂性概述" class="headerlink" title="软件复杂性概述"></a>软件复杂性概述</h1><p><strong>软件复杂性问题定义</strong></p><p>软件复杂性与程序复杂性不一样，软件复杂性是一个更为高层的概念，主要反映为分析，设计，测试，维护和修改软件的困难程度或复杂程度。而软件复杂性也是软件危机产生的最直接原因，人类的思维有限，要明确的认识软件的运行对人类而言有点勉强，我们只能通过定义软件的对象，属性，边界，交互逻辑来描述软件的运行机制。</p><p>当软件的运行逻辑条目越来越多时，复杂性呈指数提高，软件复杂性已经远远超过人类对复杂性控制的能力，软件隐含错误的概率越来越多，软件可靠性和可维护性越差，甚至可能引发软件项目的失败。软件复杂性是无法避免的，就像软件危机一样，是客观存在的，我们只能尽可能地以某种概率来减轻其不良影响。</p><p>分析，度量和控制软件复杂性是软件可靠性工程急需解决的重要问题，我们可以通过降低由软件设计方法和技巧使用不当而带来的复杂性，以更好地对软件开发过程进行控制。软件复杂性同时也直接关联到对软件开发费用，开发周期和软件内部隐藏错误的评估。</p><p><strong>软件复杂性出现的主要原因</strong> </p><ol><li>软件应用需求的复杂性；</li><li>软件应用框架，结构及模型的复杂性；</li><li>开发环境及应用环境的复杂性；</li><li>软件开发过程的复杂性；</li><li>涉及人力管理的复杂性 </li><li>软件设计与验证的复杂性。</li></ol><h1 id="软件结构复杂性"><a href="#软件结构复杂性" class="headerlink" title="软件结构复杂性"></a>软件结构复杂性</h1><p><strong>软件复杂性的主要体现</strong></p><ol><li>软件结构复杂性</li><li>程序算法复杂性</li></ol><p><strong>软件复杂性形成的根源</strong></p><p>软件设计过程是根源，我们在需要：</p><ol><li>进行概要设计的时候需要对<strong>软件总体模块结构复杂性</strong>进行有效控制；</li><li>在进行详细设计的时候对<strong>模块结构复杂性和模块内部复杂性</strong>进行控制。</li></ol><p>使之保持在一个合理的范围内。</p><p>软件结构复杂性体现为</p><ol><li>模块复杂性：<ol><li>模块内部结构复杂性：<ol><li>McCabe 度量</li><li>Halstead 度量</li></ol></li><li>模块接口复杂性：<ol><li>模块调用关系图</li><li>模块或信息的扇入扇出数来度量</li></ol></li></ol></li><li>总体结构复杂性<ol><li>尚无权威的度量方法</li><li><strong>矛盾</strong>：单个模块划分越小，功能越简单，虽然降低模块内部结构复杂性，但是模块之间联系多，接口 复杂，总体复杂性增加。</li></ol></li></ol><h1 id="软件复杂性控制"><a href="#软件复杂性控制" class="headerlink" title="软件复杂性控制"></a><strong>软件复杂性控制</strong></h1><ul><li>内部模块结构复杂性控制<ul><li>模块隔离。单个模块进行单独的编制，调试，查错，修改 ，测试和维护。模块隔离有助于防止错误蔓延，降低软件复杂性，提高软件可靠性。</li><li>控制模块大小和结构的控制。</li></ul></li><li>总体结构复杂性控制<ul><li>提高模块独立性<ul><li>模块耦合性控制。尽量使用数据耦合，少用 控制耦合，限制公共耦合范围，完全不用内容耦合四个原则。减少耦合性，降低模块复杂性。</li><li>模块高内聚，并能识别低内聚。内聚是指模块功能的相对强度，用于衡量一个模块内部各元素彼此结合的紧密程度，是信息隐蔽和局部化的自然延伸。</li></ul></li><li>保持适当的扇入扇出。扇出量<ul><li>扇出量越大，模块功能宽度越大，模块就越复杂。</li><li>扇出量太小，下级模块进一步分解成若干子模块并合并到上级模块。</li></ul></li><li>简化软件接口<ul><li>接口传递的信息尽量保持简单。</li><li>单入口，单出口。</li><li>避免模块接口之间的病态连接，杜绝引入或引用一个模块内部结构。</li></ul></li></ul></li></ul><p><strong>形成软件复杂性的重要原因</strong></p><ol><li>控制结构和数据结构复杂的程序复杂性高；</li><li>转向语句使用不当的程序复杂性高；</li><li>非局部变量较多的程序复杂性高；</li><li>按地址调用参数比按值调用参数的复杂性高；</li><li>模块及过程之间联系密切的程序的复杂性高；</li><li>嵌套深度大的程序的复杂性高；</li><li>循环结构的复杂性比选择结构和顺序结构的复杂性高；</li><li>模块宽度是形成软件复杂性的主要原因。</li></ol><p>软件复杂性度量的基本度量准则集。</p><h1 id="软件复杂性度量"><a href="#软件复杂性度量" class="headerlink" title="软件复杂性度量"></a>软件复杂性度量</h1><p>软件复杂性度量的结果是软件复杂度，是对软件复杂性的定量描述，为软件复杂性的定量分析和控制提供依据，是软件复杂性分析和控制研究的基础。</p><p>软件复杂性度量的根本目的：通过控制软件复杂性来改善和提高软件的可靠性。</p><p>软件复杂性的度量的方法和标准主要分为两大类：</p><ol><li>面向过程的软件复杂性度量：<ol><li>代码语句行度量</li><li>基于FPA（功能点分析）的度量</li><li>Halstead 软件科学度量法！！</li><li>McCabe 结构复杂性度量</li></ol></li><li>面向对象的软件复杂性度量<ol><li>C&amp;K，MOOD</li></ol></li></ol><p>复杂性度量元的分类：</p><ol><li>规模： 命令总数。如line count</li><li>难度：程序出现操作数的数目所决定的量表示。如Halstead 复杂性</li><li>结构：通常与程序结构有关的度量，McCabe 复杂度</li><li>智能度：算法难易程度。</li></ol><p><strong>LineCount 复杂度</strong> （规模度量元）</p><p>统计程序的源代码行数，将其作为程序复杂性的度量。</p><p><strong>Halstead 复杂度</strong>（难度度量元）</p><p>Halstead 复杂度根据程序中语句行的操作符和操作数的数量计<br>算程序复杂性。</p><ul><li>操作符和操作数的量越大，程序结构就越复杂。</li><li>操作符包括语言保留字、函数调用、运算符，也可以包括有关的分隔符等。</li><li>操作数可以是常数和变量等标识符。</li></ul><p>Halstead 复杂度有11种方法，见PPT3.3 P21-22</p><p><strong>McCabe 复杂度</strong> （结构度量元）</p><p>McCabe 对程序流程图PFC进行静态分析，并将其转化为程序控制流图CFG，然后以图论的方法进行严格的结构分析 。</p><p>McCabe 复杂度包括：</p><ol><li><p>环路复杂度</p><ol><li>衡量判定模块的复杂程度。数量上可以表现为程序控制流图(第4章讨论) 中从<br>开始点到终结点的独立路径条数，相当于合理预防错误所需测试的最少路径条数。</li><li>计算公式 ：V(G) = m - n + 2p  m 是G 的边数目；n 是G 的顶点数目；p 是G 的连通分支数</li><li>结构化模块：单入口单出口；非结构化模块：（可选的）多入口多出口。</li><li>当结构化模块程序控制流图增加从出口指向入口的辅助边，形成强连通图。此时强连通图的环路复杂度定义为图的秩数。</li></ol><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190410113719.png" alt=""></p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件复杂性概述&quot;&gt;&lt;a href=&quot;#软件复杂性概述&quot; class=&quot;headerlink&quot; title=&quot;软件复杂性概述&quot;&gt;&lt;/a&gt;软件复杂性概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;软件复杂性问题定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件复杂性与程序复杂性不一样，软
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件测试" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 | 认识动态规划</title>
    <link href="https://joshuaqyh.github.io/2019/04/05/%E7%AE%97%E6%B3%95-%E8%AE%A4%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://joshuaqyh.github.io/2019/04/05/算法-认识动态规划/</id>
    <published>2019-04-05T08:22:07.000Z</published>
    <updated>2019-04-05T09:27:34.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字三角形问题"><a href="#数字三角形问题" class="headerlink" title="数字三角形问题"></a>数字三角形问题</h1><p>给定一个数字等腰的数字三角形，第一行只有一个数字，每增加一行数字的个数就加一。然后现在要求从三角形顶部到底边所经过的路径的数字之和的最大值。</p><p>我们先定义一个二维数组来存放数字三角形，这个三角形的存放是直角三角形的形状。</p><p>这个问题使用递归的方式来求解，相当的简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// i j 代表从数组的第i行第j个开始求和  n代表三角形的最大行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == n)</span><br><span class="line">        <span class="keyword">return</span> D[i][j];</span><br><span class="line">    <span class="keyword">int</span> x = MaxSum(i + <span class="number">1</span>, j, n);</span><br><span class="line">    <span class="keyword">int</span> y = MaxSum(i + <span class="number">1</span>, j + <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> max(x, y) + D[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：这个程序的时间复杂度太大了！！！！当三角形高度过大的时候，会超时的！！ O(2^n) !!</p><p>改进方法，每算出一个maxsum就保存起来，下次直接取值。不需要再访问。$O（n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆递归形程序</span></span><br><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> maxsum[MAX][MAX];  <span class="comment">// 初始化为 -1</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> maxsum[i][j] != <span class="number">-1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxsum[i][j]</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (i == n)&#123;</span><br><span class="line">        maxsum[i][j] = D[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = MaxSum(i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">int</span> y = MaxSum(i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">        maxsum[i][j] = x + y + D[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum[i]][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写成递推的方式.同样是$O(n^2)$ </p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190405164132.png?token=AZHt8AWjatGIbxaT3j5NU6duU1AMt71nks5cpxT_wA%3D%3D" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 101</span></span><br><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> maxsum[MAX][MAX];  <span class="comment">// 初始化为 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        maxsum[n][i] = D[n][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            maxsum[i][j] = max(maxsum[i + <span class="number">1</span>][j] + maxsum[i + <span class="number">1</span>][j + <span class="number">1</span>]) + D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxsum[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述方式进行空间优化就是利用一维数组maxsum来存放每一层递推求解的结果。因为在当前递推层结束之后，上一层递推的结果是多余的，不会再用到了，我们可以直接覆盖之。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码是</span></span><br><span class="line"><span class="keyword">int</span> maxsum[MAX]； </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">max[i] = D[n][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n, j++)&#123;</span><br><span class="line">maxsum[j] = max(maxsum[j], maxsum[j+<span class="number">1</span>]) + D[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更精简的做法是，使用D数组的最后一行当作一维的maxsum数组。。。空间更加节省了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D[n][j] = max(D[n][j], D[n][j+<span class="number">1</span>]) + D[i][j];</span><br></pre></td></tr></table></figure><p>动态规划的思路就是找到一个问题的子问题，对子问题逐步细化到最简单的状态，然后子问题逐层递推（递归）解决，最终保证问题的解决。</p><p>我们需要找到子问题的状态转移过程，理解完过程之后就比较好写代码了。</p><p>建议从最简单的递归程序实现，然后递推实现优化时间复杂度，再来就考虑空间优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数字三角形问题&quot;&gt;&lt;a href=&quot;#数字三角形问题&quot; class=&quot;headerlink&quot; title=&quot;数字三角形问题&quot;&gt;&lt;/a&gt;数字三角形问题&lt;/h1&gt;&lt;p&gt;给定一个数字等腰的数字三角形，第一行只有一个数字，每增加一行数字的个数就加一。然后现在要求从三角形顶
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法 | 分治-输出前 m 大的数</title>
    <link href="https://joshuaqyh.github.io/2019/04/02/%E5%88%86%E6%B2%BB-%E8%BE%93%E5%87%BA%E5%89%8DK%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
    <id>https://joshuaqyh.github.io/2019/04/02/分治-输出前K大的数/</id>
    <published>2019-04-01T17:05:15.000Z</published>
    <updated>2019-04-01T17:42:41.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输出前-m-大的数"><a href="#输出前-m-大的数" class="headerlink" title="输出前 m 大的数"></a>输出前 m 大的数</h1><p>假设数组长度为 n，要输出前m大的数，m &lt; = n，想法有两种：</p><ol><li>先排序后输出，算法复杂度为 O(n log n)</li><li>先在 O（n）时间内将前m大的数放到数组的右边，然后对其进行快排O(mlogm)，时间复杂度为 O（n+mlogm）。</li></ol><p>在m较小，n较大的情况下，第二种做法显然比较可取。</p><p> 那么如何在 O（n）的时间内将前m大的数放在数组的右边呢。</p><p>我们引入 arrangeRight（k）：即把前K大的数放在数组的最右边。</p><p>同快排一样，我们选取一个位置 a = key[0]，我们为 a 选择一个合适的位置，保证左边的数小于等于 a，右边的数大于等于a。然后判断 a右边的数组的数目和左边的数目</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190402011549.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= e)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = a[s];</span><br><span class="line">    <span class="keyword">int</span> i = s;</span><br><span class="line">    <span class="keyword">int</span> j = e;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; i &amp;&amp; a[j] &gt;= k) j--;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= k ) i++;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(a, s, i - <span class="number">1</span>);</span><br><span class="line">    qsort(a, i + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrangeRight</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// a: 数组指针   k：前k大, s:起始索引 e:结束索引  </span></span><br><span class="line">    <span class="keyword">int</span> key = a[s];</span><br><span class="line">    <span class="keyword">int</span> i = s;</span><br><span class="line">    <span class="keyword">int</span> j = e;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= key) j--;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= a[i]) i++;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == e - k + <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i + k &gt; e + <span class="number">1</span>) arrangeRight(a, k, i, e);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i + k &lt; e - <span class="number">1</span>) arrangeRight(a, k-a, s, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">arrangeRight(a, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">qsort(a, e - k + <span class="number">1</span>, e);</span><br><span class="line">print...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输出前-m-大的数&quot;&gt;&lt;a href=&quot;#输出前-m-大的数&quot; class=&quot;headerlink&quot; title=&quot;输出前 m 大的数&quot;&gt;&lt;/a&gt;输出前 m 大的数&lt;/h1&gt;&lt;p&gt;假设数组长度为 n，要输出前m大的数，m &amp;lt; = n，想法有两种：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法 | 分治（快排-归并）</title>
    <link href="https://joshuaqyh.github.io/2019/04/01/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"/>
    <id>https://joshuaqyh.github.io/2019/04/01/算法-分治/</id>
    <published>2019-03-31T16:00:20.000Z</published>
    <updated>2019-03-31T17:15:37.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序的思路就是：</p><ul><li>排序好数组 1</li><li>排序好数组 2</li><li>然后将两个数组合并</li></ul><p>时间复杂度：</p><p>对n个元素进行排序的时间，T（n) = O(nlogn)</p><p>利用递归表达式来推导时间复杂度如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190401004332.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> e, <span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="comment">// 对区间 [s, m] 和 [m + 1, e]两个区间的数组进行合并,存储到tmp；</span></span><br><span class="line">    <span class="comment">// 然后保证tmp有序，然后再将tmp的内容拷贝会 a[s, e]</span></span><br><span class="line"><span class="keyword">int</span> pb = <span class="number">0</span>;   <span class="comment">// tmp 数组的下标</span></span><br><span class="line"><span class="keyword">int</span> p1 = s;   <span class="comment">// p1, p2 为两个区间的开始索引指针</span></span><br><span class="line"><span class="keyword">int</span> p2 = m + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;= e)&#123; <span class="comment">// 在两个子数组中，比较两个指针指向的两个数，</span></span><br><span class="line">        <span class="keyword">if</span>(a[p1] &lt; a[p2])&#123;    <span class="comment">// 较小的数存入tmp，同时索引递增</span></span><br><span class="line">            tmp[pb++] = a[p1++]; <span class="comment">//直到有其中一个子数组所有值已经被复制到tmp后停止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[pb++] = a[p2++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里直接按顺序将未写入到tmp的数写入。因为底层归并时，已经排序好了。</span></span><br><span class="line">    <span class="keyword">while</span>( p1 &lt;= m)&#123;</span><br><span class="line">        tmp[pb++] = a[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( p2 &lt;= e)&#123;</span><br><span class="line">        tmp[pb++] = a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制值回到原始数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pb; i++)&#123;</span><br><span class="line">        a[s + i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> tmp[])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    a: 待排序的数组</span></span><br><span class="line"><span class="comment">    s：开始排序的下标</span></span><br><span class="line"><span class="comment">    e: 结束排序的下标</span></span><br><span class="line"><span class="comment">    tmp: 临时存放排序的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 当开始下标和结束下标大小一致时，结束归并</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt; e)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(a, s, m, tmp);</span><br><span class="line">        MergeSort(a, m, e, tmp);</span><br><span class="line">        Merge(a, s, m, e, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序也是一个典型的分治算法，其思想相当简洁：</p><ul><li>找到其中一个数k，将其挪到适当的位置，使得比 k 小的元素都排在左边，比k大的元素都排在右边</li><li>然后对k的左边进行排序</li><li>对k的右边进行排序</li></ul><p>一般情况为 nlogn，最坏情况是 n^2；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// a 为待排序的数组</span></span><br><span class="line">    <span class="comment">// s 为要处理的数组前索引</span></span><br><span class="line">    <span class="comment">// e 为要处理的数组后索引 s，e构成一个子数组</span></span><br><span class="line">    <span class="keyword">if</span>(s &gt;= e)  <span class="comment">// 当前后边界相等时，开始返回</span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">int</span> k = a[s];  <span class="comment">// 选择子数组的第一个数，下一步将要为其挑选一个合适的位置，保证该位置的左边都</span></span><br><span class="line">      <span class="comment">// 小于k，右边都大于k</span></span><br><span class="line">    <span class="keyword">int</span> i = s;</span><br><span class="line">    <span class="keyword">int</span> j = e;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; i &amp;&amp; a[j] &gt;= k) --j;  <span class="comment">// 当尾部的数e，大于k时，需要向前移动一位e--，</span></span><br><span class="line">          <span class="comment">// 继续比较直到小于k</span></span><br><span class="line">        swap(a[i], a[j]); <span class="comment">// 找到一个 j 指向的数min小于 k时，需要交换min，k的位置</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= k) ++i; <span class="comment">// 当前部的数s，小于k时，向后移动一位，</span></span><br><span class="line">        <span class="comment">// 继续比较，直到大于 k</span></span><br><span class="line">        swap(a[j], a[i]);  <span class="comment">// 找到一个数，大于k，需要交换位置。</span></span><br><span class="line">    &#125; <span class="comment">// 直到两个索引 i，j相等事，k已放置在合适的位置，左边小于k，右边大于k。</span></span><br><span class="line">    QuickSort(a, s, i - <span class="number">1</span>); <span class="comment">// 对 k 左右两边进行上述操作</span></span><br><span class="line">    QuickSort(a, i + <span class="number">1</span>, e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;p&gt;归并排序的思路就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序好数组 1&lt;/li&gt;
&lt;li&gt;排序好数组 2&lt;/li&gt;
&lt;li&gt;然后将两
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法 | 递归求解N皇后问题</title>
    <link href="https://joshuaqyh.github.io/2019/03/30/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>https://joshuaqyh.github.io/2019/03/30/算法-递归求解N皇后问题/</id>
    <published>2019-03-29T18:27:41.000Z</published>
    <updated>2019-03-29T18:38:51.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>输入一个数N，要求输出满足N皇后规则的所有皇后位置的情况。</p><p>利用递归的思想，可以有效的解决这个问题。</p><p>我们可以假设前 k - 1行都没有发生冲突，现在需要决定 第 k 行的皇后位置。</p><p>我们只需要判断某位置是否与前 k -1行的皇后是否冲突即可，不冲突就可以放置，然后继续下一轮的放置（此处利用递归）。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> queenPos[<span class="number">100</span>]; <span class="comment">// 假设最多不超过N个皇后，此处用于存放每一行的皇后的列数</span></span><br><span class="line"><span class="keyword">int</span> N = <span class="number">66</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">// 假设前 k - 1行已经完毕，需要放置第 k 行</span></span><br><span class="line">    <span class="keyword">if</span>(k == N)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; queenPos[i] &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定一个与已经放置的皇后位置不冲突的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;  <span class="comment">// 尝试所有位置，判断是否冲突</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queenPos[j] == i || <span class="built_in">abs</span>(k - j) != <span class="built_in">abs</span>(i - queenPos[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == k)&#123; <span class="comment">// 无冲突</span></span><br><span class="line">            queenPos[k] = i; <span class="comment">// 放置在该位置</span></span><br><span class="line">            NQueen(k+<span class="number">1</span>);     <span class="comment">// 确定下一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;输入一个数N，要求输出满足N皇后规则的所有皇后位置的情况。&lt;/p&gt;
&lt;p&gt;利用递归的思想，可以有效的解决这个问题。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 | 二叉树</title>
    <link href="https://joshuaqyh.github.io/2019/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://joshuaqyh.github.io/2019/03/29/数据结构-二叉树/</id>
    <published>2019-03-29T08:56:20.000Z</published>
    <updated>2019-03-29T15:10:29.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非递归实现遍历"><a href="#非递归实现遍历" class="headerlink" title="非递归实现遍历"></a>非递归实现遍历</h1><ul><li><p>前序遍历非递归实现</p><ul><li>使用栈来完成。</li><li>访问左节点，压入右节点。</li><li>左节点为空，弹出右节点。</li></ul></li><li><p>中序遍历非递归实现</p><ul><li>使用栈来完成</li><li>遇到一个节点，将其推入栈，遍历其左子树</li><li>遍历完左子树，弹出栈顶节点并访问</li><li>同时遍历其右节点，重复上述动作。</li></ul></li><li><p>非递归后续遍历二叉树</p><ul><li>从根节点开始，判断栈空还是非空</li><li>沿左路下降。。。</li><li>最难的。。总之就是左右子树访问完毕，才访问根节点</li></ul><p>O(n) </p><p>​</p></li></ul><h1 id="二叉树的搜索"><a href="#二叉树的搜索" class="headerlink" title="二叉树的搜索"></a>二叉树的搜索</h1><ul><li>宽度搜索<ul><li>队列来存储</li><li>类似层序遍历。</li><li>访问当前节点，将左右节点压入队列</li><li>弹出当前节点</li></ul></li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>使用二叉链表的信息。当前节点，存储左右节点的指针。（还有的保存了parent指针）</p><p>寻找一个指针的父节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">FindParent</span><span class="params">(Node* root, Node* current)</span></span>&#123;</span><br><span class="line">    Node* tmp;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// root 是否为 current的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == current || root-&gt;right == current)&#123;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp = FindParent(root-&gt;left, current) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp = FindParent(root-&gt;right, current) != <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> tmp;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">Tree</span><span class="params">(Node* current)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">    Node* tmp = root;</span><br><span class="line">    s.push(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全二叉树，用数组层序存储。</p><p>编号为 i 的节点的左节点为 2 i + 1</p><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>快速搜索，时间复杂度为 O(log n )</p><p>其中的构建二叉搜索树比较简单。这里重点记一下，BST删除节点的操作。</p><p>我们使用递归的来删除节点，需要分三种情况：</p><ol><li>节点的左节点为空，直接将右节点复制到删除节点的位置。（不用考虑右节点是否为空）</li><li>如果左节点非空，右节点为空，那就将左节点复制到删除节点的位置。</li><li>如果左右节点都不为空，那就找出左子树中的最右节点，将右子树的根节点拼接到该最右节点的右边。<ol><li>这个方法其实会导致挂接后，整个树的高度过长，影响搜索的效率</li><li>我们可以换另外一种思路，就是找到右子树的最小节点，保存其值，赋值给删除节点，然后删除右子树的最小节点。</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removehelp</span><span class="params">(Node* &amp;root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" is not in the tree \n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">        removehelp(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root-&gt;val)&#123;</span><br><span class="line">        removehelp(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node* tmp = root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) root = = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp = deletemin(root-&gt;right); <span class="comment">// 找到右子树中最小的那个数 min，并删除</span></span><br><span class="line">            root-&gt;setValue(tmp-&gt;value); <span class="comment">// 将 min中的数赋值给删除的节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">deletemin</span><span class="params">(Node * &amp;root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> deletemin(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 找到右子树中最小的，删除，然后将该节点复制到原先被删除节点的位置</span></span><br><span class="line">        node *tmp = root;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何放置BST退化成线性结构？</p><p>允许重复关键码吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;非递归实现遍历&quot;&gt;&lt;a href=&quot;#非递归实现遍历&quot; class=&quot;headerlink&quot; title=&quot;非递归实现遍历&quot;&gt;&lt;/a&gt;非递归实现遍历&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前序遍历非递归实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用栈来完成。&lt;/li&gt;
&lt;li&gt;访
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="数据结构" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode | Practice 7</title>
    <link href="https://joshuaqyh.github.io/2019/03/29/Leetcode-Practice-7/"/>
    <id>https://joshuaqyh.github.io/2019/03/29/Leetcode-Practice-7/</id>
    <published>2019-03-29T07:40:47.000Z</published>
    <updated>2019-05-16T14:04:13.578Z</updated>
    
    <content type="html"><![CDATA[<p>如<a href="https://leetcode.com/problems/decoded-string-at-index/" target="_blank" rel="noopener">题</a>。</p><p>题目的要求就是输入一个编码的串S，包含数字和字母，从头开始读取，如果读取到字母，就直接放入结果的解码串，如果读取到数字，就把解码串已有的内容复制几遍。</p><p>最后给定一个数K，返回该位置的字符。</p><p>想来是比较简单的，因为可以直接申请一个string，读到字母就往里头append，读到数字就复制几遍，然后最后按索引输出结果字符就行了。先试试。</p><p>果然有坑！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeAtIndex</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> contain = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] &gt; <span class="string">'1'</span> &amp;&amp; S[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; S[i] - <span class="string">'0'</span>; j++)&#123;</span><br><span class="line">                    contain += contain;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                contain.append(<span class="number">1</span>, S[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; contain[K - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">string</span> res = ss.str();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a2345678999999999999999&quot;, K = 1</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The decoded string is &quot;a&quot; repeated 8301530446056247680 times.  The 1st letter is &quot;a&quot;.</span><br></pre></td></tr></table></figure><p>内存会不够的！！</p><p>得另外确定一个思路，可以考虑一下在复制过程中，直接输出K处的结果。</p><p>emmm 不需要复制字符串，不然内存占用太大了。。</p><p>可以先确定解码后的字符串长度。</p><p>然后再反向遍历初始字符串，然后对解码后的字符串长度进行缩短。知道缩短至长度为K时，输出字符。</p><p>太妙了！（不是我写的，逃。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeAtIndex</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = S.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find size = length of decoded string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(S[i]))</span><br><span class="line">                size *= S[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            K %= size;</span><br><span class="line">            <span class="keyword">if</span> (K == <span class="number">0</span> &amp;&amp; <span class="built_in">isalpha</span>(S[i]))</span><br><span class="line">                <span class="keyword">return</span> (<span class="built_in">string</span>) <span class="string">""</span> + S[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(S[i]))</span><br><span class="line">                size /= S[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如&lt;a href=&quot;https://leetcode.com/problems/decoded-string-at-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;题目的要求就是输入一个编码的串S，包含数字和字母，从
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="Leetcode" scheme="https://joshuaqyh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 正确性要素 on SDLC</title>
    <link href="https://joshuaqyh.github.io/2019/03/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A6%81%E7%B4%A0-on-SDLC/"/>
    <id>https://joshuaqyh.github.io/2019/03/27/软件工程-正确性要素-on-SDLC/</id>
    <published>2019-03-27T13:47:37.000Z</published>
    <updated>2019-03-27T16:27:44.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>选择一个测试要素，以你做过的一个软件作品为例，分别讨论该要素在软件生命周期的需求，设计，编程，测试，安装和维护各阶段的测试目标和内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327233612.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h1><p>以我上学期做过的<a href="https://github.com/JoshuaQYH/MyTrelloDApp" target="_blank" rel="noopener">区块链DAPP课程项目 MyTrello (基于以太坊的去中心化日程管理 Web 应用)</a>为例（主要涉及了两大核心的功能：<strong>团队人员管理和任务驱动协作），</strong> 我选择 <strong>正确性</strong>测试要素进行讨论。该要素在软件生命周期的各个阶段的测试目标和内容总结如下。</p><h2 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h2><p><strong>事件</strong>：定义产品的功能规格说明。</p><p><strong>目标：</strong></p><p> 保证需求分析的正确性以及充分性。具体来讲其目标是保证需求正确反应用户的需要，需求被定义和文档化。</p><p><strong>内容：</strong></p><ol><li>检查需求分析所定义的功能是否反映用户需求。即认真审视以团队为单元，以任务流为驱动，以以太坊智能合约技术为基础的去中心化 <code>web app</code> 的正确性。</li><li>测试需求是否已经被明确定义，以及输出合理规范的需求文档。 即是否产出作为一个团队日程管理所具备的核心功能的需求规格说明书。</li><li>检测产品需求功能是否满足课程要求。</li></ol><h2 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h2><p><strong>事件</strong>：设计符合需求。</p><p><strong>目标</strong>： 对设计阶段产出的文档和架构说明进行评审；当需求分析发生改变时，测试要对修改的部分进行检查，确保设计与需求保持一致。</p><p><strong>内容：</strong></p><ol><li>评估技术选型和架构是否有满足需求。分析选用 <code>solidity</code> 语言编写智能合约是否可靠，使用 <code>solc</code> 编译合约是否合理，使用<code>web.js</code> 来部署调用合约是否妥当，使用<code>react</code>作为前端框架是否足够高效等等。</li><li>评审设计阶段产出的文档，在功能设计上是否符合需求规格。即对比需求文档，从本项目中的<strong>团队管理和任务流驱动</strong>的两个核心功能出发，检查设计的接口是否符合需求，评审设计文档中是否存在着对需求遗漏缺失，理解认知错误的地方，有则修正设计文档。</li></ol><h2 id="编程阶段"><a href="#编程阶段" class="headerlink" title="编程阶段"></a>编程阶段</h2><p><strong>事件</strong>：程序符合设计。</p><p><strong>目标</strong>： 检测编码是否与设计一致，是否正确地实现系统功能需求，编码是否正确地按照既有的标准进行。</p><p><strong>内容</strong>：</p><ol><li>测试编码是否与设计文档定义一致，包括模块化，接口定义，界面设计。即检查智能合约中的接口功能是否与设计文档保持一致，编译、部署、调用合约是否按照设计文档中的规范进行。若未一致，则结合设计文档对现有代码进行修正。</li><li>测试程序的能否正确运行。使用黑盒、白盒测试对本日程管理应用的每个单元模块进行测试。</li></ol><h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><p><strong>事件：</strong> 功能测试。</p><p><strong>目标：</strong>进行第三方的正式确认测试，检验所开发的系统是否按照用户提出的要求运行。</p><p><strong>内容：</strong></p><p>在一个新的应用系统来进行测试，运行部分或全部系统，确认用户需求被满足。按照用户规定的需求来测试应用功能，检查应用<strong>是否能正常连接以太坊公有测试网络，是否能正常完成团队管理和任务管理这两大功能</strong>，确认产品功能是否正确满足了用户的需求。若未能正确满足，则重新检查修改，以匹配需求。</p><h2 id="安装阶段"><a href="#安装阶段" class="headerlink" title="安装阶段"></a>安装阶段</h2><p><strong>事件</strong>：正确的程序和数据防入产品。</p><p><strong>目标</strong>： 保证被测试系统不存在问题，注重对程序安装的正确性和完整性进行核对。</p><p><strong>内容：</strong></p><p>对程序安装的正确性进行核对。按照系统安装说明手册的步骤进行，确定好测试环境（<code>win10</code>  <code>nodejs</code> <code>metamask</code> ），借助<code>npm</code> 包管理器安装好软件相应的包和环境依赖。使用命令运行项目，在浏览器查看项目的安装情况。若失败，则要寻求相应的解决方案。</p><h2 id="维护阶段"><a href="#维护阶段" class="headerlink" title="维护阶段"></a>维护阶段</h2><p><strong>事件：</strong>修改需求</p><p><strong>目标</strong>：根据软件实际运行情况以及用户的反馈对软件功能或需求进行适当的修正。</p><p><strong>内容</strong>： </p><p>经过多次的使用，对项目一些细节有了新的需求。比如在本日程管理项目中增加事件通知，任务历史记录功能，赋予更加简洁灵活的任务交互操作，修改冗余的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h1&gt;&lt;p&gt;选择一个测试要素，以你做过的一个软件作品为例，分别讨论该要素在软件生命周期的需求，设计，编程，测试，安装和维护各阶段的测试目
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件测试" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试 | 敏捷宣言四-风险评估</title>
    <link href="https://joshuaqyh.github.io/2019/03/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E5%9B%9B-%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"/>
    <id>https://joshuaqyh.github.io/2019/03/27/软件测试-敏捷宣言四-风险评估/</id>
    <published>2019-03-27T12:38:27.000Z</published>
    <updated>2019-03-27T12:39:07.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在敏捷宣言遵循的12条原则中，挑选一条你最感兴趣的原则进行风险评估。</p><h2 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h2><p>在12条原则中，我选择进行阐释的原则是第4条，即：</p><p><strong>在整个项目过程中，业务人员和开发人员每天在一起工作。</strong></p><p>以下是个人评估过程，所阐述的原则简称<strong>原则4</strong>。</p><p><strong>关于风险。</strong>敏捷开发中主要存在着四个维度的风险：分别是人员风险、技术风险，产品风险和过程风险。它们相互联系和同一，决定了软件开发的效率。而其中与原则4相关联的风险就是<strong>人员风险</strong>。</p><p><strong>首先必须明确人员风险是什么。</strong>人员风险主要有：团队成员沟通不畅，对业务不理解，不熟悉，缺乏高效协作；人员变动频繁，缺乏激励，工作氛围低下；成员道德素质、能力素质低下；成员之间存在潜在的矛盾和冲突；缺乏客户介入等。这些风险对团队都具有一定的破坏性，可以通过调整工作模式，工作顺序来进行一定程度上的规避和预防。</p><p><strong>原则4对人员风险的具有一定的规避作用</strong>。在原则4中，它强调的是业务人员和开发人员必须紧密结合，保持高效顺畅的沟通。在项目的整个流程中，开发和业务人员每天一起工作，保证业务和开发工作进度的有效控制和跟踪。由于业务人员和开发人员空间和交流成本的降低，可通过频繁沟通，短会议，及时反馈的方式来解决沟通不畅，缺乏协作的问题。业务人员可以在第一时间识别新的业务需求并快速传达给开发人员，通知制定相应的架构编码任务并实施，而开发人员也可以在第一时间提交业务反馈和业务代码变更的需求，业务人员也可以快速响应开发人员的请求，迅速实现业务的动态灵活调整。</p><p>在高效的协作和响应的敏捷开发工作模式下，团队成员沟通不畅的问题得到有效解决，业务人员能够快速摸清产品的真实需求并制定相应的业务策略，而开发人员能更好的识别业务需求，实现敏捷开发，一定程度避免开发进度过慢甚至失败的局面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在敏捷宣言遵循的12条原则中，挑选一条你最感兴趣的原则进行风险评估。&lt;/p&gt;
&lt;h2 id=&quot;风险评估&quot;&gt;&lt;a href=&quot;#风险评估&quot; c
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 | 字符串string 学习</title>
    <link href="https://joshuaqyh.github.io/2019/03/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2string-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://joshuaqyh.github.io/2019/03/26/数据结构-字符串string-学习/</id>
    <published>2019-03-26T14:16:17.000Z</published>
    <updated>2019-03-26T16:41:29.953Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容来自中国大学MOOC上北京大学的数据结构与算法的公开课。</p><p>主要从字符串string相关编码方面进行笔记的梳理，涉及：</p><ol><li>字符串常见操作实现</li><li>字符串的运算算法实现</li><li>字符串的快速模式匹配 （KMP）</li></ol><h1 id="字符串的存储和常见操作实现"><a href="#字符串的存储和常见操作实现" class="headerlink" title="字符串的存储和常见操作实现"></a>字符串的存储和常见操作实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span> d [])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(d[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串的拷贝操作</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *d, <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        d[i] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    d[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串的比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; s1[i] == s2[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s2[i] &amp;&amp; s1[i] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (s1[i] - s2[i]) / <span class="built_in">abs</span>(s1[i] - s2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* str;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">char</span> *str)&#123;</span><br><span class="line">        size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];</span><br><span class="line">        assert(str != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] str;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="keyword">operator</span>=(String &amp;s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str != s.size())&#123;</span><br><span class="line">            <span class="keyword">delete</span> []str;</span><br><span class="line">            str = <span class="keyword">new</span> <span class="keyword">char</span>[s.size() + <span class="number">1</span>];</span><br><span class="line">            assert(str != <span class="literal">NULL</span>);</span><br><span class="line">            size = s.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, s.c_str());\</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        assert(start &gt;= <span class="number">0</span> &amp;&amp; start + num - <span class="number">1</span>&lt; size);</span><br><span class="line">        <span class="keyword">char</span> * newstr = <span class="keyword">new</span> <span class="keyword">char</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != num)&#123;</span><br><span class="line">           newstr[i] = str[start + i];</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">        newstr[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> String(newstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start != end)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = str[start] - str[end];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                str[start] = str[start] - tmp;</span><br><span class="line">                str[end] = str[end] + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                str[end] = str[end] - tmp;</span><br><span class="line">                str[start] = str[start] + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            end--;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的模式匹配"><a href="#字符串的模式匹配" class="headerlink" title="字符串的模式匹配"></a>字符串的模式匹配</h1><h2 id="朴素模式匹配法（穷举法）"><a href="#朴素模式匹配法（穷举法）" class="headerlink" title="朴素模式匹配法（穷举法）"></a>朴素模式匹配法（穷举法）</h2><p>字符串匹配就是给定一个字符串，想要判断一下在该字符串中是否存在有一个子串，有则返回第一个匹配字符的下标，否则返回-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fidPat_3</span><span class="params">(<span class="built_in">string</span> T, <span class="built_in">string</span> P, <span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> g = startIndex; g &lt;= T.length() - P.length(); g++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (j &lt; P.length() &amp;&amp; P[j] == T[g + j]); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == P.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> g;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法最坏情况下的复杂度是 O(m × n), m 为长串的长度，n为短串的长度。</p><h2 id="快速模式KMP算法"><a href="#快速模式KMP算法" class="headerlink" title="快速模式KMP算法"></a>快速模式KMP算法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326235903.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>KMP算法就是在朴素匹配算法的基础之上，对每次滑动的位数 n 进行了提前的计算，减少了不要的冗余计算。</p><p>而这个滑动的位数计算的思想就是先建立一个关于模式串P中每一个字符的特征向量表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327000236.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327000253.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中next数组就是所谓的特征向量表。当 j ！= 0 时，向量元素值的含义就是在模式串本身的从0到 j - 1的子串中，首尾的的连续等长子串相等时的最大长度值k。</p><p>这样当模式串的第 j + 1个元素匹配错误的时候，我们就可以直接确定下一步滑动的位数为 j - k 位。</p><p>理由是模式串首部的前k个字符和模式串的 【j - k ： j 】的子串相匹配，下一次匹配时，可以用首部的串代替尾部的子串，然后减少比较次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPMatching</span><span class="params">(<span class="built_in">string</span> T, <span class="built_in">string</span> P, <span class="keyword">int</span> *N, <span class="keyword">int</span> start)</span></span>&#123; <span class="comment">// N 为特征向量</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 模式串P的比较位置</span></span><br><span class="line">    <span class="keyword">int</span> i = start; <span class="comment">// 目标串的比较位置</span></span><br><span class="line">    <span class="keyword">int</span> plen = P.length();</span><br><span class="line">    <span class="keyword">int</span> tlen = T.length();</span><br><span class="line">    <span class="keyword">if</span>(tlen - start &lt; plen)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; plen &amp;&amp; i &lt; tlen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || T[i] == P[j])&#123;</span><br><span class="line">            i++;  <span class="comment">// 如果两个比较位置相同，那么位置都递增</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">// 模式串在位置 j 发生了不匹配</span></span><br><span class="line">            j = N[j];  <span class="comment">// 模式串的比较位置需要更新为特征向量的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= plen)&#123;  <span class="comment">//匹配成功，返回匹配子串的起始位置</span></span><br><span class="line">        <span class="keyword">return</span> (i - plen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327002839.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fineNext</span><span class="params">(<span class="built_in">string</span> P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="keyword">int</span> m = P.length();</span><br><span class="line">assert(m &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    assert(next != <span class="literal">NULL</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    j = <span class="number">0</span>; k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; m - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; P[k] != P[j])&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        j++; k++; next[j] = k;</span><br><span class="line">        <span class="comment">// 进行优化</span></span><br><span class="line">        <span class="keyword">if</span> (P[k] == P[j])&#123;</span><br><span class="line">            next[j] = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> next[j] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文内容来自中国大学MOOC上北京大学的数据结构与算法的公开课。&lt;/p&gt;
&lt;p&gt;主要从字符串string相关编码方面进行笔记的梳理，涉及：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符串常见操作实现&lt;/li&gt;
&lt;li&gt;字符串的运算算法实现&lt;/li&gt;
&lt;li&gt;字符串的快速模式匹配 （KMP
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="数据结构" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode | Practice 6</title>
    <link href="https://joshuaqyh.github.io/2019/03/26/Leetcode-Practice-6/"/>
    <id>https://joshuaqyh.github.io/2019/03/26/Leetcode-Practice-6/</id>
    <published>2019-03-26T13:21:05.000Z</published>
    <updated>2019-05-16T14:04:13.566Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326212552.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这题目看起来是真的有点迷，中级题目。</p><p>给一个从1到N的数组，对该数组进行重构，使之符合以下两条规则：</p><ol><li>第i个数能够被i整除</li><li>i能够被第i个整除</li></ol><p>我们需要返回能够符合以上两条规则之一或者同时满足的数组的个数。0 &lt; N &lt;= 15</p><p>怎么说好呢，一个数组升序都是满足的。</p><p>emmmm 完全没有思路啊，，我看来得去看看MOOC上浙大的数据结构和北大的算法课。。</p><p>貌似可以用回溯，，回溯在大一时简直就是噩梦，都没有听懂。。。。</p><p>看了大佬的回溯算法，简直有点迷，递归回溯算法。。我先贴个码吧，我先去刷了慕课了。。</p><p>应该是用了递归深度搜索方法，仔细看看真的好妙 啊。</p><p>我还是多看看课程吧，算法渣。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coutArrangement</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dfs(N, &amp;ans, <span class="number">1</span>); <span class="comment">// 第 1 个数开始搜索</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *ans, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt; n)&#123;</span><br><span class="line">            (*ans)++; <span class="comment">// 找到了一个符合的数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; (i % pos == <span class="number">0</span> || pos % i == <span class="number">0</span>))&#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>; <span class="comment">// 在深度搜索的时候，该位置无法被访问</span></span><br><span class="line">                dfs(n, ans, pos + <span class="number">1</span>);</span><br><span class="line">                visited[i] = <span class="number">0</span>; <span class="comment">// 深层的深度搜索结束了，该位置恢复访问。。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="Leetcode" scheme="https://joshuaqyh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode | Practice 5</title>
    <link href="https://joshuaqyh.github.io/2019/03/26/Leetcode-Practice-5/"/>
    <id>https://joshuaqyh.github.io/2019/03/26/Leetcode-Practice-5/</id>
    <published>2019-03-26T12:36:05.000Z</published>
    <updated>2019-05-16T14:04:13.541Z</updated>
    
    <content type="html"><![CDATA[<p>选一道easy的题来解解闷。。。</p><p>找出数组中的两个数之和等于target。。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326203656.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>思路：</p><ol><li>两重遍历。不过由于数组是升序的，在第一层遍历开始前，先判断一下当前元素和结尾元素之和能否大于等于目标值，如果不行则continue</li><li>给定收尾索引，判断对应位置之和和target的关系。如果相等，则返回，如果大于target，则尾索引变小，如果小于target，则头索引变大。</li></ol><p>思路一实现：</p><p>时间复杂度 O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int smallest = numbers[0];</span></span><br><span class="line">        <span class="keyword">int</span> biggest = numbers[numbers.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(biggest + numbers[i] &lt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i] + numbers[j] == target)&#123;</span><br><span class="line">                    result.push_back(i + <span class="number">1</span>);</span><br><span class="line">                    result.push_back(j + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result.size() == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> j = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                result.push_back(i + <span class="number">1</span>);</span><br><span class="line">                result.push_back(j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选一道easy的题来解解闷。。。&lt;/p&gt;
&lt;p&gt;找出数组中的两个数之和等于target。。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
              
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="Leetcode" scheme="https://joshuaqyh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode | Practice 4</title>
    <link href="https://joshuaqyh.github.io/2019/03/26/Leetcode-Practice-4/"/>
    <id>https://joshuaqyh.github.io/2019/03/26/Leetcode-Practice-4/</id>
    <published>2019-03-26T02:16:19.000Z</published>
    <updated>2019-05-16T14:04:13.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Find-K-Pairs-with-Smallest-Sums"><a href="#Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="Find K Pairs with Smallest Sums"></a>Find K Pairs with Smallest Sums</h1><p>给定两个升序整数数组<code>nums1</code> <code>nums2</code>以及一个整数<code>k</code>。</p><p>定义一个数对，一个元素来自<code>nums1</code> 一个来自<code>nums2</code>。</p><p>目的是返回k个数对，这些数对的内部元素之和升序存放。</p><p>例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>], k = <span class="number">3</span></span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]] </span><br><span class="line">Explanation: The first <span class="number">3</span> pairs are returned from the sequence: </span><br><span class="line">             [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>解题思路：</p><ol><li>初级思路：求出每一个对，然后再找出前K大的对，返回。<ol><li>缺点：时空复杂度都太高。求出每一个对时间复杂度为 $O(m^2)$，找出前K大的对时间复杂度为$O(mlogm)$ 。 </li></ol></li><li>中级思路：使用map容器进行选择。以数对之和为键, 数对数组为值（可能有，map会自动排序，然后输出前k个对。。这种做法结果证明时空占用都挺大的。。</li><li>看看大佬们的分享。使用优先队列来搞，比较快的样子。</li></ol><p>….  最简单的做法， 使用map键的自动排序特性。这个内部实现肯定比直接使用现有高效的排序方式来的慢。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; _map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter1 = nums1.begin(); iter1 != nums1.end(); iter1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter2 = nums2.begin(); iter2 != nums2.end(); iter2++) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = *iter1 + *iter2;</span><br><span class="line">_map[sum].push_back(make_pair(*iter1, *iter2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = _map.begin(); it != _map.end(); it++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> vec = it-&gt;second.begin(); vec != it-&gt;second.end(); vec++) &#123;</span><br><span class="line">res.push_back(*vec);</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span> (num == k)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == k)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Solution s;</span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">7</span>, <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">3</span>] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">nums1.push_back(arr1[i]);</span><br><span class="line">nums2.push_back(arr2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res = s.kSmallestPairs(nums1, nums2, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; res[i].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.empty() || nums2.empty() || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        result.reserve(k);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义排序方式</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p2) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[p1.first] + nums2[p1.second] &gt; nums1[p2.first] + nums2[p2.second];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个元素是pair对，第二个元素是pair数组，保证某些和相同的对在同一位置</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br><span class="line">        <span class="comment">//  ？？？先放数组一的第一个元素进优先队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); ++i) &#123;</span><br><span class="line">            q.push(make_pair(i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用优先队列来筛选目标</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 返回队首，由于优先特性，返回的是最小的对</span></span><br><span class="line">            <span class="keyword">auto</span> minPair = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (minPair.second + <span class="number">1</span> &lt; nums2.size()) &#123;</span><br><span class="line">                q.push(make_pair(minPair.first, minPair.second + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数组尾部替换为新筛选得到的最小对</span></span><br><span class="line">            result.emplace_back(nums1[minPair.first], nums2[minPair.second]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Find-K-Pairs-with-Smallest-Sums&quot;&gt;&lt;a href=&quot;#Find-K-Pairs-with-Smallest-Sums&quot; class=&quot;headerlink&quot; title=&quot;Find K Pairs with Smallest Sum
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="Leetcode" scheme="https://joshuaqyh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | StarGAN - paper summary</title>
    <link href="https://joshuaqyh.github.io/2019/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-StarGAN-paper-summary/"/>
    <id>https://joshuaqyh.github.io/2019/03/26/深度学习-StarGAN-paper-summary/</id>
    <published>2019-03-25T16:31:38.000Z</published>
    <updated>2019-05-16T14:14:19.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StarGAN-Unified-Generative-Adversarial-Networks-for-Multi-Domain-Image-to-Image-Translation"><a href="#StarGAN-Unified-Generative-Adversarial-Networks-for-Multi-Domain-Image-to-Image-Translation" class="headerlink" title="StarGAN: Unified Generative Adversarial Networks for Multi-Domain Image-to-Image Translation"></a>StarGAN: Unified Generative Adversarial Networks for Multi-Domain Image-to-Image Translation</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Although many GAN models show amazing performance in image-to-image translation tasks in recent studies, there are lots of limitations in scalability, robustness,efficiency and so on. Aimed at developing a more effective GAN model in image translation task, StarGAN is introduced to solve the problem that existing models are incapable of the implementation of multi-domain image translation among different datasets by using a single network. The StarGAN framework can learn mappings among multiple domains using a single generator and discriminator and behaves more effective than current similar models in the training phase. However, the other models cannot jointly train domains from various datasets, and if they want to learn all mappings within <em>k</em> domains, <em>k(k-1)</em> generators have to be trained, which is inefficient and ineffective.</p><p>The StarGAN model structure consists of two modules, including a generator and a discriminator. The working principle of StarGAN is to train a generator <em>G</em> that learns mappings among different domains and a discriminator <em>D</em> that distinguish between real and fake images and classify real images to its corresponding real domain. Basically, StarGAN adopts two generators <em>(G1, G2)</em> for generating near-true fake images to fool the discriminator, causing the discriminator to be unable to distinguish the authenticity of the images and classify the pictures as the target domain. The input of <em>G1</em>is an image and the target domain label, and then its output is a fake image. Furthermore, <em>G2</em> tries to take in as input both fake image from the output of <em>G1</em> and original domain under the depth-wise concatenation and reconstructs an image as the output that will be treated as the input image of <em>G1</em>.Therefore, a near-true fake image is generated after many generating cycles and inputs the discriminator for judgment.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003803.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Toachieve the goal to train a single generator <em>G</em> that learns mappings among multiple domains, <em>G</em> is trained to translate an input image x into an output image yconditioned on the randomly generated target domain label <em>c, G (x, c)</em> <em>→</em> <em>y.</em>Meanwhile, an auxiliary classifier is introduced to permit a singlediscriminator to control multiple domains. The discriminator will produceprobability distributions over both sources and domain labels. That is <em>D: x<strong>→</strong>{Dsrc(x), Dcls(x)}.Dsrc(x)</em> means the probability distributionover sources given by <em>D</em>. The authorsdefine an adversarial loss to measure how easily the generated image iscorrectly distinguished:</p><p><strong><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003614.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></strong></p><p>Basedon the generated and adversarial characteristics, the generator will try tominimize the above objective, while the discriminator will try to maximize it.The loss function of the aforementioned auxiliary classifier can divide intotwo situations to discuss which is to classify real images and fake images tothe target domain <em>c</em>, defined as:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003635.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Toguarantee that translated images preserve the content of its input images whilechanging only the domain-related part of the inputs, a cycle consistency lossapplies to the generator, represented as:</p><p><strong><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003652.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></strong></p><p>Insummary, the loss function of the full objective to optimize <em>D</em> and <em>G</em> is designed as follows:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003708.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Thehyperparameter <em>λcls</em>, <em>λrec</em> is used to control therelative importance of domain classification and reconstruction loss. Both <em>D</em> and <em>G</em> will try to minimize the above full objective during the trainingprocessing.</p><p>Animportant advantage and novel aspect of StarGAN is that it can utilize severaldatasets with different types of labels while all existing models only can betrained with a single dataset. To alleviate the problem that label informationis partially known to each dataset, the authors introduce a method named maskvector <em>m</em> to ignore unspecified labelsand focus on the explicitly known label provided by a particular dataset. Themask vector <em>m</em> is represented by ann-dimensional one-hot vector, where n stands for the number of datasets.Therefore, a unified version of the label is made as a vector c(~):</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003742.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Where <em>ci</em> represents the label of <em>ith</em> dataset. So it solves theproblem of the inconsistent labels on multiple datasets and inability to sharethe label and transfer the feature. When training StarGAN with multipledatasets, the domain label c(~) is applied and the model isto be trained in a multi-task learning setting, where the discriminator triesto minimize only the classification error associated to the known label.</p><p>Beforestarting to implement the model, we should understand the internal constructionof the generator and discriminator. The generator network structure of StarGANis modified and adapted from CycleGAN, composing of two convolutional layerswith the stride size of two for downsampling, six residual blocks, and twotransposed convolutional layers with the stride size of two for upsampling.Moreover, it applies the instance normalization method for the generator butnot for the discriminator. Adapted from PatchGANs, the discriminator isdesigned to classify whether the local image patches are real or fake.</p><p>The twodatasets CelebA and RaFD are used to train and test StarGAN, and try to makethe comparison between StarGAN and some baseline models like DIAT, cycleGAN,and IcGAN, finding the advantage and strength of StarGAN. The qualitativeresults on CelebA show a higher visual quality and preserve the facial identityfeature of an input. Moreover, quantitative result reflects that StarGANobtained the majority of votes for best transferring attributes in all cases.As for the result on RaFD, StarGAN is capable of generating the mostnatural-looking expressions and preserve the personal identity and facialfeatures of the input. Furthermore, the model gets the lowest classificationerror, meaning producing the most realistic facial expression. Also, theparameters required of the model is less than other models, enhancing thescalability of the model. When training model jointly on CelebA and RaFD, ithas confirmed that StarGAN can properly learn features in a dataset andtransfer them to another dataset by using a proper mask vector, achievingexcellent results on image-to-image cross-domain translation.</p><p>Due tothe limited number of test datasets used in the experiment, it is almost notpossible to verify whether the StarGAN model is universal or not. Anotherunfortunate fact is that some properties outside the target domain arefrequently modified. For instance, face attributes would be easily modifiedwhen executing the synthetic facial expression task. For further development ofthis model, we assume that the model will develop towards more accurate andfine-grained target domain generation, and meanwhile ensure the stability of non-targetdomain attributes. However, it also is worthy of recognition that this modelhas achieved relatively excellent improvement and progress on the efficiencyand quality of the image-to-image translation. In particular, the beginning oftraining models with multiple different datasets with various labels created.It is valuable work to enable more researchers to explore and develop excellentimage translation applications across multiple domains.</p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><p><a href="">[1]    </a><a href="https://arxiv.org/abs/1711.09020" target="_blank" rel="noopener">StarGAN: Unified Generative Adversarial Networks forMulti-Domain Image-to-Image Translation</a> <a href="https://github.com/yunjey" target="_blank" rel="noopener">Yunjey Choi</a> 1,2, <a href="https://github.com/mjc92" target="_blank" rel="noopener">Minje Choi</a> 1,2, <a href="https://www.facebook.com/munyoung.kim.1291" target="_blank" rel="noopener">MunyoungKim</a> 2,3, <a href="https://www.facebook.com/jungwoo.ha.921" target="_blank" rel="noopener">Jung-Woo Ha</a> 2, <a href="https://www.cse.ust.hk/~hunkim/" target="_blank" rel="noopener">Sung Kim</a> 2,4, and <a href="https://sites.google.com/site/jaegulchoo/" target="_blank" rel="noopener">JaegulChoo</a> 1,2 1 Korea University, 2 Clova AI Research (NAVER Corp.), 3 The College of NewJersey, 4 HKUST <em>IEEEConference on Computer Vision and Pattern Recognition (</em><a href="http://cvpr2018.thecvf.com/" target="_blank" rel="noopener"><em>CVPR</em></a><em>)</em>, 2018 (<strong>Oral</strong>)</p><p><a href="">[2]    The code of this paper is open in </a><a href="https://github.com/yunjey/stargan" target="_blank" rel="noopener">Github</a>.</p><p><a href="">[3]    Z. Liu, P. Luo, X. Wang,and X. Tang. Deep learning face attributes in the wild. In <em>Proceedings of the IEEE International Conference on Computer Vision(ICCV)</em>, 2015.</a></p><p><a href="">[4]    O. Langner, R. Dotsch, G.Bijlstra, D. H. Wigboldus, S. T. Hawk, and A. Van Knippenberg. Presentation andvalidation of the radboud faces database. <em>Cognitionand Emotion</em>, 24(8):1377–1388, 2010.</a></p><p><a href="">[5]    Facial Attribute Transferon CelebA</a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003857.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p><a href="">[6]    Facial ExpressionSynthesis on RaFD</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190326003931.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;StarGAN-Unified-Generative-Adversarial-Networks-for-Multi-Domain-Image-to-Image-Translation&quot;&gt;&lt;a href=&quot;#StarGAN-Unified-Generative-Ad
      
    
    </summary>
    
    
      <category term="Writing" scheme="https://joshuaqyh.github.io/tags/Writing/"/>
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机视觉" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="Paper" scheme="https://joshuaqyh.github.io/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 支持向量机学习笔记</title>
    <link href="https://joshuaqyh.github.io/2019/03/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://joshuaqyh.github.io/2019/03/25/机器学习-支持向量机学习笔记/</id>
    <published>2019-03-25T08:54:42.000Z</published>
    <updated>2019-03-27T13:09:52.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SVM原理"><a href="#SVM原理" class="headerlink" title="SVM原理"></a>SVM原理</h1><p>假设有两类样本，类别分别为 - 1， 1。空间中存在一个超平面能够划分这两类样本。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190325172141.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190325172206.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190325172307.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190325172327.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190325172555.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="求解SVM"><a href="#求解SVM" class="headerlink" title="求解SVM"></a>求解SVM</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190325174215.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190325174343.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327205056.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>梳理一下过程就是：</p><p>我们记初始的目标优化函数为 f(w)。 求 min f(w)。 </p><p>但是这个 min f(w) 真的不太好求，所以我们引入拉格朗日乘子 a，构造了一个拉格朗日函数 L(w, b, a)。</p><p>根据KKT条件可得，当 f(w) = max L(w, b, a);</p><p>所以有 min f(w) = min max L(w, b, a) </p><p>但因为是凸规划问题，不太好求 max L，所以我们把问题转化为  min f(w) = min max L(w, b, a) &gt;= max min L(w, b, a)。 </p><p>所以我们对 w b 求偏导，令其等于0，然后代入L(w, b, a) 得到 min L(w, b, a)：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327205430.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>记上述式子为 g (a) = min L(w, b, a)。</p><p>于是问题转化为 min f(x) = max g(a)。</p><p>所以我们求解 max g(a)，得到 a，然后代入超平面方程得到关于 a， b的模型方程。</p><p>至于 a 我们使用 SMO算法来求解。</p><p>而位移项，我们可以通过支持向量的平均值来计算。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327205832.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p>引入核函数的作用就是将一些低维空间的数据映射到高维空间，使之在高维空间中得以找到一个超平面进行划分，解决一些样本在低维空间的线性不可分的问题</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327210003.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327210133.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h1><p>软间隔的意思就是允许一些样本不满足到超平面的距离大于等于1的约束。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327210251.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327210321.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>引入了软间隔，我们需要重新修改优化的目标函数。</p><p>当然我们需要保证我们最大间隔的约束性质，同时允许一些样本不受约束。建模如公式6.29.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327210635.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>同样的求解思路是引入拉格朗日乘子，不过这次是引入了两个乘子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327210600.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190327210706.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>上述比较显得较为潦草，碍于个人时间有限，有些地方表达可能不太严谨，但已经大致的描述了SVM的相关概念和原理。</p><p>更为详细的博文请戳这里。<a href="https://blog.csdn.net/v_JULY_v/article/details/7624837" target="_blank" rel="noopener">支持向量机通俗导论（理解SVM的三层境界）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SVM原理&quot;&gt;&lt;a href=&quot;#SVM原理&quot; class=&quot;headerlink&quot; title=&quot;SVM原理&quot;&gt;&lt;/a&gt;SVM原理&lt;/h1&gt;&lt;p&gt;假设有两类样本，类别分别为 - 1， 1。空间中存在一个超平面能够划分这两类样本。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 系分作业二</title>
    <link href="https://joshuaqyh.github.io/2019/03/24/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E7%B3%BB%E5%88%86%E4%BD%9C%E4%B8%9A%E4%BA%8C/"/>
    <id>https://joshuaqyh.github.io/2019/03/24/软件工程-系分作业二/</id>
    <published>2019-03-24T12:17:58.000Z</published>
    <updated>2019-04-12T03:34:05.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>16340186   邱奕浩   电子政务方向</p></blockquote><h1 id="一、-简答题"><a href="#一、-简答题" class="headerlink" title="一、 简答题"></a>一、 简答题</h1><ol><li><strong>用简短的语言给出对分析，设计的理解。</strong></li></ol><ul><li><p><strong>分析</strong>强调的是对问题和需求和调查研究，而不是解决方案。其含义较为广泛，如市场分析，需求分析，面向对象分析等等。</p></li><li><p><strong>设计</strong>强调的是满足需求上的<strong>解决方案</strong>，但不涉及其实现，设计通常不会涉及较为底层细节的描述，更多是描述宏观的事物和策略。</p><p><strong>简单来说分析就是做正确的事，设计就是正确地去做事。</strong>（来自教材《UML和模式应用》P5）、</p><p>​</p></li></ul><ol start="2"><li><p><strong>用一句话描述面向对象分析与设计的优势。</strong></p><p>OOA／D的优势在于能够满足复杂软件功能的分析，设计与实现，同时又有有利于团队成员理解项目和产品的迭代更新。</p><p>​</p></li><li><p><strong>简述 <code>UML</code>（统一建模语言）的作用。考试考哪些图？</strong></p></li></ol><p>   UML是描述，构造和文档化系统制品的可视化语言，是图形化表示法的事实标准，主要用来绘制和展示       与软件（尤其是<code>OO</code>软件）相关的图形和文字，能够形象直观的表达面向对象软件设计中各个部分的逻辑和关联，帮助软件开发人员更好的理解项目设计。</p><p>   考试考的图有：用例图、静态图、行为图、实现图</p><ol start="4"><li><p><strong>从软件本质的角度，解释软件范围（需求）控制的可行性。</strong></p><p>软件的本质特性是复杂性，不可视性，不一致性，可变性。软件范围多数情况下对于客户和开发人员都是相对模糊的，软件的需求设计并不是一开始就能完全确定下来，在后续的开发、测试、运维阶段都会发生一定的变化，并进行不断地迭代更新，不断满足用户日新月异的需求点。</p><p>而根据著名的 <code>２／８</code> 法则，产品初期发展只需要 <code>２０％</code> 的有效核心需求就足以打开市场的大门，后续再进一步扩大软件范围，不断地跟进满足需求，不断完善用户服务和体验，依旧可以创造有价值的软件产品。</p><p>​</p></li></ol><h1 id="二、项目管理实践"><a href="#二、项目管理实践" class="headerlink" title="二、项目管理实践"></a>二、项目管理实践</h1><ol><li><p>看板使用练习（提交看板执行结果贴图，建议使用 <code>Git project</code>）</p><ul><li>使用截图工具（ <code>png</code> 格式输出），展现你团队的任务 <code>Kanban</code></li><li>每个人的任务是明确的。必须一周后可以看到具体结果</li><li>每个人的任务是1-2项</li><li>至少包含一个团队活动任务</li></ul><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190329231150.png" alt=""></p><p>​</p></li></ol><ol start="2"><li><code>UML</code> 绘图工具练习（提交贴图，必须使用 <code>UMLet</code>）<ul><li>请在 参考书2 或 教材 中选择一个类图（给出参考书页码图号）</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190324223826.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;16340186   邱奕浩   电子政务方向&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、-简答题&quot;&gt;&lt;a href=&quot;#一、-简答题&quot; class=&quot;headerlink&quot; title=&quot;一、 简答题&quot;&gt;&lt;/a&gt;一、 简答题&lt;/h1
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统分析与设计" scheme="https://joshuaqyh.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode | Practice 3</title>
    <link href="https://joshuaqyh.github.io/2019/03/18/leetcode-practice-3/"/>
    <id>https://joshuaqyh.github.io/2019/03/18/leetcode-practice-3/</id>
    <published>2019-03-17T17:46:35.000Z</published>
    <updated>2019-03-17T18:12:41.962Z</updated>
    
    <content type="html"><![CDATA[<p>本次题目来自<a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/submissions/" target="_blank" rel="noopener">链接</a></p><p>题目大意是：</p><p>给出一个数组，相当于一堆卡牌，每个元素相当于一张牌，每次从卡牌中抽出一张牌，离开牌堆后，下一张牌需要放在牌底。在这种规则下，我们需要确定牌的顺序，来保证这些牌的抽走顺序是升序的。</p><p>代码虽然不难，但是思路必须抓得清，我们很容易被把牌塞回牌底这一动作迷惑，其实我们可以把它看作是跳过这一张牌，将其留在原来的位置，然后抽取下一张牌。我们需要做的就是给升序后的数组的每一个元素确定其相应的索引位置。</p><p>整体思路是这样子的：</p><ol><li>我们定义一个同样大小的数组result，初始化为0，用于存放结果；</li><li>将待处理的数组进行升序处理得到deck（deck中的元素都是大于0的）；</li><li>设置一个全局的放置标志 put = true 和一个全局索引数 i = 0</li><li>遍历deck中的每一个元素，找出这一个元素在新数组中的位置：<ol><li>我们确保索引数是循环移动的</li><li>当找到一个位置 i的值为0 &amp; put = true的时候，就完成元素的放置</li><li>当 i 完成放置之后，下一个元素在下一个位置 i + 1就不能放置，所以 put = false，当索引 i = i+ 1时，就会跳过该位置，在这一回中 put = true，保证下一回合能够放置。</li><li>下一个元素必须在 i + 2个放置，在 i + 1的时候，需要令 put = true，完成放置，<strong>即重复2~3。</strong></li></ol></li></ol><p>emmmm 还是有点乱，看代码吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deckRevealedIncreasing(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; deck)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(deck.size(), <span class="number">0</span>);</span><br><span class="line">    sort(deck.begin(), deck.end());</span><br><span class="line">    <span class="keyword">bool</span> put = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">auto</span> val : deck:</span><br><span class="line">    <span class="keyword">for</span> (;;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == deck.size())</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(result[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(put == <span class="literal">true</span>)&#123;</span><br><span class="line">                result[i] = val;</span><br><span class="line">                put = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            put = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本次题目来自&lt;a href=&quot;https://leetcode.com/problems/reveal-cards-in-increasing-order/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="Leetcode" scheme="https://joshuaqyh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-训练中存在的问题和策略</title>
    <link href="https://joshuaqyh.github.io/2019/03/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E8%AE%AD%E7%BB%83%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://joshuaqyh.github.io/2019/03/14/深度学习-训练中存在的问题/</id>
    <published>2019-03-14T08:23:24.000Z</published>
    <updated>2019-03-14T11:56:01.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="梯度爆炸和消失"><a href="#梯度爆炸和消失" class="headerlink" title="梯度爆炸和消失"></a>梯度爆炸和消失</h1><p>在求解梯度时，通过链式法则可以使用多个中间梯度来表示初始梯度，在多层网络中，如果多个中间梯度都大于1，那么最后计算得到的梯度将远大于一，故存在梯度爆炸；</p><p>如果许多中间梯度都大于1，那么最后计算的到梯度将近乎0，故存在梯度消失。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314163412.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于梯度爆炸的存在，训练过程相当不稳定。我们需要保证，激活函数的导数或权重的绝对值小于等于1。</p><p>解决梯度爆炸的策略有：</p><ol><li>初始化权重值的绝对值小于1</li><li>在训练前对权重进行标准化</li><li>对输入进行归一化</li></ol><p>梯度消失将会使训练相当慢，我们必须使激活函数倒数*权重的绝对值不要太小，解决的策略有：</p><ol><li>选择ReLU激活函数</li><li>权重初始化，$w - N(0, \sigma^2)$</li><li>权重在训练前重新标准化</li></ol><p>简单来说，在开始训练之前，网络权重初始化的策略是，从由输出维数n和m决定的正态分布或者均匀分布中采样，会加快网络的训练过程。</p><ul><li>当激活函数是tanh时（Weight initialization: Xavier’s method）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314171856.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>当激活函数是ReLU时（Kaiming He 大神）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\Qiuyh\AppData\Local\Temp\1552555155244.png" alt="55255515524" title="">                </div>                <div class="image-caption">55255515524</div>            </figure><h1 id="Mini-batch-的问题"><a href="#Mini-batch-的问题" class="headerlink" title="Mini-batch 的问题"></a>Mini-batch 的问题</h1><p>问题：每一批的数据分布不一致。</p><p>解决方法：批量归一化BN。将每一组数据都归一化为标准正态分布。（均值为0，方差为1）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314170344.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>BN 通常放在激活函数ReLU之前。</p><p>在合理的学习率范围内，学习率越大，BN越有效。上述的$\gamma $$,\beta$ 作为模型的参数，一并学习。 </p><h1 id="过拟合的问题"><a href="#过拟合的问题" class="headerlink" title="过拟合的问题"></a>过拟合的问题</h1><p>过拟合是普遍存在的，我们有以下几种策略来解决：</p><ol><li><p>借助验证集来确定提前终止迭代的次数</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314175216.png" alt=""></p><p>​</p></li><li><p>正则化：$L_P$Norm</p><p><img src="C:\Users\Qiuyh\Desktop\大三下\软件测试\平时作业\20190314174445.png" alt=""></p></li><li><p>dropout</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314174934.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314175004.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="4"><li><p>数据增广（增强）</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314175518.png" alt=""></p></li><li><p>集成模型</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314175638.png" alt=""></p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190314175803.png" alt=""></p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;梯度爆炸和消失&quot;&gt;&lt;a href=&quot;#梯度爆炸和消失&quot; class=&quot;headerlink&quot; title=&quot;梯度爆炸和消失&quot;&gt;&lt;/a&gt;梯度爆炸和消失&lt;/h1&gt;&lt;p&gt;在求解梯度时，通过链式法则可以使用多个中间梯度来表示初始梯度，在多层网络中，如果多个中间梯度都大于1
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode | Practice 2</title>
    <link href="https://joshuaqyh.github.io/2019/03/14/Leetcode-Practice-2/"/>
    <id>https://joshuaqyh.github.io/2019/03/14/Leetcode-Practice-2/</id>
    <published>2019-03-14T08:01:08.000Z</published>
    <updated>2019-03-14T15:07:10.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Author: qyh</p><p>Date: 2019-03-14</p><p>Description: Buid BT Stree from preorder tree</p><p>URL:<a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Definition for a binary tree node.*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">求解思路：</span></span><br><span class="line"><span class="comment">其实很简单，就是简单的二叉搜索树的插入，然后输出根节点就行了，没有那么复杂。。。</span></span><br><span class="line"><span class="comment">***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (preorder.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.size(); i++)&#123;</span><br><span class="line">insert(root, preorder[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* &amp;root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">root-&gt;left = insert(root-&gt;left, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">root-&gt;right = insert(root-&gt;right, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">Q.push(root);</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">TreeNode* tmp = Q.front();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tmp-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">Q.push(tmp-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">Q.push(tmp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">6</span>] = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">test.push_back(val[i]);</span><br><span class="line">&#125;</span><br><span class="line">Solution sol;</span><br><span class="line">TreeNode* root = sol.bstFromPreorder(test);</span><br><span class="line">levelOrder(root);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Author: qyh&lt;/p&gt;
&lt;p&gt;Date: 2019-03-14&lt;/p&gt;
&lt;p&gt;Description: Buid BT Stree from preorder tree&lt;/p&gt;
&lt;p&gt;URL:&lt;a href=&quot;https://leetcod
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="Leetcode" scheme="https://joshuaqyh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>软件质量标准</title>
    <link href="https://joshuaqyh.github.io/2019/03/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%A0%87%E5%87%86/"/>
    <id>https://joshuaqyh.github.io/2019/03/08/软件工程-软件质量标准/</id>
    <published>2019-03-08T06:29:42.000Z</published>
    <updated>2019-05-16T14:05:29.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件质量问题"><a href="#软件质量问题" class="headerlink" title="软件质量问题"></a>软件质量问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>软件质量问题是软件工程开发的关键问题，也是软件工程生产的核心问题。</p><p>软件质量问题是导致软件项目进度延误，预算超支或项目失败，项目终止等软件危机的根本原因。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>提高软件质量可以降低项目开发的总成本：</p><ul><li>降低维护成本并延长软件的生命期，降低软件失效导致的成本损失。</li></ul><p>我们需要通过减少并及早检测纠正实际的软件开发过程和软件开发结果于预期不符的情况，降低错误成本。</p><h1 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>现代质量管理中，质量代表着用户的满意程度。</p><p>ANSI/IEEE std729-1983： 软件质量是与软件产品满足规定和隐含的需求能力有关的特征和特性的全体。</p><p>ISO/IEC 9001-1999：软件质量是产品满足需求的能力。</p><h2 id="软件质量的不同观点"><a href="#软件质量的不同观点" class="headerlink" title="软件质量的不同观点"></a>软件质量的不同观点</h2><ul><li>先验论观点：质量是产品一种可以认识但不可定义的性质</li><li>用户观点：质量是产品满足使用目的的衡量指标</li><li>制造者观点：质量是产品性能和规格符合要求的符合度</li><li>产品观点：质量是联结产品固有性能的纽带</li><li>价值观点：质量依赖于顾客愿意付给产品报酬的数量</li></ul><h2 id="软件质量范畴-（3A）"><a href="#软件质量范畴-（3A）" class="headerlink" title="软件质量范畴 （3A）"></a>软件质量范畴 （3A）</h2><ul><li>可说明性: 用户可以给予产品的描述和定义来使用产品</li><li>有效性：产品对大多数用户是有效的</li><li>易用性/可用性：产品容易使用，并且具备有用的功能</li></ul><h2 id="高质量软件标准体系"><a href="#高质量软件标准体系" class="headerlink" title="高质量软件标准体系"></a>高质量软件标准体系</h2><h3 id="产品质量"><a href="#产品质量" class="headerlink" title="产品质量"></a>产品质量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190308145353.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="过程质量控制"><a href="#过程质量控制" class="headerlink" title="过程质量控制"></a>过程质量控制</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190308145747.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件产品质量标准"><a href="#软件产品质量标准" class="headerlink" title="软件产品质量标准"></a>软件产品质量标准</h2><ol><li>功能性：软件所实现的功能达到它的设计规范和满足用户需求的程度</li><li>可用性：对于一个软件，用户学习，操作，准备输入和理解输出所付出的努力程度</li><li>可靠性：在规定的时间和条件下，软件所能达到保持其正常功能操作，性能水平的程度</li><li>性能：在指定的条件下，用软件实现某种功能所需的计算机资源的有效程度。</li><li>能力/容量：系统的接受力，容纳或吸收的能力，或某项功能的最大量或最大限度</li><li>可测量性：系统某些特性可以通过一些量化的数据指标描述当前状态或理想状态</li><li>可维护性：对于一个运行阶段的软件，当环境改变或软件发生错误时，进行相应修改所需要付出的努力程度</li><li>兼容性：不同版本之间的软件功能存在普适兼容</li><li>可扩展性：在软件功能进行迭代时，优良的可扩展性可减少无谓的工作劳动，减少对已有系统的改动，从而提高效率。</li></ol><h2 id="软件的质量特性的定义"><a href="#软件的质量特性的定义" class="headerlink" title="软件的质量特性的定义"></a>软件的质量特性的定义</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190308152321.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190308152358.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件质量层次模型"><a href="#软件质量层次模型" class="headerlink" title="软件质量层次模型"></a>软件质量层次模型</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190308152847.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件质量问题&quot;&gt;&lt;a href=&quot;#软件质量问题&quot; class=&quot;headerlink&quot; title=&quot;软件质量问题&quot;&gt;&lt;/a&gt;软件质量问题&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件测试" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习模型中的优化策略</title>
    <link href="https://joshuaqyh.github.io/2019/03/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>https://joshuaqyh.github.io/2019/03/08/深度学习-模型优化策略/</id>
    <published>2019-03-07T16:15:32.000Z</published>
    <updated>2019-03-07T18:35:14.513Z</updated>
    
    <content type="html"><![CDATA[<p>   在深度学习中，我们通常需要优化我们所定义的损失函数，优化的方法思想就是通过梯度下降的方式不断逼近一个局部最优解，更新模型参数然后来保证损失函数预测误差最小。在本文主要综述了几种常见的优化策略，包括梯度下降的策略以及学习率变化的策略。这些策略有一些基本的概念需要重点掌握，这些策略有简单有复杂， 但是依照“没有免费午餐“的定理，在具体情景中，要具体运用比较，没有绝对的最优策略，只有相对的最优策略。</p><p>虽然在实践中我们可以直接调用深度学习框架的API来完成优化，但是要更加深入地理解其原理和过程才是一个优秀的深度学习工程师啊，面试肯定会涉及一些原理概念解释滴。下面就开始总结啦！</p><h1 id="批量梯度下降法-Batch-gradient-descent"><a href="#批量梯度下降法-Batch-gradient-descent" class="headerlink" title="批量梯度下降法 Batch gradient descent"></a>批量梯度下降法 Batch gradient descent</h1><p>批量梯度下降法（也叫确定性梯度算法）指的是在<strong>一个大批量的数据样本中同时处理所有样本</strong>，在更新参数的时候，会同时利用所有样本的梯度变化。公式表达如下：</p><p>$$\theta_{t+1} = \theta_{t} - \eta \bigtriangledown L(\theta_t)  = \theta_t - \frac{\eta}{N} \sum_{n=1}^{N}\bigtriangledown l(y_n, f(x_n; \theta_t))$$  </p><p>从公式上可以看到模型参数$\theta$开始更新的时候，是当计算得到所有样本$x_n$输出预测结果$f(x_n; \theta_t)$后得到损失函数梯度值时，进行模型参数的更新。</p><p>可以看到这整个过程的缺点就是训练慢，处理棘手，而且内存消耗大，但是可以保证找到一个最小的损失函数值。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for iter in range(nb_epoches):</span><br><span class="line">params_grad = eval_grad(loss_func, dataset, params)</span><br><span class="line">params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><h1 id="随机梯度下降法-Stochastic-gradient-descent"><a href="#随机梯度下降法-Stochastic-gradient-descent" class="headerlink" title="随机梯度下降法 Stochastic gradient descent"></a>随机梯度下降法 Stochastic gradient descent</h1><p>随机梯度下降法简称SGD，与批量梯度下降法相比，随机梯度下降法是在每训练一个样本的时候就进行的函数模型的更新，在每次的训练迭代中，会先随机打乱训练集，然后每抽取一个样本进行训练时，就进行更新。</p><p>公式表达如下：</p><p>$\theta_{t+1} = \theta_t - \eta \bigtriangledown L(\theta_t) = \theta_t - \eta \bigtriangledown l(y_n , f(x_n; \theta_t))$</p><p>显而易见，在处理大数据样本的时候，模型更新速度很快，但是存在收敛震荡的情况，可能会跳出局部最优解，但是也很接近局部最优解。从计算设备的角度来考虑，随机梯度下降无法做到很好的并行计算，没有很好地利用多核架构，每一次更新都得依赖前一个样本的计算。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for iter in range(epoches):</span><br><span class="line">np.random.shuffle(dataset)</span><br><span class="line">for example in dataset:</span><br><span class="line">param_grad = eval_grad(loss_func, example, params)</span><br><span class="line">params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><h1 id="小批量梯度下降-Mini-batch-gradient-descent"><a href="#小批量梯度下降-Mini-batch-gradient-descent" class="headerlink" title="小批量梯度下降 Mini-batch gradient descent"></a>小批量梯度下降 Mini-batch gradient descent</h1><p>小批量梯度下降法，其实就是介于批量下降法和随机梯度下降法之间的优化方法，关键在于每次更新模型参数时，训练样本的大小。我们知道大批量的运算将会使我们的计算设备和内存不堪重负，而随机梯度下降法的中的单样本更新则无法充分使用我们的多核计算架构。我们想要达到的目的就是：<strong>既能有效的保证计算设备的良好充分使用，又能保证较短的训练时间和较好的性能</strong> 。而小批量梯度下降法就是我们比较常用的一种优化方法。</p><p>小批量的大小通常使用以下几个因素决定的：</p><ul><li>更大的批量将计算得到更为精确的梯度估计，但是回报却是小于线性的。</li><li>极小批量将无法充分利用多核架构，这促使我们给批量设定一个最小阈值。</li><li>如果批量处理中所有样本可以并行地处理，那么内存消耗和批量大小将会呈正比，所有批量有一个上限。</li></ul><p>小批量随机梯度下降法用数学公式表达如下：</p><p>$$\theta_{t+1} = \theta_{t} - \eta\bigtriangledown L(\theta_t) = \theta_t - \frac{\eta}{S} \sum_{(x_n, y_n) ∈S} \bigtriangledown l(y_n, f(x_n; \theta_t))$$</p><p>S 代表批量的大小，通常为10~300之间。</p><p>整个过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in range(nb_epochs):</span><br><span class="line">np.random.shuffle(dataset)</span><br><span class="line">for batch in get_batches(dataset, batch_size = 64):</span><br><span class="line">params_grad = eval_grad(loss_func, batch, params)</span><br><span class="line">params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><p>对于小批量梯度下降法来说，用小批量可以比较好的近似真实梯度，但是对学习率的自适应调整有了一定的要求。</p><h1 id="动量-Momentum"><a href="#动量-Momentum" class="headerlink" title="动量 Momentum"></a>动量 Momentum</h1><p>虽然SGD仍然是非常接收欢迎的优化方法，但是其学习过程有时是相当的漫长，动量方法就是为了加速学习，特别是在处理高曲率，小但一致的梯度，或者带噪声的梯度。动量算法简单来说就是在原来SGD的基础上，利用了之前所有梯度指数级衰减的移动平均，并且沿该方向继续移动。</p><p>在描述该方法的时候，引入了变量 v 来充当速度的角色，它代表参数在参数空间移动的方向和速率。数学描述如下：</p><p>$v_{t+1} = \gamma v_t + \eta\bigtriangledown L(\theta_t)$</p><p>$\theta_{t+1} = \theta_t - v_{t+1}$</p><p>该迭代式可以看出：</p><p>$v_{t+1} = \eta { \bigtriangledown L(\theta_t) + \eta L(\theta_{t-1}) + \eta^2 \bigtriangledown L(\theta_{t-2}）+ … }$</p><p>这种方法有效的利用了前面所有的梯度信息，可以有效的减少SGD，mini-batch的震荡，但是这种算法有时会导致跳出最优解，而且随着计算次数的增加，有些梯度信息已经几乎可以忽略不记了。</p><h1 id="自适应梯度下降法-Adagrad"><a href="#自适应梯度下降法-Adagrad" class="headerlink" title="自适应梯度下降法 Adagrad"></a>自适应梯度下降法 Adagrad</h1><p>自适应可以理解为学习率的自适应变化，在基础的下降法种的学习率$\eta$ 是一个常数，在自适应法中，学习率需要除以之前所有导数的平方和的平方根。</p><p>表达式如下：</p><p>$g_{t+1, i} = g_{t, i} + (\frac{\partial L(\theta_t)}{\partial \theta_i})^2$</p><p>$\theta_{t+1, i} = \theta_{t, i} - \frac{\eta}{\sqrt{g_{t+1, i}} + \epsilon} \frac{\partial L(\theta_t)}{\partial  \theta_i}$</p><p>该方法实现了学习率的自动调整，当迭代次数增加的时候，学习率将会变得极小。</p><h1 id="RMSprop-root-mean-square-propagation"><a href="#RMSprop-root-mean-square-propagation" class="headerlink" title="RMSprop (root mean square propagation)"></a>RMSprop (root mean square propagation)</h1><p>为了解决Adagrad学习率单调递减的原因，我们对于每一个时刻的导数计算，引入了$\gamma $来避免学习率极低的情况，是简单利用线性加权的方式来描述这一方法的：</p><p>$g_{t+1, i} = \gamma g_{t, i} + (1 - \gamma)(\frac{\partial L(\theta_t)}{\partial \theta_i}) ^2$</p><p>$\theta_{t+1, i} = \theta_{t, i} - \frac{\eta}{\sqrt{g_{t+1, i} + \epsilon}} \frac{\partial L(\theta_t)}{\partial \theta_i}$</p><p>一般$gamma$可以取0.9。</p><h1 id="Adam-Adaptive-moment-estimation"><a href="#Adam-Adaptive-moment-estimation" class="headerlink" title="Adam (Adaptive moment estimation)"></a>Adam (Adaptive moment estimation)</h1><p>Adam 简单来说就是在RMSProp的基础之上，添加了momentum和bias的方法，过程如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190308021211.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190308022822.png" alt=""></p><p>从上文可以看到，Adam其实是对学习率和要更新的梯度值进行了修改，学习率近似于RMSProp的方法，而梯度的修改则是参照了Momentum方法，当前的梯度信息需要依赖以往所有梯度信息的线性加权求和，权重随着迭代次数增加而减少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   在深度学习中，我们通常需要优化我们所定义的损失函数，优化的方法思想就是通过梯度下降的方式不断逼近一个局部最优解，更新模型参数然后来保证损失函数预测误差最小。在本文主要综述了几种常见的优化策略，包括梯度下降的策略以及学习率变化的策略。这些策略有一些基本的概念需要重点掌握
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | PageRank 算法和简单应用</title>
    <link href="https://joshuaqyh.github.io/2019/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-PageRank-%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>https://joshuaqyh.github.io/2019/03/05/机器学习-PageRank-算法和简单应用/</id>
    <published>2019-03-05T08:20:08.000Z</published>
    <updated>2019-03-05T10:25:28.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PageRank-算法原理"><a href="#PageRank-算法原理" class="headerlink" title="PageRank 算法原理"></a>PageRank 算法原理</h1><p>PageRank 算法是一种简单有效且流行的网页排序算法，它通过一个网页的所有入链数目来计算该网页的重要性（PageRank 值，简称 PR），其思想类似于一篇论文被引用的次数越大，该论文的影响力越大。</p><p>以下给出一个简单的例子，一个个网页就是互联网中的一个个节点，这些网页之间相互引用，构成一个有向图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/81/36/814d53ff8d73113631482e71b7c53636.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里有着和算法相关的两个概念。</p><ul><li>出链：网页链接出去的链接，相当于离散数学的图论中的出度概念；</li><li>入链：链接进来的链接，相当于入度。</li></ul><p>简单来说，一个网页的影响力（PR值） = 该网页所有入链集合的加权影响力之和，用公式表示为：</p><p>$$RP(u) = \sum_{v ∈ B_u} \frac{PR(v)}{L(v)}$$</p><p>其中，u 为待评估的节点网页，$B_u$ 为所有入链到节点u的网页集合，$PR_(v)$ 为入链到u的网页影响力值，而 $L(v)$ 则是网页 v 的出链数目。 以上述图像为例子，已知一个网页出链的数目，可以计算一个网页跳转到另外一个网页的概率，由此 A，B，C，D四个网页的转移矩阵 M</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/20/d4/204b0934f166d6945a90185aa2c95dd4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假设这四个网页的初始影响力（权重） w 都是一致的，给出如下向量 w0，代表A，B，C，D初始影响力。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/a8/b8/a8eb12b5242e082b5d2281300c326bb8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>经过第一次转移之后，各页面计算结果如下 w1, (矩阵乘法的过程，其实就是PR公式计算了)。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/fc/8c/fcbcdd8e96384f855b4f7c842627ff8c.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由此不断产生迭代，直到第 n 次迭代之后，wn 的影响力不再发生变化，收敛的最终结果就是各网页的最终PR值。</p><p>存在两种特殊情况：</p><p>１.　等级泄露：一个网站如果没有出链，只有入链，那么吸收了其他页面的影响力，但却不释放，最终会导致其他页面的PR值为０；</p><p>２.　等级沉没，如果一个网站只有出链，没有入链，多次迭代，这个网站的影响力PR将会变为０。</p><p>为了解决这两个问题，ＰａｇｅＲａｎｋ有了一个优化模型，称为随机浏览模型。</p><p><strong>随机浏览模型</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/5f/8f/5f40c980c2f728f12159058ea19a4d8f.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在原来模型的基础上，引入了一个阻尼因子ｄ，这个因子代表用户按照跳转链接来上网的概率，通常取一个固定值，而 1 - d 则代表了用户不是通过跳转链接来访问的网页，比如直接输入网址。其中 N代表比较网页的总数。</p><h1 id="PageRank-算法实践"><a href="#PageRank-算法实践" class="headerlink" title="PageRank  算法实践"></a>PageRank  算法实践</h1><p>首先我们需要了解如何使用 PageRank 算法以及如何用python快速构建一个图。</p><p>这里直接使用工具包，networkx，里面内置了PageRank 计算函数和建图的函数，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"><span class="comment"># creat directed graph</span></span><br><span class="line">G = nx.DiGraph()</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the edge relationship</span></span><br><span class="line">edges = [(<span class="string">"a"</span>, <span class="string">"b"</span>), (<span class="string">"a"</span>, <span class="string">"c"</span>), (<span class="string">"a"</span>, <span class="string">"d"</span>), (<span class="string">"b"</span>, <span class="string">"a"</span>), (<span class="string">"b"</span>, <span class="string">"d"</span>), (<span class="string">"c"</span>, <span class="string">"a"</span>), (<span class="string">"d"</span>, <span class="string">"b"</span>), (<span class="string">"d"</span>, <span class="string">"b"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># add edge</span></span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">    G.add_edge(edge[<span class="number">0</span>], edge[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate pr value with the pagerank</span></span><br><span class="line">pagerank_list = nx.pagerank(G, alpha = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> (pagerank_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># node operations</span></span><br><span class="line">G.add_node(<span class="string">'c'</span>)</span><br><span class="line">G.add_nodes_from([<span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">G.remove_node(<span class="string">'d'</span>)</span><br><span class="line">G.remove_nodes_from([<span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">print(G.nodes())</span><br><span class="line">print(G.number_of_nodes())</span><br><span class="line"></span><br><span class="line"><span class="comment"># edge operations</span></span><br><span class="line">G.add_edge(<span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line">print(G.edges())</span><br><span class="line">G.remove_edge(<span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line">print(G.edges())</span><br><span class="line">print(G.number_of_edges())</span><br></pre></td></tr></table></figure><p>实战项目来自 <a href="https://github.com/cystanford/PageRank/tree/master/input" target="_blank" rel="noopener">Github</a>, 主要是分析 希拉里邮件发送接收的关系网，由此来发现与希拉里关系密切的人。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">emails = pd.read_csv(<span class="string">"./data/Emails.csv"</span>)</span><br><span class="line"></span><br><span class="line">file = pd.read_csv(<span class="string">"./data/Aliases.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># key: alias  value: personId</span></span><br><span class="line">aliases = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> file.iterrows():</span><br><span class="line">    aliases[row[<span class="string">'Alias'</span>]] = row[<span class="string">'PersonId'</span>]</span><br><span class="line">    </span><br><span class="line">file = pd.read_csv(<span class="string">"./data/Persons.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># key: id  value: name</span></span><br><span class="line">persons = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> file.iterrows():</span><br><span class="line">    persons[row[<span class="string">'Id'</span>]] = row[<span class="string">'Name'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform the alias name to the same</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unify_name</span><span class="params">(name)</span>:</span></span><br><span class="line">    name = str(name).lower()</span><br><span class="line">    name = name.replace(<span class="string">','</span>,<span class="string">''</span>).split(<span class="string">"@"</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> aliases.keys():</span><br><span class="line">        <span class="keyword">return</span> persons[aliases[name]]</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_graph</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="comment"># graph is a direct graph object</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set spring_layout</span></span><br><span class="line">    positions = nx.spring_layout(graph)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set the size of the nodes. The PR value is higher, the node is larger.</span></span><br><span class="line">    nodesize = [x[<span class="string">'pagerank'</span>]*<span class="number">20000</span> <span class="keyword">for</span> v, x <span class="keyword">in</span> graph.nodes(data=<span class="keyword">True</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set the length of the edges</span></span><br><span class="line">    edgesize = [np.sqrt(e[<span class="number">2</span>][<span class="string">'weight'</span>]) <span class="keyword">for</span> e <span class="keyword">in</span> graph.edges(data = <span class="keyword">True</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># draw nodes</span></span><br><span class="line">    nx.draw_networkx_nodes(graph, positions, node_size = nodesize, alpha = <span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># draw edges</span></span><br><span class="line">    nx.draw_networkx_edges(graph, positions, edge_size = edgesize, alpha = <span class="number">0.6</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># draw nodes' label</span></span><br><span class="line">    nx.draw_networkx_labels(graph, positions, font_size = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># normalize the from and to value.</span></span><br><span class="line"><span class="comment"># the metadataFrom and metadatato is the columns's name</span></span><br><span class="line">emails.MetadataFrom = emails.MetadataFrom.apply(unify_name)</span><br><span class="line">emails.MetadataTo = emails.MetadataTo.apply(unify_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the weight is equal the sending times</span></span><br><span class="line"><span class="comment"># &#123;  (from, to): num &#125;</span></span><br><span class="line">edges_weights_temp = defaultdict(list)  <span class="comment"># the key can be a tuple</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> zip(emails.MetadataFrom, emails.MetadataTo, emails.RawText):</span><br><span class="line">    temp = (row[<span class="number">0</span>], row[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> edges_weights_temp:</span><br><span class="line">        edges_weights_temp[temp] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        edges_weights_temp[temp] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># transfer the format (from, to):value  -&gt; from, to, value</span></span><br><span class="line">edge_weights = [(key[<span class="number">0</span>], key[<span class="number">1</span>], val) <span class="keyword">for</span> key, val <span class="keyword">in</span> edges_weights_temp.items()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the direct graph</span></span><br><span class="line">graph = nx.DiGraph()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add weight </span></span><br><span class="line">graph.add_weighted_edges_from(edge_weights)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate the pr value of every node</span></span><br><span class="line">pagerank = nx.pagerank(graph)  <span class="comment"># return a dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get the pr of per value</span></span><br><span class="line">pagerank_list = &#123;node: rank <span class="keyword">for</span> node, rank <span class="keyword">in</span> pagerank.items()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the pr value as the attribute of the node</span></span><br><span class="line">nx.set_node_attributes(graph, name = <span class="string">'pagerank'</span>, values=pagerank_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># draw graph</span></span><br><span class="line">draw_graph(graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># simplify the graph</span></span><br><span class="line">pagerank_threshold = <span class="number">0.02</span></span><br><span class="line"><span class="comment"># copy a graph</span></span><br><span class="line">small_graph = graph.copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n, p_rank <span class="keyword">in</span> graph.nodes(data = <span class="keyword">True</span>):</span><br><span class="line">    <span class="keyword">if</span> p_rank[<span class="string">'pagerank'</span>] &lt; pagerank_threshold:</span><br><span class="line">        small_graph.remove_node(n)</span><br><span class="line">draw_graph(small_graph)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190305182416.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PageRank-算法原理&quot;&gt;&lt;a href=&quot;#PageRank-算法原理&quot; class=&quot;headerlink&quot; title=&quot;PageRank 算法原理&quot;&gt;&lt;/a&gt;PageRank 算法原理&lt;/h1&gt;&lt;p&gt;PageRank 算法是一种简单有效且流行的网页排序
      
    
    </summary>
    
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 阐释原型方法对软件生命周期各阶段的支持</title>
    <link href="https://joshuaqyh.github.io/2019/03/03/%E9%98%90%E9%87%8A%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%84%E9%98%B6%E6%AE%B5%E7%9A%84%E6%94%AF%E6%8C%81/"/>
    <id>https://joshuaqyh.github.io/2019/03/03/阐释原型方法对软件生命周期各阶段的支持/</id>
    <published>2019-03-02T19:01:15.000Z</published>
    <updated>2019-03-27T13:49:40.700Z</updated>
    
    <content type="html"><![CDATA[<p>要正确理解原型方法对软件生命周期不同阶段的支持，分别给出：</p><ol><li>辅助或代替分析阶段；</li><li>辅助设计阶段；</li><li>代替分析与设计阶段；</li><li>代替分析、设计和实现阶段；</li><li>代替全部开发阶段；这五种情形所对应的开发活动执行时间顺序。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190303012019.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以下对这五种情形所对应的开发活动执行时间顺序展开阐述。</p><h3 id="1-辅助或代替分析阶段"><a href="#1-辅助或代替分析阶段" class="headerlink" title="1. 辅助或代替分析阶段"></a>1. 辅助或代替分析阶段</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190303012226.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从上图可知，在分析和需求说明阶段应用原型方法，其开发活动的执行顺序如下：</p><ol><li>定义软件的初步需求</li><li><strong>原型方法辅助或代替分析阶段</strong>：<ol><li>快速分析软件初步需求</li><li>快速构造软件需求说明书</li><li>用户理解软件需求书</li><li>用户对软件需求书进行评价反馈</li><li>根据反馈，决定是否需要修改需求分析结果，进行新一轮的原型方法还是跳出当前分析阶段，进入下一阶段。</li><li>不断循环应用原型方法，直到得出<strong>明确的需求说明文档</strong>，然后进入下一阶段。</li></ol></li><li>根据需求说明书，开始进行软件的概要设计和详细设计，输出设计说明文档</li><li>根据设计说明文档，进行编码实现，输出初步的程序系统</li><li>对程序系统进行编码测试，得到软件产品</li><li>运行软件产品，并持续维护。</li></ol><h3 id="2-辅助设计阶段"><a href="#2-辅助设计阶段" class="headerlink" title="2. 辅助设计阶段"></a>2. 辅助设计阶段</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190303014140.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由上图可知，在设计阶段应用原型方法，其对应的开发活动顺序如下：</p><ol><li>确定初步的软件需求</li><li>对需求进行详细分析，并输出明确的需求说明文档</li><li><strong>原型方法辅助设计阶段</strong>：<ol><li>结合需求说明文档，快速分析需求</li><li>快速构造软件系统的架构，以及不同的功能实现算法</li><li>工程师对现有提出的系统架构进行评价和反馈</li><li>结合评价反馈判断是否需要修改系统架构和设计，以及功能实现算法</li><li>不断循环应用原型方法，直到<strong>得到一个合适的系统架构和性能较好的功能实现算法</strong>，输出最终的软件架构设计说明文档，进入下一阶段</li></ol></li><li>编码实现阶段，充分理解软件架构设计文档，并开始实现，并输出符合设计的程序系统</li><li>对上一阶段的程序系统进行编码测试，输出良好的，无缺陷的软件产品</li><li>运行软件产品，持续维护</li></ol><h3 id="3-代替分析与设计阶段"><a href="#3-代替分析与设计阶段" class="headerlink" title="3. 代替分析与设计阶段"></a>3. 代替分析与设计阶段</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190303015132.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>原型方法代替分析与设计阶段，其开发执行顺序如下：</p><ol><li>定义软件初步需求</li><li><strong>原型方法代替分析与设计阶段</strong>：<ol><li>快速分析软件需求</li><li>快速构造设计说明文档</li><li>工程师，架构师对比使用需求和软件设计说明</li><li>对需求和设计提出评价和反馈</li><li>根据反馈决定是否修改需求文档和软件设计文档，循环应用原型方法</li><li>不断循环，<strong>直到得到完善的需求说明文档和架构设计说明文档</strong></li></ol></li><li>根据设计文档，开始编码实现功能，并输出初步的符合设计的程序系统</li><li>对初步的程序系统进行编码测试，得到符合设计和需求的软件产品</li><li>持续运行和维护上线的软件产品</li></ol><h3 id="4-代替分析、设计和实现阶段"><a href="#4-代替分析、设计和实现阶段" class="headerlink" title="4. 代替分析、设计和实现阶段"></a>4. 代替分析、设计和实现阶段</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190303020254.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从分析到输出程序系统，应用原型方法来代替分析、设计和实现阶段，各开发活动对应的时间实行顺序为：</p><ol><li>定义软件初步需求</li><li><strong>应用原型方法，代替分析、设计和实现阶段</strong>：<ol><li>快速分析软件需求</li><li>快速构造软件设计说明文档</li><li>快速编码，构造软件程序系统</li><li>用户使用软件程序系统，提出评价和反馈</li><li>根据反馈决定是否修改需求，变更软件设计文档，修正软件产品，继续应用原型方法</li><li>继续应用原型方法，<strong>直到得到明确的需求说明文档，详细的软件设计文档，和功能较为完备的程序系统</strong>，然后进入下一阶段</li></ol></li><li>对上一阶段的程序系统进行编码测试，集成测试，验证测试，确保输出功能符合需求设计的可靠软件产品</li><li>持续运行和维护软件产品</li></ol><h3 id="5-代替全部开发阶段"><a href="#5-代替全部开发阶段" class="headerlink" title="5. 代替全部开发阶段"></a>5. 代替全部开发阶段</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190303021217.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>原型方法可代替全部的开发阶段，即从分析到输出最终软件产品，其过程顺序如下：</p><ol><li><p>定义软件初步需求</p></li><li><p>原型方法代替所有开发阶段：</p><ol><li>快速分析和明确软件需求</li><li>快速构造软件架构设计说明书</li><li>根据软件设计文档，快速编码构造程序系统</li><li>在编码构造的同时，快速执行相应的编码测试，输出软件产品</li><li>用户使用软件产品，提出评价和反馈</li><li>根据评价反馈，确定是否继续应用原型方法</li><li>继续循环原型方法，直到<strong>输出明确的需求说明文档、详细的软件设计文档、可靠的软件产品、完备的测试</strong></li></ol></li><li><p>持续运行和维护软件。</p><p>​</p></li></ol><hr><p>以上，完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要正确理解原型方法对软件生命周期不同阶段的支持，分别给出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;辅助或代替分析阶段；&lt;/li&gt;
&lt;li&gt;辅助设计阶段；&lt;/li&gt;
&lt;li&gt;代替分析与设计阶段；&lt;/li&gt;
&lt;li&gt;代替分析、设计和实现阶段；&lt;/li&gt;
&lt;li&gt;代替全部开发阶段；这五种情形
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件测试" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件工程 | 系分作业一</title>
    <link href="https://joshuaqyh.github.io/2019/03/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E7%B3%BB%E5%88%86%E4%BD%9C%E4%B8%9A%E4%B8%80/"/>
    <id>https://joshuaqyh.github.io/2019/03/02/软件工程-系分作业一/</id>
    <published>2019-03-02T04:05:54.000Z</published>
    <updated>2019-04-12T03:32:45.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下问题和解答来自 SYSU 16 级系统分析与设计课程 week1 的作业实践。</p><p>Student ID       ： 16340186 </p><p>Student Name :    邱奕浩</p></blockquote><p><strong>Q1: 阐述软件工程的定义。 </strong></p><p>A1： 软件工程一直以来缺乏严格标准的定义，不过很多学者，组织机构都给出了自己的定义，如：</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" target="_blank" rel="noopener"><strong>NATO (1968)</strong></a>: 软件工程是研究和应用如何以系统的，规范化的，可定量的过程化方法去开发和维护软件，以及如何把经过实践验证而证明正确的管理技术和当前最好的技术方法综合起来的一门独立学科。</li><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" target="_blank" rel="noopener"><strong>IEEE (1993)</strong></a>：软件工程是将系统化的，严格约束化的，量化的工程方法应用于软件的开发，运行，维护过程，即用工程化的方法来打造软件。</li><li><a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279" target="_blank" rel="noopener"><strong>《计算机科学技术百科全书》</strong></a>：软件工程是应用计算机科学，数学，逻辑学及管理科学等原理，来开发软件的过程。</li><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B#%E6%B2%92%E6%9C%89%E9%8A%80%E5%BD%88%E8%88%87%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%A9%B1" target="_blank" rel="noopener"><strong>《信息技术 软件工程术语》</strong></a>: 软件工程是应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或学科。</li></ol><p>从上述各方的定义中，我们可以得出：</p><ol><li><p>软件工程是一门独立的交叉学科，也是一门独特的工程，综合了理论，工程，技术，管理等方面的知识，同时处于理论与实践水平不断发展的过程。</p></li><li><p>软件工程具有系统化，约束化，规范化，过程化，可量化的特点，具备相应的工程管理原则和方法。</p><p>​</p></li></ol><hr><p><strong>Q2: 解释导致软件危机 ( software crisis ) 的本质原因和表现形式，并述说克服软件危机的方法。 </strong></p><p>A2：</p><ul><li><strong>软件危机的本质原因</strong>：<ul><li>软件的大量需求与软件生产力效率之间的矛盾，</li><li>软件系统的复杂性与软件开发方法之间的矛盾。</li></ul></li></ul><ul><li><p><strong>软件危机的表现形式</strong>：</p><ul><li>软件开发成本日益增长，开发成本往往超出预算<strong>（成本）</strong></li><li>软件开发进度难以控制，项目的开发时间往往超出预定的进度时间表<strong>（时间）</strong></li><li>用户对软件产品不满意的现象经常发生，这是对用户需求的理解不够明确，用户需求多样化的原因<strong>（需求）</strong></li><li>软件产品的质量不可靠，时常存在 Bug <strong>（质量）</strong>  </li><li>软件的可维护性低，数量不断膨胀的软件产品缺乏适当的文档资料 <strong>（维护）</strong></li><li>软件的开发生产率跟不上硬件的发展，计算能力越大，编程问题越大，软件越复杂。<strong>（摩尔定律）</strong></li></ul></li><li><p><strong>克服软件危机的主要方法</strong>：</p><ul><li>软件从业者必须正确认识计算机软件的内涵（软件 ≠ 程序）。</li><li>充分认识到软件开发并不是来自于某种个体劳动的神秘技巧，而是需要依托组织良好，管理严密，协同配合的工程活动。</li><li>采用成熟的软件开发技术和方法，比如<a href="https://zh.wikipedia.org/wiki/%E7%B5%90%E6%A7%8B%E5%8C%96%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" target="_blank" rel="noopener">结构化程序设计</a>，<a href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">面向对象的开发</a>)，<a href="https://zh.wikipedia.org/wiki/CMM" target="_blank" rel="noopener">CMM</a>，<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">UML</a>等等</li><li>开发和使用适当的软件工具</li><li>从业者的专业素养和知识水平必须不断提升</li></ul><p>IBM大型机之父 Brooks 在其著名论文《<a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9" target="_blank" rel="noopener">没有银弹</a>》中断言：“在10年无法找到解决软件危机的灵丹妙药”，在其另外一著作《<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D" target="_blank" rel="noopener">人月神话</a>》提到：开发软件的困难是天生存在的，我们只能渐进式的改善它。在整体工程环境没有改变之前，对克服软件危机所能做的就是<strong>依靠人的素质，培养优秀的软件工程师</strong>。</p><p>​</p></li></ul><hr><p><strong>Q3: 解释一下软件的生命周期的概念。</strong></p><p>A3：软件像一个个生命体一样，具有孕育、诞生、成长、成熟、衰亡的生存过程，即软件的生命周期。软件的生命周期被划分为若干阶段，每个阶段具有明确的任务，从而使规模，结构和管理复杂软件的开发过程得到适当的控制管理。生命周期主要分为以下6个阶段。</p><ol><li><p><strong>可行性分析与计划阶段</strong> </p><ol><li>确定软件开发的总体目标，给出功能，性能，可靠性以及接口等方面的要求，并进行可行性分析。</li><li>估算软件的开发成本，估计可利用的资源，成本，效益，开发进度，进行投资-收益分析，制定开发计划。</li><li>提交可行性分析报告、开发计划等文档。</li></ol></li><li><p><strong>需求分析阶段</strong></p><ol><li>分析用户需求，给出需求的详细定义，确定软件的各项功能，性能需求和设计约束，确定对文档编制的要求。</li><li>提交软件需求说明文档，软件规格说明文档，数据要求说明等文档和初步的用户手册。</li></ol></li><li><p><strong>设计阶段</strong></p><ol><li>概要设计：将需求转化成软件的体系结构，结构中每一组成部分必须是意义明确的模块，每一个模块必须和需求相匹配。</li><li>详细设计：对模块所完成的任务进行详细具体的描述，提供源程序编写的直接依据。</li><li>提交结构设计说明、详细设计说明和测试计划初稿等文档。</li></ol></li><li><p><strong>实现阶段</strong></p><ol><li>完成源程序的编码，编译，调试，得到没有语法错误的程序清单。必须确保程序结构良好，清晰，具有较为良好的可读性，并且与上一设计阶段中的要求相一致。</li><li>根据项目重要性和规模，编写开发进度日报，周报，或月报。</li><li>完成用户手册，操作手册等面向用户的文档编写工作。</li><li>编制初步的测试计划。</li></ol></li><li><p><strong>测试阶段</strong></p><ol><li>全面测试目标软件（包括单元测试，集成测试，系统测试等），并检查审阅已编制好的文档，提交测试分析报告。逐项评价所生产的程序，文档以及开发工作本身，提交项目开发总结报告。</li><li>在这个开发过程中，开发集体需要按月编写进度月报。</li></ol></li><li><p><strong>运行和维护阶段</strong></p><ol><li>用户使用软件之后，必须在运行使用中加以持续的维护，根据用户新提出的需求进行软件功能的扩充，删改，更新和升级。</li><li>软件维护包括改正性维护（用于发现软件错误），适应性维护（适应运行环境的变化）以及完善性维护（增强功能）。</li></ol><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190302163413.png" alt=""></p><p>​</p></li></ol><hr><p><strong>Q4:  SWEBoK 的 15 个知识域（<a href="https://www.sebokwiki.org/wiki/An_Overview_of_the_SWEBOK_Guide" target="_blank" rel="noopener">An Overview of the SWEBOK Guide</a> 请中文翻译其名称与简短说明）</strong></p><p>A4：SWEBoK  的中文名称为软件工程知识体系( <a href="https://www.computer.org/web/swebok/index" target="_blank" rel="noopener">Software Engineering Body of Knowledge</a>)，是 IEEE Computer Society 构建软件生产的最佳实践与相关知识的框架，用于指导软件工程人才的培养与学科建设。<strong>知识体系分为软件工程实践和基础教育两个部分，共有15个知识域 ( Knowledge Aaras 以下简称 KA )</strong> 。</p><ol><li><strong>软件工程实践(The Practice of Software Engineering) </strong><ol><li><strong>软件需求 (Software Requirements) </strong>：软件需求知识域主要关注软件需求的协商，谈判，分析，明确。，验证等过程。该 KA 是整个 SWEBoK 中最重要的两个领域之一。经业界实践表明，如果软件需求工作没做好，那么整条软件产品线和软件工程项目将变得极其最弱，所谓 ”牵一发而动全身”。</li><li><strong>软件设计 (Software Design) </strong>： 软件设计是定义软件结构，组件，接口，和其他系统特性以及产品结果的过程，该 KA 涵盖了软件的设计过程和目标产品。软件设计在软件生命周期中的主要目的是结合上一阶段的软件需求，做出对软件内部结构，接口和行为的具体描述。和软件需求 KA一样，软件设计KA是 SWEBoK 中最重要的领域之一。</li><li><strong>软件构建 (Software Construction)</strong>： 软件构建实现主要涉及到了详细的代码设计实现，单元测试，集成测试，调试和验证等工作任务。软件构建 KA 包含的相关主题是满足需求和设计约束的软件程序的发展过程，涵盖了软件构造基础，管理软件构建任务，构建方法论，实用的构建思想和软件构造的工具。</li><li><strong>软件测试 (Software Testing) </strong>：软件测试是一项评估软件项目质量以及识别软件缺陷并改善的工作，该 KA 包含了软件测试的基础知识，软件测试的技术，用户界面接口测试，相关的测试措施和实际软件的考虑方法。</li><li><strong>软件维护 (Software Maintenance) </strong>：软件维护 KA 涉及了升级现有软件功能（完善性维护），调整软件适应运行环境的变化（适应性维护），以及更正软件缺陷（改正性维护）等方面的工作。</li><li><strong>软件配置管理 (Software Configuration Management) </strong>： 系统的配置是硬件，固件，软件或他们组合的功能和物理特征。同时配置还可以看作是硬件，固件，软件，或其组合的特定版本的集合。不同的版本有不同的配置，根据特定的构建过程组合在一起，以服务与特定的目的。</li><li><strong>软件工程管理 (Software Engineering Management)</strong> ：软件工程管理包括计划，协调，衡量，报告和控制一个项目，以确保软件的开发和维护是系统化的，有纪律的以及可量化的。</li><li><strong>软件工程过程 (Software Engineering Process) </strong>： 该KA涉及软件生命周期过程的定义，实现，评估，度量，管理和改进。所涵盖的主题包括过程实现和变更，过程定义，过程评估模型和方法，以及过程测量。</li><li><strong>软件工程模型和方法 (Software Engineering Models and Methods) </strong>：该 KA 解决了围绕整个软件生命周期各阶段问题的方法，以及在特定生命周期阶段的其他 KA 所包含的问题的方法。</li><li><strong>软件质量 (Software Quality)</strong>： 软件质量问题是普遍存在于整个软件生命周期的问题，该 KA 关注软件质量的基础，软件质量管理过程，以及实际的考虑。</li><li><strong>软件工程专业实践 (Software Engineering Professional Practice)</strong>：该 KA 的理念是对于软件工程师而言，必须具备的知识，技能和态度，要以一种专业的，负责的，和合乎道德的方法来进行实践。</li></ol></li><li><strong>软件工程教育的需求 (The Educational Requirements of Software Engineering )</strong><ol><li><strong>软件工程经济学 (Software Engineering Economics)</strong>： 该 KA 主要关注的是如何在业务环境中做出决策，以便技术决策与组织的业务目标保持一致。</li><li><strong>计算基础  (Computing Foundations)</strong>：该 KA 涵盖了提供给软件工程实践所需的计算背景的基础主题。包括问题解决技术、抽象、算法和复杂性、编程基础、并行和分布式计算的基础、计算机组织、操作系统和网络通信。</li><li><strong>数学基础 (Mathematical Foundations) </strong>： 该 KA 涵盖了用于软件工程实践所需的数学理论基础，包含的主题有集合、关系、函数、基本的明题和谓词逻辑、证明方法、图、树、离散数学、仿真建模等等。</li><li><strong>工程基础 (Engineering Foundations)</strong>：该KA主要提供了用于软件工程实践所需的工程背景基础，主题涵盖了经验方法和实验技术、统计分析、测量与指标、工程设计、建模与仿真、以及根本原因分析等方面。</li></ol></li></ol><hr><p><strong>Q5： 简单解释 CMMI 的五个级别。</strong></p><p>A5： <a href="https://en.wikipedia.org/wiki/Capability_Maturity_Model_Integration" target="_blank" rel="noopener">CMMI</a> 中文名称为能力成熟度模型集成，是一种过程性的改进训练和评估计划，用于度量一个企业的软件工程能力。其五个级别简单概括如下：</p><ol><li><strong>Level 1 - Initial</strong>：企业运作处于一种无序，自发生产的模式，过程难以预测，控制性差，反应性弱。</li><li><strong>Level 2 - Managed</strong>：企业在管理级的水平上处于有序的，项目化的生产模式，具有明确的流程和较好的项目控制程序。</li><li><strong>Level 3 - Defined</strong>：企业工程水平达到定义级，企业企业管理组织化，流程标准化，体系制度化。</li><li><strong>Level 4 - Quantitatively Managed</strong>：企业管理水平进一步升级，实现数字化管理和控制。</li><li><strong>Level 5 - Optimizing</strong>：在优化级别，企业项目管理达到最高水平，能主动改善业务项目流程，不断实现过程优化。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Characteristics_of_Capability_Maturity_Model.svg/500px-Characteristics_of_Capability_Maturity_Model.svg.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p><strong>Q6：用自己的语言简述 SWEBok 或 CMMI（ 200 字）。</strong></p><p>SWEBok （软件工程知识体系）是 IEEE Computer Society 提出来的一套构建软件生产的最佳实践与相关知识的框架，用于指导软件工程人才的培养和学科建设。该体系从<strong>软件工程的实践和教育</strong>两个方面切入，就这两个方面划分了15个知识域（KA）。</p><p>在实践方面，知识体系归纳了 11 种知识域：围绕软件生命周期提出了 5 个知识域：软件需求 KA、软件设计 KA、软件实现 KA、软件测试 KA、软件运行维护 KA；结合工程管理的原则，提出了 6 个 KA：软件配置管理 KA、软件工程管理 KA、软件工程过程 KA、软件工程建模与方法 KA、软件质量 KA、软件工程专业实践 KA。</p><p>在教育方面，则是提出了软件工程经济学 KA、计算基础 KA、数学基础 KA、工程基础 KA。</p><p>整套知识体系科学完备，教育 KA 是 实践 KA 的基础和支撑，在实践的探索过程中，又不断地给予教育体系层面的反馈和优化。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190302163103.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p><strong>完。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下问题和解答来自 SYSU 16 级系统分析与设计课程 week1 的作业实践。&lt;/p&gt;
&lt;p&gt;Student ID       ： 16340186 &lt;/p&gt;
&lt;p&gt;Student Name :    邱奕浩&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统分析与设计" scheme="https://joshuaqyh.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>概念 | 必知的软件工程核心概念</title>
    <link href="https://joshuaqyh.github.io/2019/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>https://joshuaqyh.github.io/2019/03/01/软件工程-核心概念/</id>
    <published>2019-03-01T06:31:22.000Z</published>
    <updated>2019-03-08T06:30:22.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件与软件危机"><a href="#软件与软件危机" class="headerlink" title="软件与软件危机"></a>软件与软件危机</h1><h2 id="软件概念"><a href="#软件概念" class="headerlink" title="软件概念"></a>软件概念</h2><p>软件 = 程序 + 数据 + 文档 + （服务）</p><p>程序 = 数据结构 + 算法</p><p> 软件是能够完成预定功能和性能的、可执行的计算机指令；<br> 软件是使得程序能够适当地处理信息的数据结构；<br> 软件是描述程序的操作和使用的文档。</p><h2 id="软件的逻辑抽象性"><a href="#软件的逻辑抽象性" class="headerlink" title="软件的逻辑抽象性"></a>软件的逻辑抽象性</h2><p>软件是一种逻辑实体，具备知识性的产品集合，是对物理世界的一种抽象化，同时又是一种人脑智力的成果，开发成本昂贵但可以复制。</p><p>而软件问题都是在软件开发和修改过程中引入的，开发工作仍未完全摆脱手工作坊式的低效开发方式。软件测试则是为了最小化软件问题和风险。</p><h2 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301144129.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件产品的组成"><a href="#软件产品的组成" class="headerlink" title="软件产品的组成"></a>软件产品的组成</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301144237.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301144526.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301144608.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301144657.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301144804.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="软件开发与软件工程"><a href="#软件开发与软件工程" class="headerlink" title="软件开发与软件工程"></a>软件开发与软件工程</h1><h2 id="软件开发基本过程"><a href="#软件开发基本过程" class="headerlink" title="软件开发基本过程"></a>软件开发基本过程</h2><ol><li>软件计划，确定产品定位和目标人群。</li><li>软件需求分析：根据客户需求，制定客户需求的产品功能，特性，性能，界面和具体规格。</li><li>根据需求进行设计：概要设计和详细设计。</li><li>编程实现并运行。</li><li>软件测试：确认用户需求，对设计和实现结果进行验证。</li><li>维护：维持软件运行，修改软件缺陷，增强完善功能，不断迭代软件版本。</li></ol><h2 id="软件开发成本"><a href="#软件开发成本" class="headerlink" title="软件开发成本"></a>软件开发成本</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301145800.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301145817.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件工程要点"><a href="#软件工程要点" class="headerlink" title="软件工程要点"></a>软件工程要点</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301150101.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件工程原则"><a href="#软件工程原则" class="headerlink" title="软件工程原则"></a>软件工程原则</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301150138.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件工程目标"><a href="#软件工程目标" class="headerlink" title="软件工程目标"></a>软件工程目标</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301150216.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301150253.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h1><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><h3 id="可行性分析与计划阶段"><a href="#可行性分析与计划阶段" class="headerlink" title="可行性分析与计划阶段"></a>可行性分析与计划阶段</h3><ul><li>确定软件开发的总体目标，给出功能，性能，可靠性以及接口方面的要求，完成可行性分析。</li><li>估计软件开发所需要利用的各种资源，效益，成本，开发进度，制定开发计划</li><li>提交可行性分析报告，开发计划文档。</li></ul><h3 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h3><ul><li>分析用户提出的要求，给出需求详细定义，确定软件系统的各项功能，性能需求和设计约束，确定对文档编制的要求。</li><li>提交软件需求说明，软件规格说明，数据要求说明等文档和初步用户手册。</li></ul><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><ul><li>概要设计：把各项需求转换成软件的体系结构，结构中的每一部分都是意义明确的模块，每个模块与某些需求对应/</li><li>详细设计：对每个模块所完成的工作进行具体的描述，提供源程序编写的直接依据。</li><li>提交结构设计说明，详细设计说明和测试计划初稿等文档。</li></ul><h3 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h3><ul><li>完成源代码的编码实现。保证程序结构良好，清晰易读，与设计一致。</li><li>编写进度日报，周报和月报（取决于项目的重要性和规模）</li><li>提交用户手册，操作手册等面向用户的文档编写工作</li><li>提交测试计划</li></ul><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><ul><li>全面测试目标软件系统，检查审阅与编制的文档，提交测试分析报告。逐项评价所生产的程序，文档以及开发工作本身，提交项目开发总结报告。</li><li>开发过程中（前5阶段），开发集体需要按月编写开发进度月报。</li></ul><h3 id="运行与维护阶段"><a href="#运行与维护阶段" class="headerlink" title="运行与维护阶段"></a>运行与维护阶段</h3><ul><li>软件提交给用户后，在运行使用过程中得到持续维护，根据用户的新需求进行必要的软件修改和升级。</li><li>软件维护包括正性维护（发现错误），适应性维护（适应运行环境变化）和完善性维护（增强功能）</li></ul><h2 id="软件生命周期模型SDM"><a href="#软件生命周期模型SDM" class="headerlink" title="软件生命周期模型SDM"></a>软件生命周期模型SDM</h2><h3 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301153248.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301153331.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>瀑布模型中的每一个开发活动具有下列特征：</p><ul><li>本阶段活动的工作对象来自于上一项活动的输出，这些输出一般是代表本阶段活动结束的里程碑式的文档</li></ul><ul><li><p>根据本阶段的活动规程执行相应的任务</p></li><li><p>本阶段活动产出相关的软件工件，作为下一阶段活动的输入。</p></li><li><p>对本阶段活动执行情况进行评审</p><p>​</p></li></ul><p>瀑布模型的优点：</p><ul><li>降低软件开发的复杂程度，提高软件开发过程的透明性，提高软件开发过程的可管理性</li><li>推迟软件实现，强调在软件实现前必须进行分析和设计工作</li><li>以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，使产品达到预期的质量要求</li></ul><p>瀑布模型的缺点：</p><ul><li>强调过程活动的线性顺序</li><li>缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题</li><li>风险控制能力较弱</li><li>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量</li><li>管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论</li></ul><h3 id="V-W模型"><a href="#V-W模型" class="headerlink" title="V-W模型"></a>V-W模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301153814.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301153850.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>W 模型是V 模型的演进</p><ul><li>在V 模型中增加软件各开发阶段对应同步进行的测试。</li><li>W 模型中开发是一个“V”型，测试是与此并行的另一个“V”型。基于“尽早地和不断地进行软件测试”的原则，在软件的需求和设计阶段的测试活动遵循IEEE1012-1998《软件验证与确认(V&amp;V)》。</li><li>W 模型强调测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、功能和设计同样要测试。测试与开发是同步进行的，从而有利于尽早地发现问题。</li></ul><h3 id="快速应用开发模型"><a href="#快速应用开发模型" class="headerlink" title="快速应用开发模型"></a>快速应用开发模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301154034.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>（前端应用常用）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301154105.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190301154127.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="原型模型（重点）"><a href="#原型模型（重点）" class="headerlink" title="原型模型（重点）"></a>原型模型（重点）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190301154300.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>问题产生 → 用户痛点 → 产生需求 ↓</p><p>—– 设计原型  —— 实现并实现模型：  </p><p>if 原型 exist problems， then  修改加强 （伴随新的需求）</p><p>else 转为可用于生产环境的软件发行版本</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190301154646.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所有的新技术，需要使用原型法来试验。</p><p><strong>原型与原型方法</strong></p><ul><li>原型指模拟某种最终产品的原始模型</li><li>原型方法指在获得一组基本需求后，通过快速分析构造出一个小型的软件系统原型，满足用户的基本要求</li><li>用户通过使用原型系统，提出修改意见，从而减少用户与开发人员对系统需求的误解，使需求尽可能准确</li><li>原型方法主要用于明确需求，但也可以用于软件开发的其他阶段</li></ul><p><strong>原型方法的三种作用类型</strong></p><ul><li>探索型<ul><li>澄清用户对目标系统的要求，确定用户期望的特性；探讨多种实现方案的可行性。主要针对需求模糊、用户和开发者对目标项目开发都缺乏经验的情况。</li></ul></li><li>实验型<ul><li>用于大规模开发和实现之前，考核技术实现方案是否合适、分析和设计的规格说明是否可靠。</li></ul></li><li>进化型<ul><li>在构造系统的过程中适应需求的变化，通过不断改进原型，逐步将原型进化成最终的系统。它将原型方法的思想扩展到软件开发的全过程，适用于需求经常变动的软件项目。</li></ul></li></ul><p><strong>原型策略</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190301155319.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190301155352.png" alt=""></p><p><strong>原型方法与软件生命周期的联系！！</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190301155637.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件与软件危机&quot;&gt;&lt;a href=&quot;#软件与软件危机&quot; class=&quot;headerlink&quot; title=&quot;软件与软件危机&quot;&gt;&lt;/a&gt;软件与软件危机&lt;/h1&gt;&lt;h2 id=&quot;软件概念&quot;&gt;&lt;a href=&quot;#软件概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://joshuaqyh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 神经网络推导-前向&amp;反向</title>
    <link href="https://joshuaqyh.github.io/2019/02/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8E%A8%E5%AF%BC-%E5%89%8D%E5%90%91-%E5%8F%8D%E5%90%91/"/>
    <id>https://joshuaqyh.github.io/2019/02/28/机器学习-神经网络推导-前向-反向/</id>
    <published>2019-02-28T02:44:48.000Z</published>
    <updated>2019-02-28T05:27:32.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 以下BP神经网络推导过程是来自于NTU的李宏毅老师的ML课程。过程相当易懂，很好理解。为避免忘记，在此记录一下。视频推导链接如下（需要fq）:</p><p><a href="https://www.youtube.com/watch?v=ibJpTrp5mcE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ibJpTrp5mcE</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228111242.png" alt="局部网络图" title="">                </div>                <div class="image-caption">局部网络图</div>            </figure><h1 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h1><p>我们必须了解到的就是BP神经网络本质就是一个多层级联神经元和对应连接权重和偏置构成的函数，我们输入该函数，然后得到函数值就是模型的输出结果。</p><p>该函数具备有权重参数和偏置参数，我们需要通过输入训练数据和标签来拟合得到一组权重参数和偏置参数。拟合的方式近似于最小二乘法，我们可以得到BP神经网络的损失函数。如下：</p><p>给定训练集标签向量$O_t$和训练结果$R_t$, 我们将其训练误差$L$表示为:</p><p>$$L = \frac{1}{2} \sum_{t∈T}{(O_t - R_t)}^2 \tag{1}$$</p><p>其实也就是所有模型输出实例的预测结果减去标签真实结果的平方和的一半。<strong>我们将训练误差函数定义为一个BP神经网络模型的损失函数，我们的目标就是最小化该损失函数</strong>。求解思路看下。</p><h1 id="求解核心思路"><a href="#求解核心思路" class="headerlink" title="求解核心思路"></a>求解核心思路</h1><p>BP神经网络参数（权重+bias）和损失函数L($\theta$)已知，利用梯度下降法和链式法则可进行推导。</p><ol><li>首先梯度下降法核心思想不变，我们需要重点关注梯度函数。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228105856.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="2"><li>由于网络结构是多层的，需要使用到链式法则来求解梯度函数。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228105919.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="3"><li>损失函数的微分（梯度函数）可以为关于$w_i$的多项偏微分之和。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228110018.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="4"><li>利用链式法则,将梯度函数差分为主要的两项（红色方框标出），然后分别进行前向和反向的迭代计算，等整个网络收敛之后，<strong>计算得到整个网络的当前梯度值，然后利用梯度下降法更新网络参数。</strong></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228110551.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228111048.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>前向过程特别简单，从网络结构上来看：微分值 = 前一层的输入之和。 </p><p>反向过程较为复杂，以下详细展开。</p><h2 id="反向推导"><a href="#反向推导" class="headerlink" title="反向推导"></a>反向推导</h2><p>先从输入层出发考虑，可以得到一个迭代式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228111549.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228111717.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可以看出上图右边式子的小红框部分和左边式子的左边构成一个迭代关系。只不过小红框部分是下一层的微分值。从这里就可以看出来，要计算当前的微分值需要提前知道下一层的微分值，由此可以将网络结构逆转，反向进行计算。代入$w_3,w_4,\sigma’(z)$整理得到下述式子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228112027.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将输出层，当成输入层，激活函数为放大器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228112254.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>迭代过程主要有两种情况：输出层和非输出层。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228112316.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228112544.png" alt=""></p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228112615.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190228112647.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>利用梯度下降法和链式法则来求解BP神经网络的损失函数的最优参数解，可分为前向和后向两个过程。前向微分是直接将当前节点的输入值求和即可。而反向微分则是需要链式法则由下一层的微分值计算得到当前层的微分值，将整个网络逆转过来，而激活函数变为普通的放大器$\sigma’(z)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 以下BP神经网络推导过程是来自于NTU的李宏毅老师的ML课程。过程相当易懂，很好理解。为避免忘记，在此记录一下。视频推导链接如下（需要fq）:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ibJ
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 线性模型-手写推导和求解</title>
    <link href="https://joshuaqyh.github.io/2019/02/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B-%E6%89%8B%E5%86%99%E6%8E%A8%E5%AF%BC%E5%92%8C%E6%B1%82%E8%A7%A3/"/>
    <id>https://joshuaqyh.github.io/2019/02/26/机器学习-线性模型-手写推导和求解/</id>
    <published>2019-02-25T18:02:44.000Z</published>
    <updated>2019-02-25T18:06:36.480Z</updated>
    
    <content type="html"><![CDATA[<p>写的好草啊，虽然这个有点简单，但如果涉及到对数回归就会相对麻烦一点了，这次就先这样，下次要更加规范一点：</p><ol><li>字体不要太草</li><li>公式符号要特别标明</li></ol><p>下面是简单记录模型的含义，以及如何利用梯度下降法来求解最小二乘法的问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190226020318.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190226020337.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写的好草啊，虽然这个有点简单，但如果涉及到对数回归就会相对麻烦一点了，这次就先这样，下次要更加规范一点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字体不要太草&lt;/li&gt;
&lt;li&gt;公式符号要特别标明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是简单记录模型的含义，以及如何利用梯度下降法来求解最小二乘
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 |  思考篇</title>
    <link href="https://joshuaqyh.github.io/2019/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%80%9D%E8%80%83%E7%AF%87/"/>
    <id>https://joshuaqyh.github.io/2019/02/25/机器学习-思考篇/</id>
    <published>2019-02-25T15:53:56.000Z</published>
    <updated>2019-02-25T18:12:33.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习的局限在哪里"><a href="#机器学习的局限在哪里" class="headerlink" title="机器学习的局限在哪里"></a>机器学习的局限在哪里</h1><ul><li>缺乏可解释性</li><li>假设数据分布一致</li><li>需要大量数据</li><li>难以进行知识推理，只能基于统计归纳</li></ul><h1 id="机器学习未来的发展方向在哪里"><a href="#机器学习未来的发展方向在哪里" class="headerlink" title="机器学习未来的发展方向在哪里"></a>机器学习未来的发展方向在哪里</h1><ul><li>提升可解释性，脱离黑盒模型</li><li>自解释和自推理</li><li>防止对抗攻击</li><li>神经网络压缩</li><li>强化学习</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习的局限在哪里&quot;&gt;&lt;a href=&quot;#机器学习的局限在哪里&quot; class=&quot;headerlink&quot; title=&quot;机器学习的局限在哪里&quot;&gt;&lt;/a&gt;机器学习的局限在哪里&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;缺乏可解释性&lt;/li&gt;
&lt;li&gt;假设数据分布一致&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | EM聚类算法</title>
    <link href="https://joshuaqyh.github.io/2019/02/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-EM%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://joshuaqyh.github.io/2019/02/24/机器学习-EM聚类算法/</id>
    <published>2019-02-23T22:00:00.000Z</published>
    <updated>2019-02-23T23:36:02.921Z</updated>
    
    <content type="html"><![CDATA[<p>EM算法的思想利用到了极大似然法，首先必须对极大似然有所了解。</p><h1 id="极大似然估计法"><a href="#极大似然估计法" class="headerlink" title="极大似然估计法"></a>极大似然估计法</h1><p>极大似然估计，简单来说就是通过抽取一部分样本，反推个体分布规律中的参数。比如从一个班抽取一部分同学，统计其身高，反推实际的高斯分布中的参数如均值$\mu$ 和标准差$\theta$。一般步骤就是：</p><p>（1）写出似然函数；</p><p>（2）对似然函数取对数，并整理；</p><p>（3）求导数，令导数为0，得到似然方程；</p><p>（4）解似然方程，得到的参数即为所求；</p><p>详细介绍如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190224062751.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190224062830.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><p>​    期望最大算法是一种从不完全数据或有数据丢失的数据集（存在隐含变量）中求解概率模型参数的最大似然估计方法。</p><p><strong>EM的算法流程：</strong></p><p>初始化分布参数θ；</p><p><strong>重复以下步骤直到收敛</strong>：</p><p>​        <strong>E步骤：</strong>根据参数初始值或上一次迭代的模型参数来计算出隐性变量的后验概率，其实就是隐性变量的期望。作为隐藏变量的现估计值：</p><p>​       <img src="https://img-my.csdn.net/uploads/201301/24/1359004674_9261.jpg" alt="img"></p><p>​        <strong>M步骤：</strong>将似然函数最大化以获得新的参数值：</p><p>​          <img src="https://img-my.csdn.net/uploads/201301/24/1359004692_8552.jpg" alt="img"></p><p>​        这个不断的迭代，就可以得到使似然函数L(θ)最大化的参数θ了。那就得回答刚才的第二个问题了，它会收敛吗？</p><p>感性的说，因为下界不断提高，所以极大似然估计单调增加，那么最终我们会到达最大似然估计的最大值。理性分析的话，就会得到下面的东西：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-my.csdn.net/uploads/201301/24/1359004726_5955.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>具体如何证明的，看推导过程参考：Andrew Ng《The EM algorithm》</p><p><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="noopener">http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html</a></p><h1 id="EM算法用途"><a href="#EM算法用途" class="headerlink" title="EM算法用途"></a>EM算法用途</h1><p><strong>EM的应用</strong></p><p>​       EM算法有很多的应用，最广泛的就是GMM混合高斯模型、聚类、HMM等等。具体可以参考JerryLead的cnblog中的Machine Learning专栏：</p><p><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="noopener">（</a><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="noopener">EM算法）</a>The EM Algorithm</p><p><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006924.html" target="_blank" rel="noopener">混合高斯模型（</a>Mixtures of Gaussians）和EM算法</p><p><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006910.html" target="_blank" rel="noopener">K-means</a>聚类算法</p><h1 id="使用-EM工具包"><a href="#使用-EM工具包" class="headerlink" title="使用 EM工具包"></a>使用 EM工具包</h1><p>直接使用sklearn中的工具包，获得GMM模型，先fit拟合，然后predict输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数据加载，避免中文乱码问题</span></span><br><span class="line">data_ori = pd.read_csv(<span class="string">'./heros.csv'</span>, encoding = <span class="string">'gb18030'</span>)</span><br><span class="line">features = [<span class="string">u'最大生命'</span>,<span class="string">u'生命成长'</span>,<span class="string">u'初始生命'</span>,<span class="string">u'最大法力'</span>, <span class="string">u'法力成长'</span>,<span class="string">u'初始法力'</span>,<span class="string">u'最高物攻'</span>,<span class="string">u'物攻成长'</span>,<span class="string">u'初始物攻'</span>,<span class="string">u'最大物防'</span>,<span class="string">u'物防成长'</span>,<span class="string">u'初始物防'</span>, <span class="string">u'最大每5秒回血'</span>, <span class="string">u'每5秒回血成长'</span>, <span class="string">u'初始每5秒回血'</span>, <span class="string">u'最大每5秒回蓝'</span>, <span class="string">u'每5秒回蓝成长'</span>, <span class="string">u'初始每5秒回蓝'</span>, <span class="string">u'最大攻速'</span>, <span class="string">u'攻击范围'</span>]</span><br><span class="line">data = data_ori[features]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对英雄属性之间的关系进行可视化分析</span></span><br><span class="line"><span class="comment"># 设置 plt 正确显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>] <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>]=<span class="keyword">False</span> <span class="comment"># 用来正常显示负号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用热力图呈现 features_mean 字段之间的相关性</span></span><br><span class="line">corr = data[features].corr()</span><br><span class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">14</span>))</span><br><span class="line"><span class="comment"># annot=True 显示每个方格的数据</span></span><br><span class="line">sns.heatmap(corr, annot=<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 相关性大的属性保留一个，因此可以对属性进行降维</span></span><br><span class="line">features_remain = [<span class="string">u'最大生命'</span>, <span class="string">u'初始生命'</span>, <span class="string">u'最大法力'</span>, <span class="string">u'最高物攻'</span>, <span class="string">u'初始物攻'</span>, <span class="string">u'初始物攻'</span>, <span class="string">u'最大物防'</span>, <span class="string">u'初始物防'</span>, <span class="string">u'最大每5秒回血'</span>, <span class="string">u'最大每5秒回蓝'</span>, <span class="string">u'初始每5秒回蓝'</span>, <span class="string">u'最大攻速'</span>, <span class="string">u'攻击范围'</span>]</span><br><span class="line">data = data_ori[features_remain]</span><br><span class="line">data[<span class="string">u'最大攻速'</span>] = data[<span class="string">u'最大攻速'</span>].apply(<span class="keyword">lambda</span> x: float(x.strip(<span class="string">'%'</span>))/<span class="number">100</span>)</span><br><span class="line">data[<span class="string">u'攻击范围'</span>]=data[<span class="string">u'攻击范围'</span>].map(&#123;<span class="string">'远程'</span>:<span class="number">1</span>,<span class="string">'近战'</span>:<span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment"># 采用 Z-Score 规范化数据，保证每个特征维度的数据均值为 0，方差为 1</span></span><br><span class="line">ss = StandardScaler()</span><br><span class="line">data = ss.fit_transform(data)</span><br><span class="line"><span class="comment"># 构造 GMM 聚类</span></span><br><span class="line">gmm = GaussianMixture(n_components=<span class="number">5</span>, covariance_type=<span class="string">'full'</span>)</span><br><span class="line">gmm.fit(data)</span><br><span class="line"><span class="comment"># 训练数据</span></span><br><span class="line">prediction = gmm.predict(data)</span><br><span class="line">print(prediction)</span><br><span class="line"><span class="comment"># 将分组结果输出到 CSV 文件中</span></span><br><span class="line">data_ori.insert(<span class="number">0</span>, <span class="string">'分组'</span>, prediction)</span><br><span class="line">data_ori.to_csv(<span class="string">'./hero_out.csv'</span>, index=<span class="keyword">False</span>, sep=<span class="string">','</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;EM算法的思想利用到了极大似然法，首先必须对极大似然有所了解。&lt;/p&gt;
&lt;h1 id=&quot;极大似然估计法&quot;&gt;&lt;a href=&quot;#极大似然估计法&quot; class=&quot;headerlink&quot; title=&quot;极大似然估计法&quot;&gt;&lt;/a&gt;极大似然估计法&lt;/h1&gt;&lt;p&gt;极大似然估计，简单来说
      
    
    </summary>
    
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>常用的三种数据规范化的方法及python实现</title>
    <link href="https://joshuaqyh.github.io/2019/02/24/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%E6%B3%95/"/>
    <id>https://joshuaqyh.github.io/2019/02/24/常用的三种数据规范化的方法法/</id>
    <published>2019-02-23T19:35:40.000Z</published>
    <updated>2019-02-23T19:49:33.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种数据规范化方法介绍和使用"><a href="#三种数据规范化方法介绍和使用" class="headerlink" title="三种数据规范化方法介绍和使用"></a>三种数据规范化方法介绍和使用</h1><h2 id="Min-max-规范化"><a href="#Min-max-规范化" class="headerlink" title="Min-max 规范化"></a>Min-max 规范化</h2><p>Min-max 规范化方法是将原始数据变换到 [0,1] 的空间中。用公式表示就是：</p><p><strong>新数值 =（原数值 - 极小值）/（极大值 - 极小值）。</strong></p><p>即$new = \frac{old - min}{max - min}$。</p><p>在如朴素贝叶斯方法和决策树方法中，规范化后的数值必须非负数，所以一般采用min-max规范化。</p><p>在python中使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 初始化数据，每一行表示一个样本，每一列表示一个特征</span></span><br><span class="line">x = np.array([[ <span class="number">0.</span>, <span class="number">-3.</span>,  <span class="number">1.</span>],</span><br><span class="line">              [ <span class="number">3.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">              [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line"><span class="comment"># 将数据进行 [0,1] 规范化</span></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler() <span class="comment"># 获得一个转换器对象</span></span><br><span class="line">minmax_x = min_max_scaler.fit_transform(x)  <span class="comment"># 使用转换器的方法进行转换</span></span><br><span class="line"><span class="keyword">print</span> minmax_x</span><br></pre></td></tr></table></figure><h2 id="Z-Score-规范化"><a href="#Z-Score-规范化" class="headerlink" title="Z-Score 规范化"></a>Z-Score 规范化</h2><p>假设 A 与 B 的考试成绩都为 80 分，A 的考卷满分是 100 分（及格 60 分），B 的考卷满分是 500 分（及格 300 分）。虽然两个人都考了 80 分，但是 A 的 80 分与 B 的 80 分代表完全不同的含义。</p><p>那么如何用相同的标准来比较 A 与 B 的成绩呢？Z-Score 就是用来可以解决这一问题的。</p><p>我们定义：<strong>新数值 =（原数值 - 均值）/ 标准差。</strong> 这一方法其实就是把数据规范化成一个标准的正态分布。</p><p>假设 A 所在的班级平均分为 80，标准差为 10。B 所在的班级平均分为 400，标准差为 100。那么 A 的新数值 =(80-80)/10=0，B 的新数值 =(80-400)/100=-3.2。</p><p>那么在 Z-Score 标准下，A 的成绩会比 B 的成绩好。</p><p>我们能看到 Z-Score 的优点是算法简单，不受数据量级影响，结果易于比较。不足在于，它需要数据整体的平均值和方差，而且结果没有实际意义，只是用于比较。</p><p>在python中使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 初始化数据</span></span><br><span class="line">x = np.array([[ <span class="number">0.</span>, <span class="number">-3.</span>,  <span class="number">1.</span>],</span><br><span class="line">              [ <span class="number">3.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">              [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line"><span class="comment"># 将数据进行 Z-Score 规范化</span></span><br><span class="line">scaled_x = preprocessing.scale(x) <span class="comment"># 直接调用 scale方法</span></span><br><span class="line"><span class="keyword">print</span> scaled_x</span><br></pre></td></tr></table></figure><h2 id="小数定标规范化"><a href="#小数定标规范化" class="headerlink" title="小数定标规范化"></a>小数定标规范化</h2><p>小数定标规范化就是通过移动小数点的位置来进行规范化。小数点移动多少位取决于属性 A 的取值中的最大绝对值。</p><p>举个例子，比如属性 A 的取值范围是 -999 到 88，那么最大绝对值为 999，小数点就会移动 3 位，即新数值 = 原数值 /1000。那么 A 的取值范围就被规范化为 -0.999 到 0.088。</p><p>在python中使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 初始化数据</span></span><br><span class="line">x = np.array([[ <span class="number">0.</span>, <span class="number">-3.</span>,  <span class="number">1.</span>],</span><br><span class="line">              [ <span class="number">3.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">              [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line"><span class="comment"># 小数定标规范化</span></span><br><span class="line">j = np.ceil(np.log10(np.max(abs(x)))) <span class="comment"># 获取小数点移动位数</span></span><br><span class="line">scaled_x = x/(<span class="number">10</span>**j)</span><br><span class="line"><span class="keyword">print</span> scaled_x</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三种数据规范化方法介绍和使用&quot;&gt;&lt;a href=&quot;#三种数据规范化方法介绍和使用&quot; class=&quot;headerlink&quot; title=&quot;三种数据规范化方法介绍和使用&quot;&gt;&lt;/a&gt;三种数据规范化方法介绍和使用&lt;/h1&gt;&lt;h2 id=&quot;Min-max-规范化&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | K-means 聚类算法</title>
    <link href="https://joshuaqyh.github.io/2019/02/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-kmeans-%E8%81%9A%E7%B1%BB/"/>
    <id>https://joshuaqyh.github.io/2019/02/24/机器学习-kmeans-聚类/</id>
    <published>2019-02-23T17:46:05.000Z</published>
    <updated>2019-02-23T19:51:23.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K-Means-工作原理"><a href="#K-Means-工作原理" class="headerlink" title="K-Means 工作原理"></a>K-Means 工作原理</h1><p> 工作原理很简单：</p><ol><li>选取 K 个点作为初始的类中心点，这些点一般都是从数据集中随机抽取的；</li><li>将每个点分配到最近的类中心点，这样就形成了 K 个类，然后重新计算每个类的中心点；</li><li>重复第二步，直到类不发生变化，或者你也可以设置最大迭代次数，这样即使类中心点发生变化，但是只要达到最大迭代次数就会结束。</li></ol><h1 id="使用-K-means-算法"><a href="#使用-K-means-算法" class="headerlink" title="使用 K-means 算法"></a>使用 K-means 算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">KMeans(n_clusters=<span class="number">8</span>, init=<span class="string">'k-means++'</span>, n_init=<span class="number">10</span>, max_iter=<span class="number">300</span>, tol=<span class="number">0.0001</span>, precompute_distances=<span class="string">'auto'</span>, verbose=<span class="number">0</span>, random_state=<span class="keyword">None</span>, copy_x=<span class="keyword">True</span>, n_jobs=<span class="number">1</span>, algorithm=<span class="string">'auto'</span>)</span><br></pre></td></tr></table></figure><p>们能看到在 K-Means 类创建的过程中，有一些主要的参数：</p><ul><li><strong>n_clusters</strong>: 即 K 值，一般需要多试一些 K 值来保证更好的聚类效果。你可以随机设置一些 K 值，然后选择聚类效果最好的作为最终的 K 值；</li><li><strong>max_iter</strong>： 最大迭代次数，如果聚类很难收敛的话，设置最大迭代次数可以让我们及时得到反馈结果，否则程序运行时间会非常长；</li><li><strong>n_init</strong>：初始化中心点的运算次数，默认是 10。程序是否能快速收敛和中心点的选择关系非常大，所以在中心点选择上多花一些时间，来争取整体时间上的快速收敛还是非常值得的。由于每一次中心点都是随机生成的，这样得到的结果就有好有坏，非常不确定，所以要运行 n_init 次, 取其中最好的作为初始的中心点。如果 K 值比较大的时候，你可以适当增大 n_init 这个值；</li><li><strong>init：</strong> 即初始值选择的方式，默认是采用优化过的 k-means++ 方式，你也可以自己指定中心点，或者采用 random 完全随机的方式。自己设置中心点一般是对于个性化的数据进行设置，很少采用。random 的方式则是完全随机的方式，一般推荐采用优化过的 k-means++ 方式；</li><li><strong>algorithm</strong>：k-means 的实现算法，有“auto” “full”“elkan”三种。一般来说建议直接用默认的”auto”。简单说下这三个取值的区别，如果你选择”full”采用的是传统的 K-Means 算法，“auto”会根据数据的特点自动选择是选择“full”还是“elkan”。我们一般选择默认的取值，即“auto” 。</li></ul><p>在创建好 K-Means 类之后，就可以使用它的方法，最常用的是 fit 和 predict 这个两个函数。你可以单独使用 fit 函数和 predict 函数，也可以合并使用 fit_predict 函数。其中 fit(data) 可以对 data 数据进行 k-Means 聚类。 predict(data) 可以针对 data 中的每个样本，计算最近的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 输入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'data.csv'</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line">train_x = data[[<span class="string">"2019 年国际排名 "</span>,<span class="string">"2018 世界杯 "</span>,<span class="string">"2015 亚洲杯 "</span>]]</span><br><span class="line">df = pd.DataFrame(train_x)</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 规范化到 [0,1] 空间</span></span><br><span class="line">min_max_scaler=preprocessing.MinMaxScaler()</span><br><span class="line">train_x=min_max_scaler.fit_transform(train_x)</span><br><span class="line"><span class="comment"># kmeans 算法</span></span><br><span class="line">kmeans.fit(train_x)</span><br><span class="line">predict_y = kmeans.predict(train_x)</span><br><span class="line"><span class="comment"># 合并聚类结果，插入到原数据中</span></span><br><span class="line">result = pd.concat((data,pd.DataFrame(predict_y)),axis=<span class="number">1</span>)</span><br><span class="line">result.rename(&#123;<span class="number">0</span>:<span class="string">u'聚类'</span>&#125;,axis=<span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h1 id="K-means-聚类分割"><a href="#K-means-聚类分割" class="headerlink" title="K-means 聚类分割"></a>K-means 聚类分割</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 K-means 对图像进行聚类，并显示聚类压缩后的图像</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PIL.Image <span class="keyword">as</span> image</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像，并对数据进行规范化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    <span class="comment"># 读文件</span></span><br><span class="line">    f = open(filePath,<span class="string">'rb'</span>)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="comment"># 得到图像的像素值</span></span><br><span class="line">    img = image.open(f)</span><br><span class="line">    <span class="comment"># 得到图像尺寸</span></span><br><span class="line">    width, height = img.size</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(height):</span><br><span class="line">            <span class="comment"># 得到点 (x,y) 的三个通道值</span></span><br><span class="line">            c1, c2, c3 = img.getpixel((x, y))</span><br><span class="line">            data.append([c1, c2, c3])</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="comment"># 采用 Min-Max 规范化</span></span><br><span class="line">    mm = preprocessing.MinMaxScaler()</span><br><span class="line">    data = mm.fit_transform(data)</span><br><span class="line">    <span class="keyword">return</span> np.mat(data), width, height</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像，得到规范化的结果 img，以及图像尺寸</span></span><br><span class="line">img, width, height = load_data(<span class="string">'./weixin.jpg'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 K-Means 对图像进行 2 聚类</span></span><br><span class="line">kmeans =KMeans(n_clusters=<span class="number">2</span>)</span><br><span class="line">kmeans.fit(img)</span><br><span class="line">label = kmeans.predict(img)</span><br><span class="line"><span class="comment"># 将图像聚类结果，转化成图像尺寸的矩阵</span></span><br><span class="line">label = label.reshape([width, height])</span><br><span class="line"><span class="comment"># 创建个新图像 pic_mark，用来保存图像聚类的结果，并设置不同的灰度值</span></span><br><span class="line">pic_mark = image.new(<span class="string">"L"</span>, (width, height))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(width):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(height):</span><br><span class="line">        <span class="comment"># 根据类别设置图像灰度, 类别 0 灰度值为 255， 类别 1 灰度值为 127</span></span><br><span class="line">        pic_mark.putpixel((x, y), int(<span class="number">256</span>/(label[x][y]+<span class="number">1</span>))<span class="number">-1</span>)</span><br><span class="line">pic_mark.save(<span class="string">"weixin_mark.jpg"</span>, <span class="string">"JPEG"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;K-Means-工作原理&quot;&gt;&lt;a href=&quot;#K-Means-工作原理&quot; class=&quot;headerlink&quot; title=&quot;K-Means 工作原理&quot;&gt;&lt;/a&gt;K-Means 工作原理&lt;/h1&gt;&lt;p&gt; 工作原理很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选取 K 个点
      
    
    </summary>
    
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | KNN算法</title>
    <link href="https://joshuaqyh.github.io/2019/02/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-KNN%E7%AE%97%E6%B3%95/"/>
    <id>https://joshuaqyh.github.io/2019/02/24/机器学习-KNN算法/</id>
    <published>2019-02-23T17:03:49.000Z</published>
    <updated>2019-02-23T19:51:23.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KNN工作原理"><a href="#KNN工作原理" class="headerlink" title="KNN工作原理"></a>KNN工作原理</h1><p>近朱者赤，近墨者黑”可以说是 KNN 的工作原理。整个计算过程分为三步：</p><ol><li>计算待分类物体与其他物体之间的距离；</li><li>统计距离最近的 K 个邻居；</li><li>对于 K 个最近的邻居，它们属于哪个分类最多，待分类物体就属于哪一类。</li></ol><p><strong>K 值如何选择</strong></p><p>你能看出整个 KNN 的分类过程，K 值的选择还是很重要的。那么问题来了，K 值选择多少是适合的呢？</p><p>如果 K 值比较小，就相当于未分类物体与它的邻居非常接近才行。这样产生的一个问题就是，如果邻居点是个噪声点，那么未分类物体的分类也会产生误差，这样 KNN 分类就会产生过拟合。</p><p>如果 K 值比较大，相当于距离过远的点也会对未知物体的分类产生影响，虽然这种情况的好处是鲁棒性强，但是不足也很明显，会产生欠拟合情况，也就是没有把未分类物体真正分类出来。</p><p>所以 K 值应该是个实践出来的结果，并不是我们事先而定的。<strong>在工程上，我们一般采用交叉验证的方式选取 K 值。</strong></p><p>交叉验证的思路就是，把样本集中的大部分样本作为训练集，剩余的小部分样本用于预测，来验证分类模型的准确性。所以在 KNN 算法中，我们一般会把 K 值选取在较小的范围内，同时在验证集上准确率最高的那一个最终确定作为 K 值。</p><p><strong>距离如何计算</strong></p><p>在 KNN 算法中，还有一个重要的计算就是关于距离的度量。两个样本点之间的距离代表了这两个样本之间的相似度。距离越大，差异性越大；距离越小，相似度越大。</p><p>关于距离的计算方式有下面五种方式：</p><ol><li>欧氏距离；</li><li>曼哈顿距离；</li><li>闵可夫斯基距离；</li><li>切比雪夫距离；</li><li>余弦距离。</li></ol><p>其中前三种距离是 KNN 中最常用的距离，我给你分别讲解下。</p><p><strong>欧氏距离</strong>是我们最常用的距离公式，也叫做欧几里得距离。在二维空间中，两点的欧式距离就是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/f8/80/f8d4fe58ec9580a4ffad5cee263b1b80.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>同理，我们也可以求得两点在 n 维空间中的距离：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/40/6a/40efe7cb4a2571e55438b55f8d37366a.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><strong>曼哈顿距离</strong>在几何空间中用的比较多。以下图为例，绿色的直线代表两点之间的欧式距离，而红色和黄色的线为两点的曼哈顿距离。所以曼哈顿距离等于两个点在坐标系上绝对轴距总和。用公式表示就是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/bd/aa/bda520e8ee34ea19df8dbad3da85faaa.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/dd/43/dd19ca4f0be3f60b526e9ea0b7d13543.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><strong>闵可夫斯基距离</strong>不是一个距离，而是一组距离的定义。对于 n 维空间中的两个点 x(x1,x2,…,xn) 和 y(y1,y2,…,yn) ， x 和 y 两点之间的闵可夫斯基距离为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/4d/c5/4d614c3d6722c02e4ea03cb1e6653dc5.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>其中 p 代表空间的维数，当 p=1 时，就是曼哈顿距离；当 p=2 时，就是欧氏距离；当 p→∞时，就是切比雪夫距离。</p><p><strong>那么切比雪夫距离</strong>怎么计算呢？二个点之间的切比雪夫距离就是这两个点坐标数值差的绝对值的最大值，用数学表示就是：max(|x1-y1|,|x2-y2|)。</p><p><strong>余弦距离</strong>实际上计算的是两个向量的夹角，是在方向上计算两者之间的差异，对绝对数值不敏感。在兴趣相关性比较上，角度关系比距离的绝对值更重要，因此余弦距离可以用于衡量用户对内容兴趣的区分度。比如我们用搜索引擎搜索某个关键词，它还会给你推荐其他的相关搜索，这些推荐的关键词就是采用余弦距离计算得出的。</p><h1 id="KD-树"><a href="#KD-树" class="headerlink" title="KD 树"></a>KD 树</h1><p>其实从上文你也能看出来，KNN 的计算过程是大量计算样本点之间的距离。为了减少计算距离次数，提升 KNN 的搜索效率，人们提出了 KD 树（K-Dimensional 的缩写）。KD 树是对数据点在 K 维空间中划分的一种数据结构。在 KD 树的构造中，每个节点都是 k 维数值点的二叉树。既然是二叉树，就可以采用二叉树的增删改查操作，这样就大大提升了搜索效率。</p><p>在这里，我们不需要对 KD 树的数学原理了解太多，你只需要知道它是一个二叉树的数据结构，方便存储 K 维空间的数据就可以了。而且在 sklearn 中，我们直接可以调用 KD 树，很方便。</p><h1 id="用-KNN-做回归"><a href="#用-KNN-做回归" class="headerlink" title="用 KNN 做回归"></a>用 KNN 做回归</h1><p>KNN 不仅可以做分类，还可以做回归。首先讲下什么是回归。在开头电影这个案例中，如果想要对未知电影进行类型划分，这是一个分类问题。首先看一下要分类的未知电影，离它最近的 K 部电影大多数属于哪个分类，这部电影就属于哪个分类。</p><p>如果是一部新电影，已知它是爱情片，想要知道它的打斗次数、接吻次数可能是多少，这就是一个回归问题。</p><p>那么 KNN 如何做回归呢？</p><p>对于一个新点，我们需要找出这个点的 K 个最近邻居，然后将这些邻居的属性的平均值赋给该点，就可以得到该点的属性。当然不同邻居的影响力权重可以设置成不同的。举个例子，比如一部电影 A，已知它是动作片，当 K=3 时，最近的 3 部电影是《战狼》，《红海行动》和《碟中谍 6》，那么它的打斗次数和接吻次数的预估值分别为 (100+95+105)/3=100 次、(5+3+31)/3=13 次。</p><h1 id="KNN用途"><a href="#KNN用途" class="headerlink" title="KNN用途"></a>KNN用途</h1><p>KNN 的理论简单直接，针对 KNN 中的搜索也有相应的 KD 树这个数据结构。KNN 的理论成熟，可以应用到线性和非线性的分类问题中，也可以用于回归分析。</p><p>不过 KNN 需要计算测试点与样本点之间的距离，当数据量大的时候，计算量是非常庞大的，需要大量的存储空间和计算时间。另外如果样本分类不均衡，比如有些分类的样本非常少，那么该类别的分类准确率就会低很多。</p><p>当然在实际工作中，我们需要考虑到各种可能存在的情况，比如针对某类样本少的情况，可以增加该类别的权重。</p><p>同样 KNN 也可以用于推荐算法，虽然现在很多推荐系统的算法会使用 TD-IDF、协同过滤、Apriori 算法，不过针对数据量不大的情况下，采用 KNN 作为推荐算法也是可行的。</p><h1 id="手写体识别"><a href="#手写体识别" class="headerlink" title="手写体识别"></a>手写体识别</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">data = digits.data</span><br><span class="line"><span class="comment"># 分割数据，将 25% 的数据作为测试集，其余作为训练集（你也可以指定其他比例的数据作为训练集）</span></span><br><span class="line">train_x, test_x, train_y, test_y = train_test_split(data, digits.target, test_size=<span class="number">0.25</span>, random_state=<span class="number">33</span>)</span><br><span class="line"><span class="comment"># 采用 Z-Score 规范化 Z-Score 会将数值规范化为一个标准的正态分布，即均值为 0，方差为 1，数值会包含负数。</span></span><br><span class="line">ss = preprocessing.StandardScaler()</span><br><span class="line">train_ss_x = ss.fit_transform(train_x)</span><br><span class="line">test_ss_x = ss.transform(test_x)</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier()</span><br><span class="line">knn.fit(train_ss_x, train_y) </span><br><span class="line">predict_y = knn.predict(test_ss_x) </span><br><span class="line">print(<span class="string">"KNN 准确率: %.4lf"</span> % accuracy_score(predict_y, test_y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 SVM 分类器</span></span><br><span class="line">svm = SVC()</span><br><span class="line">svm.fit(train_ss_x, train_y)</span><br><span class="line">predict_y=svm.predict(test_ss_x)</span><br><span class="line">print(<span class="string">'SVM 准确率: %0.4lf'</span> % accuracy_score(predict_y, test_y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用 Min-Max 规范化</span></span><br><span class="line">mm = preprocessing.MinMaxScaler()</span><br><span class="line">train_mm_x = mm.fit_transform(train_x)</span><br><span class="line">test_mm_x = mm.transform(test_x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Naive Bayes 分类器</span></span><br><span class="line">mnb = MultinomialNB()</span><br><span class="line">mnb.fit(train_mm_x, train_y) </span><br><span class="line">predict_y = mnb.predict(test_mm_x) </span><br><span class="line">print(<span class="string">"多项式朴素贝叶斯准确率: %.4lf"</span> % accuracy_score(predict_y, test_y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 CART 决策树分类器</span></span><br><span class="line">dtc = DecisionTreeClassifier()</span><br><span class="line">dtc.fit(train_mm_x, train_y) </span><br><span class="line">predict_y = dtc.predict(test_mm_x) </span><br><span class="line">print(<span class="string">"CART 决策树准确率: %.4lf"</span> % accuracy_score(predict_y, test_y))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KNN 准确率: <span class="number">0.9756</span></span><br><span class="line">SVM 准确率: <span class="number">0.9867</span></span><br><span class="line">多项式朴素贝叶斯准确率: <span class="number">0.8844</span></span><br><span class="line">CART 决策树准确率: <span class="number">0.8600</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;KNN工作原理&quot;&gt;&lt;a href=&quot;#KNN工作原理&quot; class=&quot;headerlink&quot; title=&quot;KNN工作原理&quot;&gt;&lt;/a&gt;KNN工作原理&lt;/h1&gt;&lt;p&gt;近朱者赤，近墨者黑”可以说是 KNN 的工作原理。整个计算过程分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 使用SVM进行乳腺癌检测</title>
    <link href="https://joshuaqyh.github.io/2019/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/"/>
    <id>https://joshuaqyh.github.io/2019/02/18/机器学习-支持向量机SVM/</id>
    <published>2019-02-18T13:14:26.000Z</published>
    <updated>2019-02-23T19:50:32.826Z</updated>
    
    <content type="html"><![CDATA[<p>关于SVM其基础知识和原理已经在一篇文章中提及到了，戳<a href="https://joshuaqyh.github.io/2018/12/24/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">这里</a>。</p><p>本文主要是谈谈如何利用sklearn包中的SVM来进行乳腺癌的检测。</p><h1 id="在-sklearn中使用svm"><a href="#在-sklearn中使用svm" class="headerlink" title="在 sklearn中使用svm"></a>在 sklearn中使用svm</h1><p>通过以下语句即可完成一个SVM模型的创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分类模型</span></span><br><span class="line">classfier_model = svm.SVC(C = <span class="number">1.0</span>, kernel = <span class="string">'rbf'</span>, degree=<span class="number">3</span>, gamma=<span class="string">'auto'</span>)</span><br><span class="line"><span class="comment"># svm.LinearSVC 在数据线性可分时使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建回归模型</span></span><br><span class="line">regression_model = svm.SVR(kernel = <span class="string">'rbf'</span>, degree=<span class="number">3</span>, gamma = <span class="string">'auto'</span>)</span><br><span class="line"><span class="comment"># svm.LinearSVR 在数据线性可分时使用</span></span><br></pre></td></tr></table></figure><p>这里重点关注SVC 的构造函数：model = svm.SVC(kernel=‘rbf’, C=1.0, gamma=‘auto’)，这里有三个重要的参数 kernel、C 和 gamma。</p><ul><li><strong>kernel</strong>：代表核函数，默认为 rbf 高斯核函数，主要可选项有：</li></ul><ol><li>inear：线性核函数，在数据为线性可分时，运算速度快，效果好，无法处理线性不可分的数据。</li><li>poly：多项式核函数，可以将数据从低维空间映射到高维空间，但是参数较多，计算两大。</li><li>rbf：高斯核函数（默认），将样本映射到高维空间，但是相较于多项式核函数来说参数较少，性能不错。</li><li>sigmoid：sigmoid 核函数，当选用sigmoid，svm实现的时多层神经网络。</li></ol><ul><li><strong>C</strong>代表的是目标函数的惩罚系数，惩罚系数指的是分错样本时的惩罚程度。当 C 越大的时候，分类器的准确性越高，但同样容错率会越低，泛化能力会变差。相反，C 越小，泛化能力越强，但是准确性会降低。</li><li><strong>gamma</strong> 代表核函数的系数，默认为样本特征数的倒数，即 gamma = 1 / n_features。</li></ul><p>然后训练和预测的方式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.fit(train_X,train_y)</span><br><span class="line">model.predict(test_X)</span><br></pre></td></tr></table></figure><h1 id="使用SVM进行乳腺癌检测"><a href="#使用SVM进行乳腺癌检测" class="headerlink" title="使用SVM进行乳腺癌检测"></a>使用SVM进行乳腺癌检测</h1><p>首先必须确定的是，乳腺癌检测是一个分类问题。</p><p>检测存在两个过程：</p><p>数据准备阶段：</p><ol><li>数据加载：加载数据集；</li><li>数据清洗：删除无关的列，对列数据属性进行变换或者映射；</li><li>特征选择：一般是剔除无关特征，运用降维方式，用少量特征代表数据的特性，增强分类器的泛化能力，避免数据过拟合。</li><li>数据规范化：Z-score等等</li></ol><p>分类阶段：</p><ol><li>创建模型</li><li>训练模型</li><li>预测模型</li><li>评估模型</li></ol><p>整个过程的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">代码来自：https://github.com/cystanford?tab=repositories</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 加载数据集，你需要把数据放到目录中</span></span><br><span class="line">data = pd.read_csv(<span class="string">"./breast_cancer_data.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据探索</span></span><br><span class="line"><span class="comment"># 因为数据集中列比较多，我们需要把 dataframe 中的列全部显示出来</span></span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="keyword">None</span>)</span><br><span class="line">print(data.columns)</span><br><span class="line">print(data.head(<span class="number">5</span>))</span><br><span class="line">print(data.describe())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将特征字段分成 3 组</span></span><br><span class="line">features_mean= list(data.columns[<span class="number">2</span>:<span class="number">12</span>])</span><br><span class="line">features_se= list(data.columns[<span class="number">12</span>:<span class="number">22</span>])</span><br><span class="line">features_worst=list(data.columns[<span class="number">22</span>:<span class="number">32</span>])</span><br><span class="line"><span class="comment"># 数据清洗</span></span><br><span class="line"><span class="comment"># ID 列没有用，删除该列</span></span><br><span class="line">data.drop(<span class="string">"id"</span>,axis=<span class="number">1</span>,inplace=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 将 B 良性替换为 0，M 恶性替换为 1</span></span><br><span class="line">data[<span class="string">'diagnosis'</span>]=data[<span class="string">'diagnosis'</span>].map(&#123;<span class="string">'M'</span>:<span class="number">1</span>,<span class="string">'B'</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将肿瘤诊断结果可视化</span></span><br><span class="line">sns.countplot(data[<span class="string">'diagnosis'</span>],label=<span class="string">"Count"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 用热力图呈现 features_mean 字段之间的相关性</span></span><br><span class="line">corr = data[features_mean].corr()</span><br><span class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">14</span>))</span><br><span class="line"><span class="comment"># annot=True 显示每个方格的数据</span></span><br><span class="line">sns.heatmap(corr, annot=<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征选择</span></span><br><span class="line">features_remain = [<span class="string">'radius_mean'</span>,<span class="string">'texture_mean'</span>, <span class="string">'smoothness_mean'</span>,<span class="string">'compactness_mean'</span>,<span class="string">'symmetry_mean'</span>, <span class="string">'fractal_dimension_mean'</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽取 30% 的数据作为测试集，其余作为训练集</span></span><br><span class="line">train, test = train_test_split(data, test_size = <span class="number">0.3</span>)<span class="comment"># in this our main data is splitted into train and test</span></span><br><span class="line"><span class="comment"># 抽取特征选择的数值作为训练和测试数据</span></span><br><span class="line">train_X = train[features_remain]</span><br><span class="line">train_y=train[<span class="string">'diagnosis'</span>]</span><br><span class="line">test_X= test[features_remain]</span><br><span class="line">test_y =test[<span class="string">'diagnosis'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用 Z-Score 规范化数据，保证每个特征维度的数据均值为 0，方差为 1</span></span><br><span class="line">ss = StandardScaler()</span><br><span class="line">train_X = ss.fit_transform(train_X)</span><br><span class="line">test_X = ss.transform(test_X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line">classifier_model = svm.SVC(C = <span class="number">1.0</span>, kernel = <span class="string">'rbf'</span>, degree=<span class="number">3</span>, gamma=<span class="string">'auto'</span>)</span><br><span class="line">classifier_model.fit(train_X, train_y)</span><br><span class="line"></span><br><span class="line">prediction = classifier_model.predict(test_X)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"准确率： "</span>, metrics.accuracy_score(prediction, test_y))</span><br></pre></td></tr></table></figure><p>这是运行的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/a6/4d/a65435de48cee8091bd5f83d286ddb4d.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/73/d9/7351aa1ce3ab939f7ab609565e1f57d9.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>其中的<strong>特征选择问题</strong>：</p><p>热力图中对角线上的为单变量自身的相关系数是 1。颜色越浅代表相关性越大。所以你能看出来 radius_mean、perimeter_mean 和 area_mean 相关性非常大，compactness_mean、concavity_mean、concave_points_mean 这三个字段也是相关的，因此我们可以取其中的一个作为代表。</p><p>特征选择的目的是降维，用少量的特征代表数据的特性，这样也可以增强分类器的泛化能力，避免数据过拟合。</p><p>所以我们可以<strong>将相关性较强的一组特征视为一类，然后选出一个特征代表该类</strong>。</p><p>我们能看到 mean、se 和 worst 这三组特征是对同一组内容的不同度量方式，我们可以保留 mean 这组特征，在特征选择中忽略掉 se 和 worst。同时我们能看到 mean 这组特征中，radius_mean、perimeter_mean、area_mean 这三个属性相关性大，compactness_mean、daconcavity_mean、concave points_mean 这三个属性相关性大。我们分别从这 2 类中选择 1 个属性作为代表，比如 radius_mean 和 compactness_mean。</p><p>这样我们就可以把原来的 10 个属性缩减为 6 个属性，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features_remain = [<span class="string">'radius_mean'</span>,<span class="string">'texture_mean'</span>, <span class="string">'smoothness_mean'</span>,<span class="string">'compactness_mean'</span>,<span class="string">'symmetry_mean'</span>, <span class="string">'fractal_dimension_mean'</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于SVM其基础知识和原理已经在一篇文章中提及到了，戳&lt;a href=&quot;https://joshuaqyh.github.io/2018/12/24/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%9
      
    
    </summary>
    
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 朴素贝叶斯分类</title>
    <link href="https://joshuaqyh.github.io/2019/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/"/>
    <id>https://joshuaqyh.github.io/2019/02/18/机器学习-朴素贝叶斯分类/</id>
    <published>2019-02-18T11:27:58.000Z</published>
    <updated>2019-02-23T19:50:43.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贝叶斯原理"><a href="#贝叶斯原理" class="headerlink" title="贝叶斯原理"></a>贝叶斯原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>贝叶斯原理其实是在求解一个逆向概率的问题。</p><p>我们用一个题目来体会下：假设有一种病叫做“贝叶死”，它的发病率是万分之一，即 10000 人中会有 1 个人得病。现有一种测试可以检验一个人是否得病的准确率是 99.9%，它的误报率是 0.1%，那么现在的问题是，如果一个人被查出来患有“叶贝死”，实际上患有的可能性有多大？</p><p>你可能会想说，既然查出患有“贝叶死”的准确率是 99.9%，那是不是实际上患“贝叶死”的概率也是 99.9% 呢？实际上不是的。你自己想想，在 10000 个人中，还存在 0.1% 的误查的情况，也就是 10 个人没有患病但是被诊断成阳性。当然 10000 个人中，也确实存在一个患有贝叶死的人，他有 99.9% 的概率被检查出来。所以你可以粗算下，患病的这个人实际上是这 11 个人里面的一员，即实际患病比例是 1/11≈9%。</p><p>以上涉及了贝叶斯原理的几个核心概念：</p><ul><li>先验概率：通过经验来判断事情发生的概率，比如说“贝叶死”的发病率是万分之一，就是先验概率。再比如南方的梅雨季是 6-7 月，就是通过往年的气候总结出来的经验，这个时候下雨的概率就比其他时间高出很多。</li><li>后验概率：后验概率就是发生结果之后，推测原因的概率。比如说某人查出来了患有“贝叶死”，那么患病的原因可能是 A、B 或 C。患有“贝叶死”是因为原因 A 的概率就是后验概率。它是属于条件概率的一种。</li><li>条件概率：事件 A 在另外一个事件 B 已经发生条件下的发生概率，表示为 P(A|B)，读作“在 B 发生的条件下 A 发生的概率”。比如原因 A 的条件下，患有“贝叶死”的概率，就是条件概率。</li><li>联合概率：多个事件同时发生的概率。</li><li>联合分布：多个事件发生多个结果的概率分布情况。</li><li>似然函数：你可以把概率模型的训练过程理解为求参数估计的过程。举个例子，如果一个硬币在 10 次抛落中正面均朝上。那么你肯定在想，这个硬币是均匀的可能性是多少？这里硬币均匀就是个参数，似然函数就是用来衡量这个模型的参数。似然在这里就是可能性的意思，它是关于统计参数的函数。</li></ul><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a><strong>贝叶斯公式</strong></h2><p>一般的二元贝叶斯公式如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/31/5e/3163faf3b511e61408b46053aad7825e.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由此，我们可以得出通用的贝叶斯公式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/99/4b/99f0e50baffa2c572ea0db6c5df4474b.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>其实贝叶斯原理的可以通过条件概率公式来推理得到。</p><p>$P(Y|X)P(X)=P(X|Y)P(Y)=P(XY)P(Y|X)P(X)=P(X|Y)P(Y)=P(XY)$</p><p>放在实例中来观察贝叶斯公式的简单应用。在医疗诊断中，如果医生知道某一疾病发生某些症状的概率，那么可以利用贝叶斯公式估计得知当病人发生某症状时，推测病人发生某病的概率。</p><p>贝叶斯公式其实是反映了原因和结果之间的概率关系。</p><h1 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h1><p>朴素贝叶斯算法是一种简单但极为强大的预测建模算法。之所以称为朴素贝叶斯，<strong>是因为它假设每一个输入变量之间是独立的。</strong></p><p>朴素贝叶斯模型由两种类型的概率组成：</p><ol><li>每个<strong>类别的概率</strong>$P(C_j)$；</li><li>每个属性的<strong>条件概率</strong>$P(Ai|C_j)$。</li></ol><p>朴素贝叶斯的公式如下：</p><p>$P(Cause,Effect_1,Effect_2,Effect_3….Effect_n)=P(Cause)∏_nP(Effect_i|Cause)$</p><p>为了训练朴素贝叶斯模型，我们需要先给出训练数据，以及这些数据对应的分类。那么上面这两个概率，也就是类别概率和条件概率。他们都可以从给出的训练数据中计算出来。一旦计算出来，概率模型就可以使用贝叶斯原理对新数据进行预测。</p><h2 id="贝叶斯原理-贝叶斯分类-朴素贝叶斯之间的区别"><a href="#贝叶斯原理-贝叶斯分类-朴素贝叶斯之间的区别" class="headerlink" title="贝叶斯原理 贝叶斯分类 朴素贝叶斯之间的区别"></a>贝叶斯原理 贝叶斯分类 朴素贝叶斯之间的区别</h2><p>贝叶斯原理是最大的概念，它解决了概率论中“逆向概率”的问题，在这个理论基础上，人们设计出了贝叶斯分类器，朴素贝叶斯分类是贝叶斯分类器中的一种，也是最简单，最常用的分类器。朴素贝叶斯之所以朴素是因为它假设属性是相互独立的，因此对实际情况有所约束，如果属性之间存在关联，分类准确率会降低。不过好在对于大部分情况下，朴素贝叶斯的分类效果都不错。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/8d/fa/8d16d796670bb4901c7a4c13ca3aa1fa.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="朴素贝叶斯分类器工作流程"><a href="#朴素贝叶斯分类器工作流程" class="headerlink" title="朴素贝叶斯分类器工作流程"></a>朴素贝叶斯分类器工作流程</h2><p>朴素贝叶斯分类常用于文本分类，尤其是对于英文等语言来说，分类效果很好。它常用于垃圾文本过滤、情感预测、推荐系统等。</p><p>流程可以用下图表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/ac/3f/acd7a8e882bf0205f9b33c43fd61453f.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>从图片你也可以看出来，朴素贝叶斯分类器需要三个流程，我来给你一一讲解下这几个流程。</p><p><strong>第一阶段：准备阶段</strong></p><p>在这个阶段我们需要确定特征属性，比如上面案例中的“身高”、“体重”、“鞋码”等，并对每个特征属性进行适当划分，然后由人工对一部分数据进行分类，形成训练样本。</p><p>这一阶段是整个朴素贝叶斯分类中唯一需要人工完成的阶段，其质量对整个过程将有重要影响，分类器的质量很大程度上由特征属性、特征属性划分及训练样本质量决定。</p><p><strong>第二阶段：训练阶段</strong></p><p>这个阶段就是生成分类器，主要工作是计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率。</p><p>输入是特征属性和训练样本，输出是分类器。</p><p><strong>第三阶段：应用阶段</strong></p><p>这个阶段是使用分类器对新数据进行分类。输入是分类器和新数据，输出是新数据的分类结果。</p><h1 id="利用朴素贝叶斯进行文档分类"><a href="#利用朴素贝叶斯进行文档分类" class="headerlink" title="利用朴素贝叶斯进行文档分类"></a>利用朴素贝叶斯进行文档分类</h1><p>朴素贝叶斯分类最适合的场景就是<strong>文本分类、情感分析和垃圾邮件识别</strong>。其中情感分析和垃圾邮件识别都是通过文本来进行判断。从这里你能看出来，这三个场景本质上都是文本分类，这也是朴素贝叶斯最擅长的地方。所以朴素贝叶斯也常用于自然语言处理 NLP 的工具。</p><p>以下是高斯朴素贝叶斯分类器的类简单实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveBayes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求一组数据的数学期望，静态方法无需传入self</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mean</span><span class="params">(X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(X) / float(len(X))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求一组数据的标准差（方差）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stdev</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        avg = self.mean(X)</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum([pow(x-avg, <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> X]) / float(len(X)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 概率密度函数。正态分布函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gaussian_probability</span><span class="params">(self, x, mean, stdev)</span>:</span></span><br><span class="line">        exponent = math.exp(-(math.pow(x-mean,<span class="number">2</span>)/(<span class="number">2</span>*math.pow(stdev,<span class="number">2</span>))))</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> / (math.sqrt(<span class="number">2</span>*math.pi) * stdev)) * exponent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理X_train，得到均值和标准差</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summarize</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        summaries = [(self.mean(i), self.stdev(i)) <span class="keyword">for</span> i <span class="keyword">in</span> zip(*train_data)]</span><br><span class="line">        <span class="keyword">return</span> summaries</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分类别求出数学期望和标准差，然后拟合。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        labels = list(set(y))</span><br><span class="line">        data = &#123;label:[] <span class="keyword">for</span> label <span class="keyword">in</span> labels&#125;</span><br><span class="line">        <span class="keyword">for</span> f, label <span class="keyword">in</span> zip(X, y):</span><br><span class="line">            data[label].append(f)</span><br><span class="line">        self.model = &#123;label: self.summarize(value) <span class="keyword">for</span> label, value <span class="keyword">in</span> data.items()&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'gaussianNB train done!'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算概率</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_probabilities</span><span class="params">(self, input_data)</span>:</span></span><br><span class="line">        <span class="comment"># summaries:&#123;0.0: [(5.0, 0.37),(3.42, 0.40)], 1.0: [(5.8, 0.449),(2.7, 0.27)]&#125;</span></span><br><span class="line">        <span class="comment"># input_data:[1.1, 2.2]</span></span><br><span class="line">        probabilities = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> label, value <span class="keyword">in</span> self.model.items():</span><br><span class="line">            probabilities[label] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                mean, stdev = value[i]</span><br><span class="line">                probabilities[label] *= self.gaussian_probability(input_data[i], mean, stdev)</span><br><span class="line">        <span class="keyword">return</span> probabilities</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类别</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_test)</span>:</span></span><br><span class="line">        <span class="comment"># &#123;0.0: 2.9680340789325763e-27, 1.0: 3.5749783019849535e-26&#125;</span></span><br><span class="line">        label = sorted(self.calculate_probabilities(X_test).items(), key=<span class="keyword">lambda</span> x: x[<span class="number">-1</span>])[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self，X_test, y_test)</span>:</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> zip(X_test, y_test):</span><br><span class="line">            label = self.predict(X)</span><br><span class="line">            <span class="keyword">if</span> label == y:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right / float(len(X_test))</span><br></pre></td></tr></table></figure><p>此外，我们直接使用 sklearn 机器学习包来帮助我们使用朴素贝叶斯分类算法。</p><h2 id="sklearn-机器学习包"><a href="#sklearn-机器学习包" class="headerlink" title="sklearn 机器学习包"></a>sklearn 机器学习包</h2><p>sklearn 的全称叫 Scikit-learn，它给我们提供了 3 个朴素贝叶斯分类算法，分别是高斯朴素贝叶斯（GaussianNB）、多项式朴素贝叶斯（MultinomialNB）和伯努利朴素贝叶斯（BernoulliNB）。</p><p>这三种算法适合应用在不同的场景下，我们应该根据特征变量的不同选择不同的算法：</p><p><strong>高斯朴素贝叶斯</strong>：特征变量是连续变量，符合高斯分布，比如说人的身高，物体的长度。</p><p><strong>多项式朴素贝叶斯</strong>：特征变量是离散变量，符合多项分布，在文档分类中特征变量体现在一个单词出现的次数，或者是单词的 TF-IDF 值等。</p><p><strong>伯努利朴素贝叶斯</strong>：特征变量是布尔变量，符合 0/1 分布，在文档分类中特征是单词是否出现。</p><p>伯努利朴素贝叶斯是以文件为粒度，如果该单词在某文件中出现了即为 1，否则为 0。而多项式朴素贝叶斯是以单词为粒度，会计算在某个文件中的具体次数。而高斯朴素贝叶斯适合处理特征变量是连续变量，且符合正态分布（高斯分布）的情况。比如身高、体重这种自然界的现象就比较适合用高斯朴素贝叶斯来处理。而文本分类是使用多项式朴素贝叶斯或者伯努利朴素贝叶斯。</p><h3 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h3><p>TF-IDF 实际上是两个词组 Term Frequency 和 Inverse Document Frequency 的总称，两者缩写为 TF 和 IDF，分别代表了词频和逆向文档频率。</p><p><strong>词频 TF</strong>计算了一个单词在文档中出现的次数，它认为一个单词的重要性和它在文档中出现的次数呈正比。</p><p><strong>逆向文档频率 IDF</strong>，是指一个单词在文档中的区分度。它认为一个单词出现在的文档数越少，就越能通过这个单词把该文档和其他文档区分开。IDF 越大就代表该单词的区分度越大。</p><p><strong>所以 TF-IDF 实际上是词频 TF 和逆向文档频率 IDF 的乘积</strong>。这样我们倾向于找到 TF 和 IDF 取值都高的单词作为区分，<strong>即这个单词在一个文档中出现的次数多，同时又很少出现在其他文档中。这样的单词适合用于分类</strong>。</p><p>首先我们看下词频 TF 和逆向文档概率 IDF 的公式。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/bc/4d/bc31ff1f31f9cd26144404221f705d4d.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/b7/65/b7ad53560f61407e6964e7436da14365.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>为什么 IDF 的分母中，单词出现的文档数要加 1 呢？因为有些单词可能不会存在文档中，为了避免分母为 0，统一给单词出现的文档数都加 1。</p><p><strong>TF-IDF=TF*IDF。</strong></p><p>你可以看到，TF-IDF 值就是 TF 与 IDF 的乘积, 这样可以更准确地对文档进行分类。比如“我”这样的高频单词，虽然 TF 词频高，但是 IDF 值很低，整体的 TF-IDF 也不高。</p><p>我在这里举个例子。假设一个文件夹里一共有 10 篇文档，其中一篇文档有 1000 个单词，“this”这个单词出现 20 次，“bayes”出现了 5 次。“this”在所有文档中均出现过，而“bayes”只在 2 篇文档中出现过。我们来计算一下这两个词语的 TF-IDF 值。</p><p>针对“this”，计算 TF-IDF 值：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/63/12/63abe3ce8aa0ea4a78ba537b5504df12.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/b5/7e/b5ac88c4e2a71cc2d4ceef4c01e0ba7e.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>所以 TF-IDF=0.02*(-0.0414)=-8.28e-4。</p><p>针对“bayes”，计算 TF-IDF 值：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/3b/8d/3bbe56a7b76513604bfe6b39b890dd8d.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/1e/2e/1e8b7465b9949fe071e95aede172a52e.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>TF-IDF=0.005*0.5229=2.61e-3。</p><p>很明显“bayes”的 TF-IDF 值要大于“this”的 TF-IDF 值。这就说明用“bayes”这个单词做区分比单词“this”要好。</p><h3 id="使用sklearn-来计算-TF-IDF"><a href="#使用sklearn-来计算-TF-IDF" class="headerlink" title="使用sklearn 来计算 TF-IDF"></a>使用sklearn 来计算 TF-IDF</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a object to calculate TF-IDF</span></span><br><span class="line"><span class="comment"># TfidfVectorizer(stop_words=stop_words, token_pattern=token_pattern)</span></span><br><span class="line"><span class="comment"># * stop_words 指的是：在分类中没有用的单词，对分类起不到作用，减少计算浪费。</span></span><br><span class="line"><span class="comment"># * token_pattern 使用正则表达式定义过滤规则</span></span><br><span class="line"></span><br><span class="line">tfidf_vec = TfidfVectorizer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># the fitting data</span></span><br><span class="line">documents = [</span><br><span class="line">    <span class="string">'this is the bayes document'</span>,</span><br><span class="line">    <span class="string">'this is the second second document'</span>,</span><br><span class="line">    <span class="string">'and the third one'</span>,</span><br><span class="line">    <span class="string">'is this the document'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># calcualte TF-IDF，拟合模型，返回TF—IDF计算结果矩阵。</span></span><br><span class="line">tfidf_matrix = tfidf_vec.fit_transform(documents)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'不重复的词:'</span>, tfidf_vec.get_feature_names())</span><br><span class="line">print(<span class="string">'每个单词的 ID:'</span>, tfidf_vec.vocabulary_)</span><br><span class="line">print(<span class="string">'每个单词的 tfidf 值:'</span>, tfidf_matrix.toarray())</span><br></pre></td></tr></table></figure><h2 id="对文档进行分类"><a href="#对文档进行分类" class="headerlink" title="对文档进行分类"></a>对文档进行分类</h2><p>如果我们要对文档进行分类，有两个重要的阶段：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/25/c3/257e01f173e8bc78b37b71b2358ff7c3.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><ol><li><strong>基于分词的数据准备</strong>，包括分词、单词权重计算、去掉停用词；</li><li><strong>应用朴素贝叶斯分类进行分类</strong>，首先通过训练集得到朴素贝叶斯分类器，然后将分类器应用于测试集，并与实际结果做对比，最终得到测试集的分类准确率。</li></ol><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>在准备阶段，分词是比较重要的一个环节。在英文文档中分词的工具为NLTK包，而中文文档则是使用了 jieba包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">word_list = nltk.word_tokenize(text) <span class="comment"># 分词</span></span><br><span class="line">nltk.pos_tag(word_list) <span class="comment"># 标注单词的词性</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">word_list = jieba.cut (text) <span class="comment"># 中文分词</span></span><br></pre></td></tr></table></figure><h3 id="加载停用词表"><a href="#加载停用词表" class="headerlink" title="加载停用词表"></a>加载停用词表</h3><p>我们需要自己读取停用词表文件，从网上可以找到中文常用的停用词保存在 stop_words.txt，然后利用 Python 的文件读取函数读取文件，保存在 stop_words 数组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_words = [line.strip().decode(<span class="string">'utf-8'</span>) <span class="keyword">for</span> line <span class="keyword">in</span> io.open(<span class="string">'stop_words.txt'</span>).readlines()]</span><br></pre></td></tr></table></figure><h3 id="计算单词的权重-TF-IDF"><a href="#计算单词的权重-TF-IDF" class="headerlink" title="计算单词的权重 TF-IDF"></a>计算单词的权重 TF-IDF</h3><p>直接创建 TfidfVectorizer 类，然后使用 fit_transform 方法进行拟合，得到 TF-IDF 特征空间 features，你可以理解为选出来的分词就是特征。我们计算这些特征在文档上的特征向量，得到特征空间 features。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tf = TfidfVectorizer(stop_words=stop_words, max_df=<span class="number">0.5</span>)</span><br><span class="line">features = tf.fit_transform(train_contents)</span><br></pre></td></tr></table></figure><p>这里 max_df 参数用来描述单词在文档中的最高出现率。假设 max_df=0.5，代表一个单词在 50% 的文档中都出现过了，那么它只携带了非常少的信息，因此就不作为分词统计。</p><h3 id="生成朴素贝叶斯分类器"><a href="#生成朴素贝叶斯分类器" class="headerlink" title="生成朴素贝叶斯分类器"></a>生成朴素贝叶斯分类器</h3><p>我们将特征训练集的特征空间 train_features，以及训练集对应的分类 train_labels 传递给贝叶斯分类器 clf，它会自动生成一个符合特征空间和对应分类的分类器。</p><p>这里我们采用的是多项式贝叶斯分类器，其中 alpha 为平滑参数。为什么要使用平滑呢？因为如果一个单词在训练样本中没有出现，这个单词的概率就会被计算为 0。但训练集样本只是整体的抽样情况，我们不能因为一个事件没有观察到，就认为整个事件的概率为 0。为了解决这个问题，我们需要做平滑处理。</p><p>当 alpha=1 时，使用的是 Laplace 平滑。Laplace 平滑就是采用加 1 的方式，来统计没有出现过的单词的概率。这样当训练样本很大的时候，加 1 得到的概率变化可以忽略不计，也同时避免了零概率的问题。</p><p>当 0&lt;alpha&lt;1 时，使用的是 Lidstone 平滑。对于 Lidstone 平滑来说，alpha 越小，迭代次数越多，精度越高。我们可以设置 alpha 为 0.001。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多项式贝叶斯分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB  <span class="comment"># GuassianNB BernoulliNB</span></span><br><span class="line">clf = MultinomialNB(alpha=<span class="number">0.001</span>).fit(train_features, train_labels)</span><br></pre></td></tr></table></figure><h3 id="使用生成的分类器做预测"><a href="#使用生成的分类器做预测" class="headerlink" title="使用生成的分类器做预测"></a>使用生成的分类器做预测</h3><p>首先我们需要得到测试集的特征矩阵。</p><p>方法是用训练集的分词创建一个 TfidfVectorizer 类，使用同样的 stop_words 和 max_df，然后用这个 TfidfVectorizer 类对测试集的内容进行 fit_transform 拟合，得到测试集的特征矩阵 test_features。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_tf = TfidfVectorizer(stop_words=stop_words, max_df=<span class="number">0.5</span>, vocabulary=train_vocabulary)</span><br><span class="line">test_features=test_tf.fit_transform(test_contents)</span><br></pre></td></tr></table></figure><p>然后我们用训练好的分类器对新数据做预测。</p><p>方法是使用 predict 函数，传入测试集的特征矩阵 test_features，得到分类结果 predicted_labels。predict 函数做的工作就是求解所有后验概率并找出最大的那个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predicted_labels=clf.predict(test_features)</span><br></pre></td></tr></table></figure><h3 id="计算准确率"><a href="#计算准确率" class="headerlink" title="计算准确率"></a>计算准确率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">print</span> metrics.accuracy_score(test_labels, predicted_labels)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;贝叶斯原理&quot;&gt;&lt;a href=&quot;#贝叶斯原理&quot; class=&quot;headerlink&quot; title=&quot;贝叶斯原理&quot;&gt;&lt;/a&gt;贝叶斯原理&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;
      
    
    </summary>
    
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 决策树</title>
    <link href="https://joshuaqyh.github.io/2019/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://joshuaqyh.github.io/2019/02/18/机器学习-决策树/</id>
    <published>2019-02-18T02:18:21.000Z</published>
    <updated>2019-02-23T20:04:12.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树的工作原理"><a href="#决策树的工作原理" class="headerlink" title="决策树的工作原理"></a>决策树的工作原理</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>决策树就是根据已有的规则条件进行评判，给出决策结果。</p><p>一棵决策树一般包括根结点，内部结点，和叶节点。根结点是一开始的判断条件，内部结点是中间过程的判断条件，而叶结点则对应着决策结果。</p><p>使用决策树时一般会经历两个阶段：构造和剪枝。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/dc/90/dca4224b342894f12f54a9cb41d8cd90.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>决策树的构造过程就是选择什么样的属性作为决策结点的过程。我们需要经过计算合理构造节点之间的关系。</p><p>在构造过程中，要解决三个重要的问题：</p><ol><li><p>选择哪个属性作为根节点；</p></li><li><p>选择哪些属性作为子节点；</p></li><li><p>什么时候停止并得到目标状态，即叶节点。</p><p>​</p></li></ol><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>剪枝相当于给决策瘦身，避免了许多无谓的决策判断，尤其在处理大型决策树的时候，剪枝尤为必要。同时这么做，也是为了防止过拟合的现象产生。</p><p>“过拟合”指的就是模型的训练结果“太好了”，以至于在实际应用的过程中，会存在“死板”的情况，导致分类错误。</p><p>造成过拟合的原因之一就是因为训练集中样本量较小。如果决策树选择的属性过多，构造出来的决策树一定能够“完美”地把训练集中的样本分类，但是这样就会<strong>把训练集中一些数据的特点当成所有数据的特点，但这个特点不一定是全部数据的特点</strong>，这就使得这个决策树在真实的数据分类中出现错误，也就是模型的“泛化能力”差。</p><p>泛化能力指的分类器是通过训练集抽象出来的分类能力，你也可以理解是举一反三的能力。如果我们太依赖于训练集的数据，那么得到的决策树容错率就会比较低，泛化能力差。因为训练集只是全部数据的抽样，并不能体现全部数据的特点。</p><p><strong>剪枝的方法</strong></p><ol><li>预剪枝（pre-pruning）</li><li>后剪枝（post-pruning)</li></ol><p>预剪枝就是在<strong>决策树开始构造</strong>的时候就进行剪枝，方法是在构造的过程中对节点进行评估，如果对某个节点进行划分，在验证集中就不能带来准确性的提升，那么对该节点就没有必要进行划分，此时就将当前节点视为叶节点。</p><p>后剪枝就是在<strong>生成决策树之后</strong>再进行剪枝，通常会从决策树的叶节点开始，逐层向上对每个节点进行评估。如果剪掉这个节点子树，与保留该节点子树在分类准确性上差别不大，或者剪掉该节点子树，能在验证集中带来准确性的提升，那么就可以把该节点子树进行剪枝。方法是：用这个节点子树的叶子节点来替代该节点，类标记为这个节点子树中最频繁的那个类。</p><h1 id="决策树构造指标"><a href="#决策树构造指标" class="headerlink" title="决策树构造指标"></a>决策树构造指标</h1><p>如何构造一个根据天气情况来判断是否去打篮球的决策树？以下是一个简单的数据集。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/32/07/327eafa4a33e3e76ca86ac59195c0307.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接下来进行简单的构造，我们必须思考以下问题：</p><ol><li>哪个属性划分效果做好，作为根节点？</li><li>哪些属性作为后继节点？</li><li>什么时候停止划分，得到叶节点？</li></ol><p>我们使用信息熵（entropy）来作为划分的指标，它表示了信息的不确定性。我们假设随机变量 $I$ 具有值 $i$，$i$ 的概率为$p_i$。</p><p>信息熵的数学公式如下：$H(x) = - \sum_{i =1}^{n} p_i log_2p_i$</p><p>同样还有其他信息指标：</p><ul><li><p>conditional entropy（条件熵）: $H(X|Y)=\sum{P(X|Y)}\log_2{P(X|Y)}$</p></li><li><p>information gain（信息增益） : $g(D, A)=H(D)-H(D|A)$</p></li><li><p>information gain ratio（信息增益比）: $g_R(D, A) = \frac{g(D,A)}{H(A)}$</p></li><li><p>gini index（基尼指数）:$Gini(D)=\sum_{k=1}^{K}p_k\log{p_k}=1-\sum_{k=1}^{K}p_k^2$</p></li></ul><p>信息增益越大越好，分类更正确</p><p>信息增益越大，信息给你带来的混乱程度越小。</p><p>信息论中熵越大，混乱程度越大，信息量越小，信息增益更小。</p><p>故信息增益越大的特征，在决策树上的越高。</p><p>存在多种决策树：</p><ul><li>ID3 决策树 （基于信息增益划分）</li><li>C4.5 决策树（基于信息增益比）</li><li>CART 决策树 （基尼指数 ）</li></ul><p>ID3算法简单，但解释性强，但存在缺陷，有些属性对分类任务没有太大作用，但是依旧有可能被选为最优属性。</p><p>在针对ID3算法，做了改进，于是又了C4.5算法。在 C4.5 中，会在决策树构造之后采用悲观剪枝（PEP），这样可以提升决策树的泛化能力。</p><p>悲观剪枝是后剪枝技术中的一种，通过递归估算每个内部节点的分类错误率，比较剪枝前后这个节点的分类错误率来决定是否对其进行剪枝。这种剪枝方法不再需要一个单独的测试数据集。</p><p>C4.5 可以处理连续属性的情况，对连续的属性进行离散化的处理。比如打篮球存在的“湿度”属性，不按照“高、中”划分，而是按照湿度值进行计算，那么湿度取什么值都有可能。该怎么选择这个阈值呢，<strong>C4.5 选择具有最高信息增益的划分所对应的阈值</strong>。</p><p>C4.5 在 ID3 的基础上，用信息增益率代替了信息增益，解决了噪声敏感的问题，并且可以对构造树进行剪枝、处理连续数值以及数值缺失等情况，但是由于 C4.5 需要对数据集进行多次扫描，算法效率相对较低。</p><h1 id="决策树构造代码"><a href="#决策树构造代码" class="headerlink" title="决策树构造代码"></a>决策树构造代码</h1> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义节点类 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root=True, label=None, feature_name=None, feature=None)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line">        self.label = label</span><br><span class="line">        self.feature_name = feature_name</span><br><span class="line">        self.feature = feature</span><br><span class="line">        self.tree = &#123;&#125;</span><br><span class="line">        self.result = &#123;<span class="string">'label:'</span>: self.label, <span class="string">'feature'</span>: self.feature, <span class="string">'tree'</span>: self.tree&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;'</span>.format(self.result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span><span class="params">(self, val, node)</span>:</span></span><br><span class="line">        self.tree[val] = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, features)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">return</span> self.label</span><br><span class="line">        <span class="keyword">return</span> self.tree[features[self.feature]].predict(features)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, epsilon=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        self._tree = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 熵</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_ent</span><span class="params">(datasets)</span>:</span></span><br><span class="line">        data_length = len(datasets)</span><br><span class="line">        label_count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(data_length):</span><br><span class="line">            label = datasets[i][<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> label_count:</span><br><span class="line">                label_count[label] = <span class="number">0</span></span><br><span class="line">            label_count[label] += <span class="number">1</span></span><br><span class="line">        ent = -sum([(p/data_length)*log(p/data_length, <span class="number">2</span>) <span class="keyword">for</span> p <span class="keyword">in</span> label_count.values()])</span><br><span class="line">        <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 经验条件熵</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cond_ent</span><span class="params">(self, datasets, axis=<span class="number">0</span>)</span>:</span></span><br><span class="line">        data_length = len(datasets)</span><br><span class="line">        feature_sets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(data_length):</span><br><span class="line">            feature = datasets[i][axis]</span><br><span class="line">            <span class="keyword">if</span> feature <span class="keyword">not</span> <span class="keyword">in</span> feature_sets:</span><br><span class="line">                feature_sets[feature] = []</span><br><span class="line">            feature_sets[feature].append(datasets[i])</span><br><span class="line">        cond_ent = sum([(len(p)/data_length)*self.calc_ent(p) <span class="keyword">for</span> p <span class="keyword">in</span> feature_sets.values()])</span><br><span class="line">        <span class="keyword">return</span> cond_ent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 信息增益</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_gain</span><span class="params">(ent, cond_ent)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ent - cond_ent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_gain_train</span><span class="params">(self, datasets)</span>:</span></span><br><span class="line">        count = len(datasets[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        ent = self.calc_ent(datasets)</span><br><span class="line">        best_feature = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(count):</span><br><span class="line">            c_info_gain = self.info_gain(ent, self.cond_ent(datasets, axis=c))</span><br><span class="line">            best_feature.append((c, c_info_gain))</span><br><span class="line">        <span class="comment"># 比较大小</span></span><br><span class="line">        best_ = max(best_feature, key=<span class="keyword">lambda</span> x: x[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> best_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        input:数据集D(DataFrame格式)，特征集A，阈值eta</span></span><br><span class="line"><span class="string">        output:决策树T</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _, y_train, features = train_data.iloc[:, :<span class="number">-1</span>], train_data.iloc[:, <span class="number">-1</span>], train_data.columns[:<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 1,若D中实例属于同一类Ck，则T为单节点树，并将类Ck作为结点的类标记，返回T</span></span><br><span class="line">        <span class="keyword">if</span> len(y_train.value_counts()) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="keyword">True</span>,</span><br><span class="line">                        label=y_train.iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2, 若A为空，则T为单节点树，将D中实例树最大的类Ck作为该节点的类标记，返回T</span></span><br><span class="line">        <span class="keyword">if</span> len(features) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="keyword">True</span>, label=y_train.value_counts().sort_values(ascending=<span class="keyword">False</span>).index[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3,计算最大信息增益 同5.1,Ag为信息增益最大的特征</span></span><br><span class="line">        max_feature, max_info_gain = self.info_gain_train(np.array(train_data))</span><br><span class="line">        max_feature_name = features[max_feature]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4,Ag的信息增益小于阈值eta,则置T为单节点树，并将D中是实例数最大的类Ck作为该节点的类标记，返回T</span></span><br><span class="line">        <span class="keyword">if</span> max_info_gain &lt; self.epsilon:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="keyword">True</span>, label=y_train.value_counts().sort_values(ascending=<span class="keyword">False</span>).index[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5,构建Ag子集</span></span><br><span class="line">        node_tree = Node(root=<span class="keyword">False</span>, feature_name=max_feature_name, feature=max_feature)</span><br><span class="line"></span><br><span class="line">        feature_list = train_data[max_feature_name].value_counts().index</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> feature_list:</span><br><span class="line">            sub_train_df = train_data.loc[train_data[max_feature_name] == f].drop([max_feature_name], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 6, 递归生成树</span></span><br><span class="line">            sub_tree = self.train(sub_train_df)</span><br><span class="line">            node_tree.add_node(f, sub_tree)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pprint.pprint(node_tree.tree)</span></span><br><span class="line">        <span class="keyword">return</span> node_tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        self._tree = self.train(train_data)</span><br><span class="line">        <span class="keyword">return</span> self._tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_test)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._tree.predict(X_test)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">datasets, labels = create_data()</span><br><span class="line">data_df = pd.DataFrame(datasets, columns=labels)</span><br><span class="line">dt = DTree()</span><br><span class="line">tree = dt.fit(data_df)</span><br></pre></td></tr></table></figure><h1 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h1><p>我们使用CART算法来生成一个分类回归决策树。ID3 和 C4.5算法可以生成多叉树，但是CART只支持二叉树。</p><p>分类树可以处理离散数据，也就是数据种类有限的数据，它输出的是样本的类别，而回归树可以对连续型的数值进行预测，也就是数据在某个区间内都有取值的可能，它输出的是一个数值。</p><p>我们使用基尼系数 来对样本进行划分。基尼系数越小，越稳定。</p><p>假设 t 为节点，那么该节点的 GINI 系数的计算公式为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/f9/89/f9bb4cce5b895499cabc714eb372b089.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>这里 p(Ck|t) 表示节点 t 属于类别 Ck 的概率，节点 t 的基尼系数为 1 减去各类别 Ck 概率平方和。</p><p>通过下面这个例子，我们计算一下两个集合的基尼系数分别为多少：</p><p>集合 1：6 个都去打篮球；</p><p>集合 2：3 个去打篮球，3 个不去打篮球。</p><p>针对集合 1，所有人都去打篮球，所以 p(Ck|t)=1，因此 GINI(t)=1-1=0。</p><p>针对集合 2，有一半人去打篮球，而另一半不去打篮球，所以，p(C1|t)=0.5，p(C2|t)=0.5，GINI(t)=1-（0.5<em>0.5+0.5</em>0.5）=0.5。</p><p>通过两个基尼系数你可以看出，集合 1 的基尼系数最小，也证明样本最稳定，而集合 2 的样本不稳定性更大。</p><p>在 CART 算法中，基于基尼系数对特征属性进行二元分裂。</p><p>假设属性 A 将节点 D 划分成了 D1 和 D2，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/69/9a/69a90a43146898150a0de0811c6fef9a.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>节点 D 的基尼系数等于子节点 D1 和 D2 的归一化基尼系数之和，用公式表示为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/10/1e/107fed838cb75df62eb149499db20c1e.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>归一化基尼系数代表的是每个子节点的基尼系数乘以该节点占整体父亲节点 D 中的比例。</p><h3 id="分类决策树"><a href="#分类决策树" class="headerlink" title="分类决策树"></a>分类决策树</h3><p>我们使用python中的 sklearn库来完成CART分类决策树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">iris=load_iris()</span><br><span class="line"><span class="comment"># 获取特征集和分类标识</span></span><br><span class="line">features = iris.data</span><br><span class="line">labels = iris.target</span><br><span class="line"><span class="comment"># 随机抽取 33% 的数据作为测试集，其余为训练集</span></span><br><span class="line">train_features, test_features, train_labels, test_labels = train_test_split(features, labels, test_size=<span class="number">0.33</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建 CART 分类树</span></span><br><span class="line">clf = DecisionTreeClassifier(criterion=<span class="string">'gini'</span>)</span><br><span class="line"><span class="comment"># 拟合构造 CART 分类树</span></span><br><span class="line">clf = clf.fit(train_features, train_labels)</span><br><span class="line"><span class="comment"># 用 CART 分类树做预测</span></span><br><span class="line">test_predict = clf.predict(test_features)</span><br><span class="line"><span class="comment"># 预测结果与测试集结果作比对</span></span><br><span class="line">score = accuracy_score(test_labels, test_predict)</span><br><span class="line">print(<span class="string">"CART 分类树准确率 %.4lf"</span> % score)</span><br></pre></td></tr></table></figure><h3 id="回归决策树"><a href="#回归决策树" class="headerlink" title="回归决策树"></a>回归决策树</h3><p>CART 回归树划分数据集的过程和分类树的过程是一样的，只是回归树得到的预测结果是连续值，而且评判“不纯度”的指标不同。在 CART 分类树中采用的是基尼系数作为标准，那么在 CART 回归树中，如何评价“不纯度”呢？实际上我们要根据样本的混乱程度，也就是样本的离散程度来评价“不纯度”。</p><p>样本的离散程度具体的计算方式是，先计算所有样本的均值，然后计算每个样本值到均值的差值。我们假设 x 为样本的个体，均值为 u。为了统计样本的离散程度，我们可以取差值的绝对值，或者方差。</p><p>其中差值的绝对值为样本值减去样本均值的绝对值：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/6f/97/6f9677a70b1edff85e9e467f3e52bd97.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>方差为每个样本值减去样本均值的平方和除以样本个数：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/04/c1/045fd5afb7b53f17a8accd6f337f63c1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>所以<strong>这两种节点划分的标准，分别对应着两种目标函数最优化的标准，即用最小绝对偏差（LAD），或者使用最小二乘偏差（LSD）</strong>。这两种方式都可以让我们找到节点划分的方法，通常使用最小二乘偏差的情况更常见一些。</p><p>我们可以通过一个例子来看下如何创建一棵 CART 回归树来做预测。</p><p>这里我们使用到 sklearn 自带的波士顿房价数据集，该数据集给出了影响房价的一些指标，比如犯罪率，房产税等，最后给出了房价。</p><p>根据这些指标，我们使用 CART 回归树对波士顿房价进行预测，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score,mean_absolute_error,mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">boston=load_boston()</span><br><span class="line"><span class="comment"># 探索数据</span></span><br><span class="line">print(boston.feature_names)</span><br><span class="line"><span class="comment"># 获取特征集和房价</span></span><br><span class="line">features = boston.data</span><br><span class="line">prices = boston.target</span><br><span class="line"><span class="comment"># 随机抽取 33% 的数据作为测试集，其余为训练集</span></span><br><span class="line">train_features, test_features, train_price, test_price = train_test_split(features, prices, test_size=<span class="number">0.33</span>)</span><br><span class="line"><span class="comment"># 创建 CART 回归树</span></span><br><span class="line">dtr=DecisionTreeRegressor()</span><br><span class="line"><span class="comment"># 拟合构造 CART 回归树</span></span><br><span class="line">dtr.fit(train_features, train_price)</span><br><span class="line"><span class="comment"># 预测测试集中的房价</span></span><br><span class="line">predict_price = dtr.predict(test_features)</span><br><span class="line"><span class="comment"># 测试集的结果评价</span></span><br><span class="line">print(<span class="string">'回归树二乘偏差均值:'</span>, mean_squared_error(test_price, predict_price))</span><br><span class="line">print(<span class="string">'回归树绝对值偏差均值:'</span>, mean_absolute_error(test_price, predict_price))</span><br></pre></td></tr></table></figure><h2 id="CART-决策树的剪枝"><a href="#CART-决策树的剪枝" class="headerlink" title="CART 决策树的剪枝"></a>CART 决策树的剪枝</h2><p>CART 决策树的剪枝主要采用的是 CCP 方法，它是一种后剪枝的方法，英文全称叫做 cost-complexity prune，中文叫做代价复杂度。这种剪枝方式用到一个指标叫做节点的表面误差率增益值，以此作为剪枝前后误差的定义。用公式表示则是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/6b/95/6b9735123d45e58f0b0afc7c3f68cd95.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>其中 Tt 代表以 t 为根节点的子树，C(Tt) 表示节点 t 的子树没被裁剪时子树 Tt 的误差，C(t) 表示节点 t 的子树被剪枝后节点 t 的误差，|Tt|代子树 Tt 的叶子数，剪枝后，T 的叶子数减少了|Tt|-1。</p><p>所以节点的表面误差率增益值等于节点 t 的子树被剪枝后的误差变化除以剪掉的叶子数量。</p><p>因为我们希望剪枝前后误差最小，所以我们要寻找的就是最小α值对应的节点，把它剪掉。这时候生成了第一个子树。重复上面的过程，继续剪枝，直到最后只剩下根节点，即为最后一个子树。</p><p>得到了剪枝后的子树集合后，我们需要用验证集对所有子树的误差计算一遍。可以通过计算每个子树的基尼指数或者平方误差，取误差最小的那个树，得到我们想要的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树的工作原理&quot;&gt;&lt;a href=&quot;#决策树的工作原理&quot; class=&quot;headerlink&quot; title=&quot;决策树的工作原理&quot;&gt;&lt;/a&gt;决策树的工作原理&lt;/h1&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="数据分析" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>10 个 python可视化实例 | matplotlib &amp; seaborn</title>
    <link href="https://joshuaqyh.github.io/2019/02/17/python%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E4%BE%8B-matplotlib-seaborn/"/>
    <id>https://joshuaqyh.github.io/2019/02/17/python可视化实例-matplotlib-seaborn/</id>
    <published>2019-02-17T09:08:32.000Z</published>
    <updated>2019-02-17T09:43:58.052Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 10 种常用且易于上手的可视化方法，基于python3.7实现。主要使用了两个图形可视化库，matplotlib &amp; seaborn。这两个库的图形效果有细微差别，matplotlib较为流行且支持的可视化图形较多，seaborn也有特有的图形效果，二者搭配使用较佳。</p><p>以下提供10种方式的可视化供参考和上手！简单给出示例代码和效果图。</p><p>只要记住API的调用方式就能迅速掌握了！</p><h1 id="1-散点图-scatter"><a href="#1-散点图-scatter" class="headerlink" title="1. 散点图 scatter"></a>1. 散点图 scatter</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line">x = np.random.randn(N)</span><br><span class="line">y = np.random.randn(N)</span><br><span class="line"><span class="comment"># 用 Matplotlib 画散点图</span></span><br><span class="line">plt.scatter(x, y,marker=<span class="string">'x'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 用 Seaborn 画散点图</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'x'</span>: x, <span class="string">'y'</span>: y&#125;)</span><br><span class="line">sns.jointplot(x=<span class="string">"x"</span>, y=<span class="string">"y"</span>, data=df, kind=<span class="string">'scatter'</span>);</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217171619.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="2-折线图-plot"><a href="#2-折线图-plot" class="headerlink" title="2. 折线图 plot"></a>2. 折线图 plot</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">x = [<span class="number">2010</span>, <span class="number">2011</span>, <span class="number">2012</span>, <span class="number">2013</span>, <span class="number">2014</span>, <span class="number">2015</span>, <span class="number">2016</span>, <span class="number">2017</span>, <span class="number">2018</span>, <span class="number">2019</span>]</span><br><span class="line">y = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">35</span>]</span><br><span class="line"><span class="comment"># 使用 Matplotlib 画折线图</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 使用 Seaborn 画折线图</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'x'</span>: x, <span class="string">'y'</span>: y&#125;)</span><br><span class="line">sns.lineplot(x=<span class="string">"x"</span>, y=<span class="string">"y"</span>, data=df)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217171842.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="3-直方图-histogram"><a href="#3-直方图-histogram" class="headerlink" title="3. 直方图 histogram"></a>3. 直方图 histogram</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">a = np.random.randn(<span class="number">100</span>)</span><br><span class="line">s = pd.Series(a) </span><br><span class="line"><span class="comment"># 用 Matplotlib 画直方图</span></span><br><span class="line">plt.hist(s)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 用 Seaborn 画直方图</span></span><br><span class="line">sns.distplot(s, kde=<span class="keyword">False</span>)</span><br><span class="line">plt.show()</span><br><span class="line">sns.distplot(s, kde=<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217172139.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217172043.png" alt=""></p><h1 id="4-条形图-bar"><a href="#4-条形图-bar" class="headerlink" title="4. 条形图 bar"></a>4. 条形图 bar</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">x = [<span class="string">'Cat1'</span>, <span class="string">'Cat2'</span>, <span class="string">'Cat3'</span>, <span class="string">'Cat4'</span>, <span class="string">'Cat5'</span>]</span><br><span class="line">y = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># 用 Matplotlib 画条形图</span></span><br><span class="line">plt.bar(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 用 Seaborn 画条形图</span></span><br><span class="line">sns.barplot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217174112.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="5-箱线图-boxplot"><a href="#5-箱线图-boxplot" class="headerlink" title="5. 箱线图 boxplot"></a>5. 箱线图 boxplot</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line"><span class="comment"># 生成 0-1 之间的 10*4 维度数据</span></span><br><span class="line">data=np.random.normal(size=(<span class="number">10</span>,<span class="number">4</span>)) </span><br><span class="line">lables = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>]</span><br><span class="line"><span class="comment"># 用 Matplotlib 画箱线图</span></span><br><span class="line">plt.boxplot(data,labels=lables)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 用 Seaborn 画箱线图</span></span><br><span class="line">df = pd.DataFrame(data, columns=lables)</span><br><span class="line">sns.boxplot(data=df)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217172431.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="6-饼图-pie"><a href="#6-饼图-pie" class="headerlink" title="6. 饼图 pie"></a>6. 饼图 pie</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">nums = [<span class="number">25</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">37</span>, <span class="number">6</span>]</span><br><span class="line">labels = [<span class="string">'High-school'</span>,<span class="string">'Bachelor'</span>,<span class="string">'Master'</span>,<span class="string">'Ph.d'</span>, <span class="string">'Others'</span>]</span><br><span class="line"><span class="comment"># 用 Matplotlib 画饼图</span></span><br><span class="line">plt.pie(x = nums, labels=labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/45/f7/45c38de6563d528f610bfcef5c8874f7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="7-热力图-heat-map"><a href="#7-热力图-heat-map" class="headerlink" title="7. 热力图 heat map"></a>7. 热力图 heat map</h1><p>较为直观的多元变量分析方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 数据准备,使用seaborn自带数据集flights</span></span><br><span class="line">flights = sns.load_dataset(<span class="string">"flights"</span>)</span><br><span class="line">data=flights.pivot(<span class="string">'year'</span>,<span class="string">'month'</span>,<span class="string">'passengers'</span>)</span><br><span class="line"><span class="comment"># 用 Seaborn 画热力图</span></span><br><span class="line">sns.heatmap(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/57/93/57e1bc17d943620620fb087d6190df93.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="8-蜘蛛图"><a href="#8-蜘蛛图" class="headerlink" title="8. 蜘蛛图"></a>8. 蜘蛛图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties  </span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">labels=np.array([<span class="string">u" 推进 "</span>,<span class="string">"KDA"</span>,<span class="string">u" 生存 "</span>,<span class="string">u" 团战 "</span>,<span class="string">u" 发育 "</span>,<span class="string">u" 输出 "</span>])</span><br><span class="line">stats=[<span class="number">83</span>, <span class="number">61</span>, <span class="number">95</span>, <span class="number">67</span>, <span class="number">76</span>, <span class="number">88</span>]</span><br><span class="line"><span class="comment"># 画图数据准备，角度、状态值</span></span><br><span class="line">angles=np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, len(labels), endpoint=<span class="keyword">False</span>)</span><br><span class="line">stats=np.concatenate((stats,[stats[<span class="number">0</span>]]))</span><br><span class="line">angles=np.concatenate((angles,[angles[<span class="number">0</span>]]))</span><br><span class="line"><span class="comment"># 用 Matplotlib 画蜘蛛图</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, polar=<span class="keyword">True</span>)   </span><br><span class="line">ax.plot(angles, stats, <span class="string">'o-'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">ax.fill(angles, stats, alpha=<span class="number">0.25</span>)</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">font = FontProperties(fname=<span class="string">r"C:\Windows\Fonts\simhei.ttf"</span>, size=<span class="number">14</span>)  </span><br><span class="line">ax.set_thetagrids(angles * <span class="number">180</span>/np.pi, labels, FontProperties=font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/19/7d/1924d3cbf035053fa3d5043794624c7d.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="9-二元分布图"><a href="#9-二元分布图" class="headerlink" title="9. 二元分布图"></a>9. 二元分布图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">print(tips.head(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 用 Seaborn 画二元变量分布图（散点图，核密度图，Hexbin 图）</span></span><br><span class="line">sns.jointplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips, kind=<span class="string">'scatter'</span>)</span><br><span class="line">sns.jointplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips, kind=<span class="string">'kde'</span>)</span><br><span class="line">sns.jointplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips, kind=<span class="string">'hex'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217174241.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/7c/aa/7cbdbb115e7d984c3086acb689b661aa.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="10-成对关系图"><a href="#10-成对关系图" class="headerlink" title="10. 成对关系图"></a>10. 成对关系图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">iris = sns.load_dataset(<span class="string">'iris'</span>)</span><br><span class="line"><span class="comment"># 用 Seaborn 画成对关系</span></span><br><span class="line">sns.pairplot(iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>这里我们用 Seaborn 中的 pairplot 函数来对数据集中的多个双变量的关系进行探索，如下图所示。从图上你能看出，一共有 sepal_length、sepal_width、petal_length 和 petal_width4 个变量，它们分别是花萼长度、花萼宽度、花瓣长度和花瓣宽度。</p><p>下面这张图相当于这 4 个变量两两之间的关系。比如矩阵中的第一张图代表的就是花萼长度自身的分布图，它右侧的这张图代表的是花萼长度与花萼宽度这两个变量之间的关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static001.geekbang.org/resource/image/88/0d/885450d23f468b9cbcabd90ff9a3480d.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>更多可视化示例可参考matplotlib 官网上的例子。<a href="https://matplotlib.org/gallery/index.html" target="_blank" rel="noopener">https://matplotlib.org/gallery/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍了 10 种常用且易于上手的可视化方法，基于python3.7实现。主要使用了两个图形可视化库，matplotlib &amp;amp; seaborn。这两个库的图形效果有细微差别，matplotlib较为流行且支持的可视化图形较多，seaborn也有特有的图形效果，
      
    
    </summary>
    
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="数据可视化" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>堆栈——C语言实现顺序存储和链式存储</title>
    <link href="https://joshuaqyh.github.io/2019/02/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%A0%88-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <id>https://joshuaqyh.github.io/2019/02/09/数据结构-堆栈-C语言实现顺序存储和链式存储/</id>
    <published>2019-02-09T15:06:33.000Z</published>
    <updated>2019-02-09T16:01:16.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆栈的顺序存储实现"><a href="#堆栈的顺序存储实现" class="headerlink" title="堆栈的顺序存储实现"></a>堆栈的顺序存储实现</h1><p>堆栈的顺序存储实现其实是利用了定长数组来模拟堆栈先进后出的规则，由此决定了堆栈的固定容量, 同时需要两个头尾指针来指示栈顶和栈底的位置。</p><p>以下展示各部分的代码实现。</p><ul><li>定义结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;     <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    Position Front, Rear;  <span class="comment">/* 队列的头、尾指针 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;           <span class="comment">/* 队列最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br></pre></td></tr></table></figure><ul><li>创建队列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">( <span class="keyword">int</span> MaxSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断堆栈队列是否已满</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q-&gt;Rear+<span class="number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加栈顶元素</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddQ</span><span class="params">( Queue Q, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsFull(Q) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;Rear = (Q-&gt;Rear+<span class="number">1</span>)%Q-&gt;MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断堆栈是否为空</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q-&gt;Front == Q-&gt;Rear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>弹出栈顶元素</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(Q) ) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  &#123;</span><br><span class="line">        Q-&gt;Front =(Q-&gt;Front+<span class="number">1</span>)%Q-&gt;MaxSize;</span><br><span class="line">        <span class="keyword">return</span>  Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h1><p>堆栈的链式结构实现原理是将栈中的每一个元素视为链表中的每一个结点，利用链表的尾部的增删来实现先进后出的堆栈特点。</p><ul><li>定义结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> * <span class="title">PtrToSNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToSNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br></pre></td></tr></table></figure><ul><li>创建一个链式堆栈</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span></span><br><span class="line">    Stack S;</span><br><span class="line"></span><br><span class="line">    S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断堆栈链表是否为空</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span> <span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span></span><br><span class="line">    <span class="keyword">return</span> ( S-&gt;Next == <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>元素压入栈顶</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">( Stack S, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将元素X压入堆栈S */</span></span><br><span class="line">    PtrToSNode TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = (PtrToSNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    TmpCell-&gt;Data = X;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>弹出栈顶元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S )</span>  </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 删除并返回堆栈S的栈顶元素 */</span></span><br><span class="line">    PtrToSNode FirstCell;</span><br><span class="line">    ElementType TopElem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( IsEmpty(S) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈空"</span>); </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FirstCell = S-&gt;Next; </span><br><span class="line">        TopElem = FirstCell-&gt;Data;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(FirstCell);</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆栈的顺序存储实现&quot;&gt;&lt;a href=&quot;#堆栈的顺序存储实现&quot; class=&quot;headerlink&quot; title=&quot;堆栈的顺序存储实现&quot;&gt;&lt;/a&gt;堆栈的顺序存储实现&lt;/h1&gt;&lt;p&gt;堆栈的顺序存储实现其实是利用了定长数组来模拟堆栈先进后出的规则，由此决定了堆栈的固定
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CH3 | Vector Spaces and Subspaces</title>
    <link href="https://joshuaqyh.github.io/2019/02/09/CH3-Vector-Spaces-and-Subspaces/"/>
    <id>https://joshuaqyh.github.io/2019/02/09/CH3-Vector-Spaces-and-Subspaces/</id>
    <published>2019-02-09T07:28:03.000Z</published>
    <updated>2019-02-17T06:26:59.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h2><h3 id="向量空间定义"><a href="#向量空间定义" class="headerlink" title="向量空间定义"></a>向量空间定义</h3><p>一个空间 $R^n$ 包含着 所有的 n 维的列向量 v，那么该空间就是向量空间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209153528.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>还有三种特殊的向量空间 M、F、Z。</p><h3 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209154059.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于子空间的任意两个 v w向量（包括 零向量），满足 v + w 存在子空间中，cv 也在子空间中（可推导得到 v w 的线性组合都在子空间中）。 此时子空间记为 span{v，w}</p><p>即：</p><ul><li><p>包含零向量</p></li><li><p>向量加法封闭</p></li><li><p>向量乘法封闭</p><p>​</p></li></ul><h3 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209154422.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于 Ax = b，我们探讨 A的列空间。</p><p>列空间就是矩阵（A）中所有列向量的所有可能线性组合（Ax）的结果 （b），这些结果构成矩阵 （A）列空间C(A)。</p><p>对于一个 系统 Ax = b，若是可解的，当且仅当b位于A的列空间之中。</p><h2 id="A的零空间：解决-Ax-0"><a href="#A的零空间：解决-Ax-0" class="headerlink" title="A的零空间：解决 Ax = 0"></a>A的零空间：解决 Ax = 0</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209171201.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>零空间内部的向量x，经过矩阵A变换，得到的解为0向量。</p><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190211171355.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>给出一个矩阵A的零空间的特殊解，该零空间是特殊解的所有可能的线性组合的结果。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190211171501.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="行阶梯矩阵"><a href="#行阶梯矩阵" class="headerlink" title="行阶梯矩阵"></a>行阶梯矩阵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217104819.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="秩和行简化的形式"><a href="#秩和行简化的形式" class="headerlink" title="秩和行简化的形式"></a>秩和行简化的形式</h2><h3 id="秩定义"><a href="#秩定义" class="headerlink" title="秩定义"></a><strong>秩定义</strong></h3><p>矩阵的秩用来描述矩阵的大小，矩阵 A 的秩等于 rank A = 矩阵主元的个数，同时也是矩阵列空间的维数，此外我们也可以用秩来描述矩阵的独立行的个数。</p><h3 id="主元-自由变量"><a href="#主元-自由变量" class="headerlink" title="主元 自由变量"></a><strong>主元 自由变量</strong></h3><p>主元（pivot）的含义就是在简化后矩阵的每一行第一个非0值就是主元.。</p><p>自由变量的含义就是就是可以任取的变量，位置处于非主元列的非主元元素。</p><h3 id="主元列-自由列"><a href="#主元列-自由列" class="headerlink" title="主元列 自由列"></a><strong>主元列 自由列</strong></h3><p>主元所在的列叫做主元列，非主元列称为自由列。</p><p>自由列可以由未化简之前的主元列进行线性组合得到，线性组合的结果就是特殊解。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217110448.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从自由列和自由变量可以发现特殊解。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217113040.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="零空间的生成集"><a href="#零空间的生成集" class="headerlink" title="零空间的生成集"></a>零空间的生成集</h3><p>我们可以利用自由变量和主元来求出零空间的一个生成集。主元可以用其他自由变量线性组合得到，代入原式可以得到一组自由变量作为权的向量组合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217142013.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="秩为1的矩阵"><a href="#秩为1的矩阵" class="headerlink" title="秩为1的矩阵"></a><strong>秩为1的矩阵</strong></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217112840.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Ax-b的完全解"><a href="#Ax-b的完全解" class="headerlink" title="Ax = b的完全解"></a>Ax = b的完全解</h2><p>之前求解Ax = 0 就是 Ax = b 的一个特殊情况（b = 0 向量）</p><p>求解Ax = b，我们先设计一个增广矩阵[ A b ],对其进行行简化。</p><p><strong>求出一个通解和一个特殊解，然后 完全解 = 通解 + 特殊解</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217134601.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="满列秩"><a href="#满列秩" class="headerlink" title="满列秩"></a><strong>满列秩</strong></h3><p>满列秩矩阵就是主元的个数等于矩阵的行数的矩阵，所有列都具有主元。其性质如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217134955.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="满行秩"><a href="#满行秩" class="headerlink" title="满行秩"></a>满行秩</h3><p>满行秩矩阵的每一行都存在主元。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217135804.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于一个 m × n 矩阵，其秩 r 与 m n 之间存在四种可能的情况：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217135920.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="独立性-基-和维度"><a href="#独立性-基-和维度" class="headerlink" title="独立性 基 和维度"></a>独立性 基 和维度</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217140039.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="线性独立"><a href="#线性独立" class="headerlink" title="线性独立"></a><strong>线性独立</strong></h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217140146.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于一个矩阵来说，线性独立意味着 Ax = 0的解只有 x = 0。零空间中只有 x = 0.</p><p>对于一组向量来说，若都处于同一平面的话，则成向量线性依赖，若不在同一平面内，则这组向量线性独立。（一组向量也可以看成一个矩阵）</p><p>公式化结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217140439.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="展开成子空间"><a href="#展开成子空间" class="headerlink" title="展开成子空间"></a>展开成子空间</h3><p>一组向量扩展成一个空间的条件就是该组向量的线性组合能够填充整个空间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217140643.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217140709.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>矩阵A的行空间是$A^T$ 的列空间。</p><p><strong>向量基</strong><br>对于一个空间$R^n$，可存在多组向量基。每一组向量基可展开填满空间$R^n$。</p><p>每一组基有n个基向量，这些基向量线性独立（即不在同一平面内）并且展开可填满整个$R^n$空间。</p><p>如果基向量相互垂直（正交），那么称为标准正交基。</p><p>此时空间的维度就等于每一组基中向量的个数。</p><p><strong>矩阵空间和函数空间的基</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217142514.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="四个子空间的维度"><a href="#四个子空间的维度" class="headerlink" title="四个子空间的维度"></a>四个子空间的维度</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190217142601.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;向量空间&quot;&gt;&lt;a href=&quot;#向量空间&quot; class=&quot;headerlink&quot; title=&quot;向量空间&quot;&gt;&lt;/a&gt;向量空间&lt;/h2&gt;&lt;h3 id=&quot;向量空间定义&quot;&gt;&lt;a href=&quot;#向量空间定义&quot; class=&quot;headerlink&quot; title=&quot;向量空间定
      
    
    </summary>
    
    
      <category term="线性代数" scheme="https://joshuaqyh.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ch2 | Solving Linear Equations</title>
    <link href="https://joshuaqyh.github.io/2019/02/07/Ch2-Solving-Linear-Equations/"/>
    <id>https://joshuaqyh.github.io/2019/02/07/Ch2-Solving-Linear-Equations/</id>
    <published>2019-02-07T15:54:13.000Z</published>
    <updated>2019-02-08T18:01:00.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="向量与线性方程组"><a href="#向量与线性方程组" class="headerlink" title="向量与线性方程组"></a>向量与线性方程组</h2><h3 id="行图像"><a href="#行图像" class="headerlink" title="行图像"></a>行图像</h3><p>在二维平面中，行图像就是每一道方程所对应的线相交与一点。（更高维情况，就是低一维的对象相交得到低两维的对象）。点的坐标就是线性方程组的解。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208000556.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="列图像"><a href="#列图像" class="headerlink" title="列图像"></a>列图像</h3><p>列图像就是将线性方程组写成线性组合的形式，在平面内进行几何向量的运算。</p><ul><li>线性组合中的列向量就是方程中每一个未知数所有系数构成的向量</li><li>线性组合中的系数就是方程组的未知数</li><li>线性组合中的结果就是方程组的解构成的列向量</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208000701.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="矩阵-向量乘法"><a href="#矩阵-向量乘法" class="headerlink" title="矩阵-向量乘法"></a>矩阵-向量乘法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208001013.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208001034.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以上内容都是基于二阶线性方程组和二维平面内进行的，在高维的情况下可直接推广。这里不做赘述。</p><h2 id="Elimination-消去"><a href="#Elimination-消去" class="headerlink" title="Elimination 消去"></a>Elimination 消去</h2><p>通常在求解一个线性方程组，无法直接构造适用的线性系统A，需要对原方程组进行一定的变化，这些变化方法统称为 消去，最终得到一个上三角矩阵 A。（<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AF%B9%E8%A7%92%E7%BA%BF" target="_blank" rel="noopener">主对角线</a>以下都是0的方阵称为上三角矩阵）</p><p>上三角矩阵具备以下性质：</p><p>1、上三角矩阵的<a href="https://baike.baidu.com/item/%E8%A1%8C%E5%88%97%E5%BC%8F" target="_blank" rel="noopener">行列式</a>为<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%A7%92%E7%BA%BF" target="_blank" rel="noopener">对角线</a>元素相乘；</p><p>2、上三角矩阵乘以系数后也是上三角矩阵；</p><p>3、上三角矩阵间的加减法和乘法运算的结果仍是上三角矩阵；</p><p>4、上三角矩阵的<a href="https://baike.baidu.com/item/%E9%80%86%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">逆矩阵</a>也仍然是上三角矩阵。</p><p>5、这些事实说明：所有上三角矩阵的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117" target="_blank" rel="noopener">集合</a>以及相应的运算构成一个方形矩阵集合的一个子代数。</p><p>一般需要对原方程组进行 行交换，乘以系数，或者方程相减等操作，从而得到化简后的上三角矩阵。</p><h2 id="Matrix-Multiplication-矩阵乘法"><a href="#Matrix-Multiplication-矩阵乘法" class="headerlink" title="Matrix Multiplication 矩阵乘法"></a>Matrix Multiplication 矩阵乘法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>矩阵乘法的规则（考虑3列的情形）：</p><p>$$AB = A [b_1 \, b_2 b_3] = [Ab_1\, Ab_2\, Ab_3] \tag{1}$$</p><p>A 为 m × n 的矩阵，B为 n × o 的矩阵，乘法结果就是 m × o 的矩阵。</p><p>A B 矩阵需要满足上述的行列数目规则， A的列数等于B的行数。</p><h3 id="乘法性质"><a href="#乘法性质" class="headerlink" title="乘法性质"></a>乘法性质</h3><ul><li>结合律成立</li><li>交换律不成立</li></ul><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>利用一些置换矩阵来完成矩阵操作：</p><ul><li>行交换</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208211421.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>消除某些行</li></ul><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><p>对于 Ax = b，其增广矩阵为 [ A b ]</p><h2 id="矩阵运算法则"><a href="#矩阵运算法则" class="headerlink" title="矩阵运算法则"></a>矩阵运算法则</h2><h3 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208222506.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208222554.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="块矩阵和块乘法"><a href="#块矩阵和块乘法" class="headerlink" title="块矩阵和块乘法"></a>块矩阵和块乘法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208222719.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208222808.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>但是不是所有矩阵都有逆矩阵！</p><p>若矩阵可逆，那么该矩阵和逆矩阵相乘的结果就是单位矩阵！</p><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>关于逆矩阵有以下几个引理，常用的有 Note5.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208224849.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208224819.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="矩阵乘法的逆矩阵"><a href="#矩阵乘法的逆矩阵" class="headerlink" title="矩阵乘法的逆矩阵"></a>矩阵乘法的逆矩阵</h3><p>如果矩阵 A，B都是可逆矩阵，那么 AB 的逆矩阵就是</p><p>$$(AB)^{-1} = B^{-1}A^{-1} \tag{2}$$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208225240.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>以此类推，有：<br><br>$$(ABC\dots Z)^{-1} = Z^{-1}\dots C^{-1}B^{-1}A^{-1} \tag{3}$$<br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208225551.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Calculating-A-1-by-Gauss-Jordan-Elimination"><a href="#Calculating-A-1-by-Gauss-Jordan-Elimination" class="headerlink" title="Calculating $A^{-1}$ by Gauss-Jordan Elimination"></a>Calculating $A^{-1}$ by Gauss-Jordan Elimination</h3><p>考虑三列的情形：</p><p>$$AA^{-1} = A[x_1\, x_2\, x_3 ] = [e_1 \, e_2 \, e_3] = I$$</p><p>处理成近似 Ax = b的情况。</p><p>构造增广矩阵 $[A \, e_1 \, e_2 \,e_3] $ , 利用消去运算，将增广矩阵改造成 $[I \, A^{-1}]$，从而得到 $A^{-1}$。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208230320.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="A-LU-矩阵因式分解"><a href="#A-LU-矩阵因式分解" class="headerlink" title="A = LU 矩阵因式分解"></a>A = LU 矩阵因式分解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190208232050.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>给定一个A矩阵，要找出一个下三角矩阵L和一个上三角矩阵U，使得 A = LU</p><p>L和U的好处就是将稠密的A矩阵转为两个稀疏矩阵L、U，减低计算复杂度，提升计算速度。</p><h3 id="计算-L和U"><a href="#计算-L和U" class="headerlink" title="计算 L和U"></a>计算 L和U</h3><p>对于一个式子 A = LU，各矩阵解释如下：</p><ul><li>A 为一个初始矩阵，待分解。</li><li>U 为 A矩阵经过矩阵消元得到的上三角矩阵。</li><li>L 为一个下三角矩阵，可以根据行变换的倍数和行，在单元矩阵上填充非0数。</li></ul><h2 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209011617.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209011736.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><ul><li>定义</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209012357.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>对称矩阵的生成方法 $R^T R $ </li></ul><p>给定任意的一个矩阵 R，我们可以使用 其转置$R^T$与R相乘，得到一个正方形的对称矩阵。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209012749.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>对称矩阵的分解性质 $LDL^T$</li></ul><p>对于一个矩阵 A，我们考虑其因式分解 A = LDU。如果A为对称矩阵，那么U = $L^T$ 。</p><h2 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190209015001.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>置换就是对原矩阵进行变换，包括系数变换，行交换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;向量与线性方程组&quot;&gt;&lt;a href=&quot;#向量与线性方程组&quot; class=&quot;headerlink&quot; title=&quot;向量与线性方程组&quot;&gt;&lt;/a&gt;向量与线性方程组&lt;/h2&gt;&lt;h3 id=&quot;行图像&quot;&gt;&lt;a href=&quot;#行图像&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="线性代数" scheme="https://joshuaqyh.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ch1| Introduction to Vectors</title>
    <link href="https://joshuaqyh.github.io/2019/02/07/CH1_Introduction-to-Vectors/"/>
    <id>https://joshuaqyh.github.io/2019/02/07/CH1_Introduction-to-Vectors/</id>
    <published>2019-02-07T13:52:08.000Z</published>
    <updated>2019-02-08T18:05:57.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性组合和列向量"><a href="#线性组合和列向量" class="headerlink" title="线性组合和列向量"></a>线性组合和列向量</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线性组合可以理解为许多系数乘以对应的列向量（其实就是向量都是一列的hhh），然后相加，最终得到一个新的列向量。其中一个例子如下：</p><p>$$cv + dw = c \left[ \begin{matrix}  1 \ 1 \end{matrix} \right] + d \left[ \begin{matrix} 2 \ 3 \end{matrix} \right] = \left[\begin{matrix} c+2d \ c + 3d\end{matrix} \right] \tag{1}$$</p><p>其中 v w 为列向量，c，d为系数。列向量可以为多个维度(行），系数代表实数。</p><p>我们定义对于多个列向量 v，… ,w，其线性组合就为 cv+…+dw。</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>关于列向量，需要了解的运算：</p><ul><li>列向量相加：向量对应的位置的值直接相加</li><li>标量和列向量相乘：系数直接乘以向量对应的位置</li></ul><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>列向量$\left[ \begin{matrix} a \ b \ c \end{matrix}\right]$就是理解为空间中的原点到点$(a,b,c)$ 的一条有向线段。</p><p>线性组合的几何含义就是空间中的列向量根据矢量相加的法则，最终得到一条新的有向线段（2维）或者更高维的平面。</p><h3 id="与线性方程组的关系"><a href="#与线性方程组的关系" class="headerlink" title="与线性方程组的关系"></a>与线性方程组的关系</h3><p>与 式子 （1）的线性组合相对应的线性方程组如下：</p><p>$$c + 2d  = x  \ c + 3d = y   \, = &gt;  \left[ \begin{matrix} 1 &amp; 2 \ 1 &amp; 3 \end{matrix}\right] \left[ \begin{matrix} c \ d\end{matrix}\right] = \left[ \begin{matrix} x \ y \end{matrix}\right]  \tag{2}$$</p><p>构造系数矩阵和未知数列向量，相乘，得到结果向量。</p><h2 id="向量点乘和长度"><a href="#向量点乘和长度" class="headerlink" title="向量点乘和长度"></a>向量点乘和长度</h2><h3 id="两个向量的点乘定义"><a href="#两个向量的点乘定义" class="headerlink" title="两个向量的点乘定义"></a>两个向量的点乘定义</h3><p>对于两个向量v = (v1, v2) 和 w = (w1, w2) ，我们将这两个向量的点乘定义为 </p><p>$$v \cdot w = v1 w1 + v2 w2  \tag{3}$$</p><p>也就是向量对应位置的数值相乘，然后求和得结果。</p><h3 id="向量长度"><a href="#向量长度" class="headerlink" title="向量长度"></a>向量长度</h3><p>对于一个向量 v 的长度，我们定义为</p><p>$length = ||v|| = \sqrt{v \cdot v}\tag{4}$</p><p>也就是向量和自身进行点乘运算，然后开方得到结果。更直观的表达就是，向量每一个元素进行平方求和，然后再开方。</p><h3 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h3><p>单位向量 u 就是长度为 1 的向量，该向量与自身点乘结果为1 即 $u \cdot u = 1 $。</p><p>对于每一个向量 v，要得到对应的单位向量，方法就是该向量除以向量长度，得到单位向量 u。用以下式子表示：</p><p>$u  = \frac{v}{||v||} \tag{5} $</p><p>其中单位向量 u 与 对应的向量 v 的方向相同。</p><h3 id="向量之间的夹角"><a href="#向量之间的夹角" class="headerlink" title="向量之间的夹角"></a>向量之间的夹角</h3><p>对于两个非零向量 v w，夹角 $\theta$, 其之间存在的关系是</p><p>$$ \frac{v \cdot w}{||v||||w||} = \cos{\theta} \tag{6}$$</p><p> 其中需要注意一种特殊情况，就是两个向量垂直的情况，也就是所谓的<strong>正交</strong>, 即 $v \cdot w = 0$</p><h3 id="重要不等式"><a href="#重要不等式" class="headerlink" title="重要不等式"></a>重要不等式</h3><p>关于向量点乘，存在一条不等式，如下：</p><p>$$ | v \cdot w | \le ||v|| \,||w|| \tag{7}$$</p><p>含义是：两个向量点乘的结果的绝对值 $\le $ 两个向量的长度相乘的结果。</p><p>关于向量相加，存咋一条不等式如下：</p><p>$$||v + w|| \le ||v|| + ||w|| \tag{8}$$</p><p>含义是：两个向量相加的结果的绝对值 $\le$ 两个向量长度之和</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h2 id="Ax-b-与线性组合的关系"><a href="#Ax-b-与线性组合的关系" class="headerlink" title="Ax = b 与线性组合的关系"></a>Ax = b 与线性组合的关系</h2><p>线性组合能够转换成矩阵相乘的形式 $Ax = b$，以下是书中的一个例子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190207231613.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>线性组合和矩阵相乘 Ax = b，各部分的意思是：</p><ul><li>A 代表一个矩阵，矩阵的列向量就是线性组合中的所有向量</li><li>x 代表一个向量，其元素是线性组合中所有的系数</li><li>b 是一个向量，是线性组合中的结果</li></ul><p>对于每一个输入向量 x，与差分矩阵 A 相乘，得到的结果都包含在 b 向量内部。</p><h3 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190207231536.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>线性方程组和矩阵相乘 Ax = b，各部分的意思是：</p><ul><li>A 该矩阵的各个列向量就是方程组左边部分对应未知数的系数组合。</li><li>x 该向量代表方程组左边未知数的组合</li><li>b 该向量代表方程组右边的数的组合</li></ul><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><p>逆矩阵其实就是 Ax = b 的逆过程所用到的矩阵, 记为 S。</p><p>Ax = b 含义就是输入一个向量x，经过线性矩阵系统A运算，得到新的向量b；</p><p>求逆过程就是  x = Sb，含义是：b 经过 逆矩阵系统 S 运算得到原来的输入向量 x。</p><p>该关系记为：</p><p>$$ A x = b   \; is\, solved \,by \,x = A^{-1}b = Sb \tag{9} $$</p><h3 id="周期差分矩阵"><a href="#周期差分矩阵" class="headerlink" title="周期差分矩阵"></a>周期差分矩阵</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190207233113.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Cx 之后运算得到的向量各个元素相加之和为0，那么 C 就是 周期差分矩阵。</p><h3 id="独立性和依赖性"><a href="#独立性和依赖性" class="headerlink" title="独立性和依赖性"></a>独立性和依赖性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190207234139.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>独立性</strong></p><p>如果我们知道 u v …w 这多个向量之中，任意一个向量都不在另外其他所有向量构成的平面内，则称这些向量相互独立。</p><p><strong>依赖性</strong></p><p>区别于独立性，依赖性就是向量都处在同一平面，任意一个向量可由其他所有向量线性组合得到。也就是说存在一个线性组合使得结果为0。那么向量组就存在依赖性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性组合和列向量&quot;&gt;&lt;a href=&quot;#线性组合和列向量&quot; class=&quot;headerlink&quot; title=&quot;线性组合和列向量&quot;&gt;&lt;/a&gt;线性组合和列向量&lt;/h1&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="线性代数" scheme="https://joshuaqyh.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>线性表——C语言实现顺序存储和链式存储</title>
    <link href="https://joshuaqyh.github.io/2019/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://joshuaqyh.github.io/2019/02/04/数据结构-线性表/</id>
    <published>2019-02-04T11:22:52.000Z</published>
    <updated>2019-02-09T15:01:39.458Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线性表的实现大致有两种方式：定长数组定义的定长线性以及指针定义的变长线性表。本文结合中国大学MOOC浙江大学的数据结构课程，对链表相关的基础知识进行了梳理和总结。</p></blockquote><h1 id="线性表表"><a href="#线性表表" class="headerlink" title="线性表表"></a>线性表表</h1><h2 id="定长链表"><a href="#定长链表" class="headerlink" title="定长链表"></a>定长链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定长链表结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line"> </span><br><span class="line">    L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    L-&gt;Last = <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 查找 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; L-&gt;Last )  <span class="keyword">return</span> ERROR; <span class="comment">/* 如果没找到，返回错误信息 */</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> i;  <span class="comment">/* 找到后返回的是存储位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 插入 */</span></span><br><span class="line"><span class="comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 在L的指定位置P前插入一个新元素X */</span></span><br><span class="line">    Position i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( L-&gt;Last == MAXSIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 表空间已满，不能插入 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"表满"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ( P&lt;<span class="number">0</span> || P&gt;L-&gt;Last+<span class="number">1</span> ) &#123; <span class="comment">/* 检查插入位置的合法性 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )</span><br><span class="line">        L-&gt;Data[i+<span class="number">1</span>] = L-&gt;Data[i]; <span class="comment">/* 将位置P及以后的元素顺序向后移动 */</span></span><br><span class="line">    L-&gt;Data[P] = X;  <span class="comment">/* 新元素插入 */</span></span><br><span class="line">    L-&gt;Last++;       <span class="comment">/* Last仍指向最后元素 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 从L中删除指定位置P的元素 */</span></span><br><span class="line">    Position i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( P&lt;<span class="number">0</span> || P&gt;L-&gt;Last ) &#123; <span class="comment">/* 检查空表及删除位置的合法性 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置%d不存在元素"</span>, P ); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( i=P+<span class="number">1</span>; i&lt;=L-&gt;Last; i++ )</span><br><span class="line">        L-&gt;Data[i<span class="number">-1</span>] = L-&gt;Data[i]; <span class="comment">/* 将位置P+1及以后的元素顺序向前移动 */</span></span><br><span class="line">    L-&gt;Last--; <span class="comment">/* Last仍指向最后元素 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变长链表"><a href="#变长链表" class="headerlink" title="变长链表"></a>变长链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 查找 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR NULL</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position p = L; <span class="comment">/* p指向L的第1个结点 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 下列语句可以用 return p; 替换 */</span></span><br><span class="line">    <span class="keyword">if</span> ( p )</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 带头结点的插入 */</span></span><br><span class="line"><span class="comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, Position P )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 这里默认L有头结点 */</span></span><br><span class="line">    Position tmp, pre;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 查找P的前一个结点 */</span>        </span><br><span class="line">    <span class="keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            </span><br><span class="line">    <span class="keyword">if</span> ( pre==<span class="literal">NULL</span> ) &#123; <span class="comment">/* P所指的结点不在L中 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置参数错误\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 找到了P的前一个结点pre */</span></span><br><span class="line">        <span class="comment">/* 在P前插入新结点 */</span></span><br><span class="line">        tmp = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode)); <span class="comment">/* 申请、填装结点 */</span></span><br><span class="line">        tmp-&gt;Data = X; </span><br><span class="line">        tmp-&gt;Next = P;</span><br><span class="line">        pre-&gt;Next = tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 带头结点的删除 */</span></span><br><span class="line"><span class="comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">( List L, Position P )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 这里默认L有头结点 */</span></span><br><span class="line">    Position tmp, pre;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 查找P的前一个结点 */</span>        </span><br><span class="line">    <span class="keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ;            </span><br><span class="line">    <span class="keyword">if</span> ( pre==<span class="literal">NULL</span> || P==<span class="literal">NULL</span>) &#123; <span class="comment">/* P所指的结点不在L中 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除位置参数错误\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 找到了P的前一个结点pre */</span></span><br><span class="line">        <span class="comment">/* 将P位置的结点删除 */</span></span><br><span class="line">        pre-&gt;Next = P-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;线性表的实现大致有两种方式：定长数组定义的定长线性以及指针定义的变长线性表。本文结合中国大学MOOC浙江大学的数据结构课程，对链表相关的基础知识进行了梳理和总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;线性表表&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LaTex 常用数学公式符号速记</title>
    <link href="https://joshuaqyh.github.io/2019/01/24/LaTex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%AC%A6%E5%8F%B7%E9%80%9F%E8%AE%B0/"/>
    <id>https://joshuaqyh.github.io/2019/01/24/LaTex-常用数学公式符号速记/</id>
    <published>2019-01-24T08:44:22.000Z</published>
    <updated>2019-05-16T14:01:09.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>LaTex的行内公式和行间公式区别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;amsmath&#125;  % 此处引入数学公式的包</span><br><span class="line"></span><br><span class="line">% 行内公式</span><br><span class="line">This is an inline formula. $a = \sqrt&#123;b + c&#125;$.</span><br><span class="line"></span><br><span class="line">% 行间公式, 带编号</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">E = mc^2</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure></p><p>以下均以行内公式呈现。<br>| 数学公式类型   | 例子                                                         | LaTex代码                                                    |<br>| ————– | ———————————————————— | ———————————————————— |<br>| 分式           | $\frac{1+ 2x}{3 + 2y}$                                       | \frac{1+ 2x}{3 + 2y}                                         |<br>| 下标           | $a_{2}$                                                      | a_{2}                                                        |<br>| 上标           | $a^{2}$                                                      | a^{2}                                                        |<br>| 平均数         | $\bar{a}$                                                    | \bar{a}                                                      |<br>| 向量           | $\vec{a}$                                                    | \vec{a}                                                      |<br>| 二项式系数     | $\binom{a}{b + c}$                                           | \binom{a}{b + c}                                             |<br>| 变量省略号     | $F(x_{1}, x_{2}, \ldots , x_{n})$                            | F(x_{1}, x_{2}, \ldots , x_{n})                              |<br>| 公式内省略号   | $x_{1} + x_{2} + \cdots + x_{n}$                             | x_{1} + x_{2} + \cdots + x_{n}                               |<br>| 矩阵(无修饰)   | $\begin{matrix}a + b + c &amp; uv &amp; x - y &amp; 27\a + b &amp; u + v &amp; z &amp; 134\end{matrix}$ | \ begin{matrix}a + b + c &amp; uv &amp; x - y &amp; 27\ \a + b &amp; u + v &amp; z &amp; 134\ end{matrix} |<br>| 矩阵(带小括号) | $\begin{pmatrix}a + b + c &amp; uv\a + b &amp; u + v\end{pmatrix}$  | \ begin{pmatrix}a + b + c &amp; uv \\a + b&amp;u + v \ end{pmatrix} |<br>| 矩阵(带竖号)   | $\begin{vmatrix}a + b + c &amp; uv\a + b &amp; u + v\end{vmatrix}$  | \ begin{vmatrix}a + b + c &amp; uv \\ a + b&amp;u + v \ end{vmatrix} |<br>| 开方           | $\sqrt[n]{t}$                                                | \sqrt[n]{t}                                                  |<br>| 累加           | $\sum_{i=1}^{n} x_{i}^{2} $                                  | \sum_{i=1}^{n} x_{i}^{2}                                     |<br>| 累积           | $\prod_{i=1}^{n} x_{i}^{2}$                                  | \prod_{i=1}^{n} x_{i}^{2}                                    |<br>| 极限           | $\lim_{x \to a}{ \frac{f(x) - f(a)}{x - a}}$                 | \lim_{x \to a}{ \frac{f(x) - f(a)}{x - a}}                   |<br>| 积分           | $\int_{a}^b f(x)\, dx$                                       | \int_{a}^b f(x) \, dx                                        |<br>（注：矩阵表示中 ‘\’ 和begin，end之间无空格。因为如果有空格，csdn渲染无法显示源码。。<br>更多内容访问<a href="http://tex.loria.fr/general/mil.pdf" target="_blank" rel="noopener">链接</a>。</p><hr><h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190121225011.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190121225100.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20190121225115.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190121225156326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NWU3ZzdnN2c3Zz,size_16,color_FFFFFF,t_70" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>更多符号访问<a href="http://math.ecnu.edu.cn/~latex/docs/others/mathsymb.pdf" target="_blank" rel="noopener">链接[PDF]</a>, 或<a href="https://blog.csdn.net/ws_20100/article/details/49159291" target="_blank" rel="noopener">博客</a>。</p><p>需要美赛LaTex模板及使用方法，请访问此<a href="https://blog.csdn.net/CVSvsvsvsvs/article/details/86555582" target="_blank" rel="noopener">博文</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;公式&quot;&gt;&lt;a href=&quot;#公式&quot; class=&quot;headerlink&quot; title=&quot;公式&quot;&gt;&lt;/a&gt;公式&lt;/h2&gt;&lt;p&gt;LaTex的行内公式和行间公式区别如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="LaTex" scheme="https://joshuaqyh.github.io/tags/LaTex/"/>
    
      <category term="Writing" scheme="https://joshuaqyh.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>The template of the MCM/ICM paper</title>
    <link href="https://joshuaqyh.github.io/2019/01/24/The-template-of-the-MCM-ICM-paper/"/>
    <id>https://joshuaqyh.github.io/2019/01/24/The-template-of-the-MCM-ICM-paper/</id>
    <published>2019-01-24T08:29:54.000Z</published>
    <updated>2019-05-16T14:01:50.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-templates-of-the-paper"><a href="#The-templates-of-the-paper" class="headerlink" title="The templates of the paper"></a>The templates of the paper</h1><h2 id="Summary-Sheet"><a href="#Summary-Sheet" class="headerlink" title="Summary Sheet"></a>Summary Sheet</h2><p>The main points that should be showed are follows:</p><ol><li><p>start a restatement of the problem.</p></li><li><p>the importance if the problem is solved.</p></li><li><p>what models or methods are put forward to solve the problem. </p></li><li><p>illustrate the model further.</p></li><li><p>analyze the model with data. (what  ? how ? )</p></li><li><p>give a conclusion of the model.</p></li><li><p>draw a final and whole conclusion of the model.</p><p>​</p></li></ol><h3 id="The-restatement-of-the-problem"><a href="#The-restatement-of-the-problem" class="headerlink" title="The restatement of the problem"></a>The restatement of the problem</h3><ol><li>Our goal is… that (minimizes the time )</li><li>We determine the … by analyzing…</li><li>After mathematically analyzing the ……problem, our modeling group would like to present our conclusions, strategies,(and recommendations )to the …….</li><li>Aimed to look for the best strategy with the three options listed to maintain the dam, we employ … model to filter factors and determine two most influential criteria, including….</li></ol><h3 id="The-importance-if-the-problem-is-solved"><a href="#The-importance-if-the-problem-is-solved" class="headerlink" title="The importance if the problem is solved"></a>The importance if the problem is solved</h3><ol><li>Without implementing defensive measure,  the university is exposed to an expected loss of $8.9 million per year.</li><li>The Institute of Risk Management of South Africa has just warned that the Kariba dam is in desperate need of rehabilitation, otherwise the whole dam would collapse, putting 3.5 million people at risk.</li></ol><h3 id="The-models-put-forward-to-solve-the-problem"><a href="#The-models-put-forward-to-solve-the-problem" class="headerlink" title="The models put forward to solve the problem"></a>The models put forward to solve the problem</h3><ol><li>According to our choice, we are required to offer…. </li><li>Regarding it as a set covering problem, we develop a  …. model to minimize the number of smaller<br>while … </li><li>Applying … evaluation method to get the demand of the electricity and water, we solve this problem with ….. algorithm and get an approximate optimal solution with …. </li><li>We address the problem of optimizing ….</li><li>We formulate the problem as ….. </li><li>We divide the jump into three phases: 1…. 2….. 3…</li><li>To address this situation, our paper provides a detailed analysis of one option</li></ol><h3 id="Illustrate-the-model-further"><a href="#Illustrate-the-model-further" class="headerlink" title="Illustrate the model further"></a>Illustrate the model further</h3><ol><li>We build a model to determine how to ….</li><li>We examined the mathematical effects of……. We developed a detailed……(simulation methodology) to test our ideas and to quantify the differences between (among) different …… (strategies).</li></ol><h3 id="Analyze-the-model-with-data"><a href="#Analyze-the-model-with-data" class="headerlink" title="Analyze the model with data"></a>Analyze the model with data</h3><ol><li>Using historical data from the United States, we determine initial conditions for our model.</li><li>this model leads to a computer simulation of catch-can tests of the irrigation system and ……</li><li>We provide a strategy that…</li><li>Finally, these statistics could help us simulate….</li></ol><h3 id="Give-a-conclusion-of-the-model"><a href="#Give-a-conclusion-of-the-model" class="headerlink" title="Give a conclusion of the model"></a>Give a conclusion of the model</h3><ol><li>We show that this strategy is not optimal but can be improved by assigning different<br>numbers…… </li><li>We modify the model to reflect (some trend such as exponentially increasing……) and<br>generalize the model to (other field).</li><li>For various situations, we propose an optimal solution.</li><li>The sensitivity analysis of our model has pointed out that ….</li></ol><h3 id="Draw-a-final-and-whole-conclusion-of-the-model"><a href="#Draw-a-final-and-whole-conclusion-of-the-model" class="headerlink" title="Draw a final and whole conclusion of the model"></a>Draw a final and whole conclusion of the model</h3><ol><li>Our suggested solution, which is easy to implement, includes a detailed timetable and the arrangement of pipes.</li><li>Since our model is based on…… it can be applied to (other domain).</li><li>Our analysis began by determining what factor impact……, Our conclusions are presented……</li></ol><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>A simple background. </li></ul><h3 id="Restatement-and-Our-Work"><a href="#Restatement-and-Our-Work" class="headerlink" title="Restatement and Our Work"></a>Restatement and Our Work</h3><ol><li>We are required to provide an overview of … </li><li>Then we need to establish a model to determine …. </li><li>In addition, we should consider …. so that we could give out …</li><li>In order to solve those problems, we will proceed as follows: </li><li>In our model, we first establish a ….. model and use ….. algorithm to determine ….</li><li>Besides, we add some constraints ….</li><li>We  employ the genetic algorithm to solve the optimal problem to …. </li></ol><ul><li><p>Literature Review</p><p>​</p></li></ul><h2 id="Assumptions-and-Justifications"><a href="#Assumptions-and-Justifications" class="headerlink" title="Assumptions and Justifications"></a>Assumptions and Justifications</h2><p>Starting: </p><p>To simplify our problems, we make the following basic assumptions, each of which is properly<br>justified.  </p><p>Reason: </p><ul><li>Because it’s more convenient to build and also with less cost, which can be easily implemented.</li><li>Owing to the fact that …. </li><li>Taking into account of …. </li><li>According to … </li></ul><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><p>In this paper we use the nomenclature in Table.1 to descibe our model. Other symbols<br>that are used only once will be described later.</p><h2 id="The-Design-of-the-Models"><a href="#The-Design-of-the-Models" class="headerlink" title="The Design of the Models"></a>The Design of the Models</h2><h3 id="Model-Overview"><a href="#Model-Overview" class="headerlink" title="Model Overview"></a>Model Overview</h3><p>Our first model allows us to determine…</p><p>On the account that the optimal problem is difficult to solve in polynomial time, so we use genetic algorithm to get the solution…</p><p>After determining the numbers and the location, we establish a joint operation of dam system<br>model to gain a strategy about modulating water flow in different condition…</p><p>In conclusion, we use programming and heuristic algorithm to solve the problem ….</p><h3 id="Establishment-of-the-Model"><a href="#Establishment-of-the-Model" class="headerlink" title="Establishment of the Model"></a>Establishment of the Model</h3><p>If it is a multi-objective model, then: </p><p>The objectives</p><ol><li><ol start="2"><li><ol start="3"><li>​</li></ol></li></ol></li></ol><p>The Constraints</p><ol><li><ol start="2"><li><ol start="3"><li></li></ol></li></ol></li></ol><h2 id="Model-Implementation-and-Results"><a href="#Model-Implementation-and-Results" class="headerlink" title="Model Implementation and Results"></a>Model Implementation and Results</h2><h2 id="Sensitivity-Analysis"><a href="#Sensitivity-Analysis" class="headerlink" title="Sensitivity Analysis"></a>Sensitivity Analysis</h2><ul><li>Change condition1</li></ul><p>Analysis …..</p><p>Result …..</p><h2 id="Strengths-and-Weaknesses"><a href="#Strengths-and-Weaknesses" class="headerlink" title="Strengths and Weaknesses"></a>Strengths and Weaknesses</h2><h3 id="Strengths"><a href="#Strengths" class="headerlink" title="Strengths"></a>Strengths</h3><ol><li>Our main model’s strength is its enormous edibility. For instance,……..Including all these factors into a single, robust framework, our model enables</li><li>We developed a theoretical line formation model which agrees without rough data. Our computer model agrees with both despite working on different principles, implying it behaves as we want.</li><li>This allows us to make substantive conclusions about</li><li>Finally, our model is strong because of</li><li>The Monte Carlo simulation has been perfectly used in our models, and the simulation results are consistent with the reality.</li><li>We introduced …… in order to improve the exchange quality. The chain rules can also modified in a degree.</li><li>The models used in our paper is promotional, in view of different consideration,</li><li>we can modify our models conveniently.</li><li>the model is independent of the site simulated(   )…</li></ol><h3 id="Weaknesses"><a href="#Weaknesses" class="headerlink" title="Weaknesses"></a>Weaknesses</h3><ol><li><p>Some special data can’t be found, and it makes that we have to do some proper assumption before the solution of our models. A more abundant data resource can guarantee a better result in our models. Current line length is not taken into account by the line formation model. In real life……</p></li><li><p>Weaknesses of the model included assumptions made for simplicity that likely do not hold. For instance, in most runs of our model on(sides……), cases(impact/conclusion) to…… This feature is likely a result of our assumption that/The primary weakness  of this model is the(   ),   It should be possible to eliminate this,   another weakness that  could be  corrected with more  analysis is ( )`</p></li><li><p>The primary weakness of this model is the…</p><p>Another weakness that could be corrected with more analysis is…</p></li><li><p>Parameters have to be derived from physical occurrences.</p></li><li><p>The other primary weakness of our model is our lack of metrics forcomparison.</p></li><li><p>Although we list the model’s comprehensive, discrete simulation asa strength, it is</p></li><li><p>(Paradoxically) also the most notable weakness. Our results lack clear….Second ,our model demands great attention to….While its general structure and methodology are valid, the specific figures embedded in its code are not airtight.</p></li><li><p>Although we list the model’s comprehensive, …… as a strength, it is (paradoxically) also the most notable weakness. Our results lack clear illustrative power; data manipulated through a computer program cannot achieve the same effect as ……</p></li><li><p>Indeed, there is a fundamental trade off here between realism and elegance, and our model arguably veers toward over realism.</p></li></ol><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ol><li><p>Through the establishment of three models, we evaluate the three plans respectively.</p></li><li><p>Through the AHP analysis, we draw the conclusion that option three is a relatively good solution.</p></li><li><p>we establish a multi-objective optimization model to determine</p></li><li><p>We also use genetic algorithm to solve the problem and find that….</p></li><li><p>We already know how well our results worked for……</p></li><li><p>We next developed a detailed simulation engine to perform simulations. Our simulations<br>allowed us to ……</p></li><li><p>We also wish to tie our exploration of sensitive……</p><p>​</p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-templates-of-the-paper&quot;&gt;&lt;a href=&quot;#The-templates-of-the-paper&quot; class=&quot;headerlink&quot; title=&quot;The templates of the paper&quot;&gt;&lt;/a&gt;The temp
      
    
    </summary>
    
    
      <category term="Writing" scheme="https://joshuaqyh.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>信息安全 | 防火墙</title>
    <link href="https://joshuaqyh.github.io/2018/12/28/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://joshuaqyh.github.io/2018/12/28/防火墙/</id>
    <published>2018-12-28T02:10:09.000Z</published>
    <updated>2019-05-16T14:05:42.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防火墙概念"><a href="#防火墙概念" class="headerlink" title="防火墙概念"></a>防火墙概念</h2><p>在两个网络之间实现访问控制地一组软件或硬件系统。主要功能是屏蔽和允许指定的数据通信。依赖一组访问控制策略，由访问控制策略决定通讯的合法性。</p><p>用处：</p><ol><li><p>管理控制网络流通数据流</p><ol><li>数据包检测</li><li>连接状态</li><li>状态包检测</li></ol></li><li><p>作为中间媒介阻塞不安全的服务和协议</p><ol><li>通过隔离外部网络来保护本地主机</li><li>避免直接与外接互动</li></ol></li><li><p>保护资源，强化网络安全策略。将所有安全软件配置在防火墙上。采取某些手段如Finger来屏蔽透露内部细节的服务。</p></li><li><p>报告和记录事件，对网络存取和访问进行监控审计。</p><p>​</p></li></ol><h2 id="防火墙的种类"><a href="#防火墙的种类" class="headerlink" title="防火墙的种类"></a>防火墙的种类</h2><h3 id="第一代：包过滤（网络级防火墙）"><a href="#第一代：包过滤（网络级防火墙）" class="headerlink" title="第一代：包过滤（网络级防火墙）"></a>第一代：包过滤（网络级防火墙）</h3><p>工作在<strong>网络层以下</strong>，基于路由器本身的分组过滤功能，检索流经数据包包头信息，决定对数据包的动作。</p><h3 id="第二代：-状态过滤（状态检测防火墙）"><a href="#第二代：-状态过滤（状态检测防火墙）" class="headerlink" title="第二代： 状态过滤（状态检测防火墙）"></a>第二代： 状态过滤（状态检测防火墙）</h3><p>工作在<strong>网络层</strong>，采用状态检测的技术，是包过滤技术的拓展。使用一个<strong>检查引擎或数据包</strong>并抽取与<strong>应用层状态</strong>相关的信息，以此决定是否接收该连接。</p><h3 id="第三代：-应用层过滤（应用层网关）"><a href="#第三代：-应用层过滤（应用层网关）" class="headerlink" title="第三代： 应用层过滤（应用层网关）"></a>第三代： 应用层过滤（应用层网关）</h3><p>应用层代理防火墙。应用层网关代理服务器有效伪装成因特网上的真实服务器，并对请求做出评估，决定允许或者拒绝。</p><p>应用层网关能够理解应用级上的协议，完成较为复杂的访问控制。每一种协议需要相应的代理软件，<strong>效率不如网络级防火墙</strong>。</p><p>第四代：基于安全操作系统的防火墙</p><h2 id="托管防火墙"><a href="#托管防火墙" class="headerlink" title="托管防火墙"></a>托管防火墙</h2><p>三种托管防火墙的方式：</p><ol><li>Bastion Host 堡垒主机。具备三层过滤和代理控制的功能。主要用于处理安全事件。</li><li>Host-Based Firewall。严格过滤数据流。</li><li>Personal Firewall。 例子Windows 防火墙。</li></ol><h2 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h2><p>最基本的防火墙，通常工作在OSI的三层及以下。可控内容包括报文的源地址，报文的目标地址，服务类型，以及第二层数据链路层可控的MAC地址。</p><p>包过滤技术允许符合安全过滤规则的数据包通过。同时执行预先定义的操作，记录过滤信息，发送报警信息。</p><h4 id="过滤分析："><a href="#过滤分析：" class="headerlink" title="过滤分析："></a>过滤分析：</h4><ul><li><p>分析数据包包头字段。包括IP PORT，TCP。。。</p></li><li><p>一个访问控制列表，每一条记录定义了对符合记录条件的数据包所要执行的动作。</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181228110934.png" alt=""></p><p>优点：</p><ol><li>高速，只对包头进行检查</li><li>对用户透明</li></ol><p>缺点：</p><ol><li><p>无法根据数据内容进行过滤</p></li><li><p>提供简单的日志信息</p></li><li><p>ACL配置困难</p></li><li><p>端口暴露在外网，安全风险</p><p>​</p></li></ol></li></ul><h2 id="状态检测防火墙"><a href="#状态检测防火墙" class="headerlink" title="状态检测防火墙"></a>状态检测防火墙</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181228111509.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>状态检测技术主要在<strong>传输层和网络层工作</strong>。</li><li>动态过滤规则存储在连接状态表中，并由防火墙维护。</li><li>对表中记录设置超时参数。</li><li>只对连接的初始报文进行检查。</li></ul><p>优点：</p><ul><li>只对初始报文进行检查，后续报文不做检查，可以快速通过</li><li>可以区分连接的发起方和接收方，通过状态分析阻断更多的复杂攻击行为，以及分析打开相应的端口。</li></ul><p>缺点：</p><ul><li>主要工作在网络层和传输层，对报文的数据部分检查很少，安全性低。</li><li>对初始报文内容检测相对增多，对防火墙的响应速度提出了更高的要求。</li></ul><h2 id="应用层网关Proxy（ALG）"><a href="#应用层网关Proxy（ALG）" class="headerlink" title="应用层网关Proxy（ALG）"></a>应用层网关Proxy（ALG）</h2><p>应用层网关防火墙也叫应用层代理，负责内部网络和外部网络之间的通讯。网络连接通过中介来实现，设定符合预定的访问控制规则，所以恶意侵害无法伤害被保护的真实网络设备。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181228113809.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>提供一些复杂的访问控制：</p><ul><li>认证机制</li><li>内容过滤</li><li>成熟的日志记录</li></ul><p>优点：</p><ul><li>提供高速缓存</li><li>屏蔽内联网络</li><li>连接基于服务</li><li>代理服务建立在应用层</li><li>规则简单</li></ul><p>缺点：</p><ul><li>专用</li><li>延迟</li><li>用户不透明</li><li>不完全支持所有协议</li><li>对特定操作系统有依赖性</li><li>速度较慢。</li></ul><h2 id="堡垒主机Bastion"><a href="#堡垒主机Bastion" class="headerlink" title="堡垒主机Bastion"></a>堡垒主机Bastion</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防火墙概念&quot;&gt;&lt;a href=&quot;#防火墙概念&quot; class=&quot;headerlink&quot; title=&quot;防火墙概念&quot;&gt;&lt;/a&gt;防火墙概念&lt;/h2&gt;&lt;p&gt;在两个网络之间实现访问控制地一组软件或硬件系统。主要功能是屏蔽和允许指定的数据通信。依赖一组访问控制策略，由访问控制
      
    
    </summary>
    
    
      <category term="信息安全" scheme="https://joshuaqyh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>机器学习|支持向量机算法原理及实现</title>
    <link href="https://joshuaqyh.github.io/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://joshuaqyh.github.io/2018/12/24/机器学习-支持向量机算法原理及实现/</id>
    <published>2018-12-24T12:33:53.000Z</published>
    <updated>2019-03-08T06:30:56.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>最简单的支持向量机是一个二分类的分类器。分类思想是给定一组包含正负样本的集合，然后找到一个超平面（可以是一维或者多维），来对正负样本进行分割。</p><p>该方法对于解决小样本，非线性，及高维模式识别中表现出许多的优势。</p><p>以下图的直线就是概念中的超平面，将样本划分为两个类别。在解决实际的多分类问题中可以转化为多个二分类问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181224221553.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中的超平面方程由以下线性方程来描述。</p><p>​    $$g(x) = w^Tx + b = 0$$</p><p>其中$x$为样本的特征向量，$w^T$ 代表平面的法向量，而 $b$ 代表超平面的偏移量。</p><p>假设输入样本为 $x_0$，使得 $g(x_0) &gt; 0$ 的样本为正样本，反之为负样本，正负标签记为 ${+1, -1} $。</p><h2 id="函数间隔"><a href="#函数间隔" class="headerlink" title="函数间隔"></a>函数间隔</h2><p> <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181224225647.png" alt=""></p><p>函数的间隔指的是正负样本点中到超平面的最近距离。对数据点进行分类，当超平面离数据点的间隔越大，<strong>分类的确信度越高</strong>。故当多个超平面的分类准确率一致时，我们要着重考虑<strong>最大间隔的分类器</strong>。</p><p>所以支持向量机的最终目标就是找到一个最大间隔的分类器。可以理解为一个约束优化问题，用以下式子来表示。</p><p>$$max \, \frac{r^<em>}{||w||}  \ subject\, to \, y_i (w^Tx_i  + b ) \ge r^</em> $$ </p><p>其中 $r^*$为函数间隔。   </p><p>① 该方程并非凸函数求解，所以将方程转化为凸函数。转化为以下约束优化问题。</p><p>$$min \, \frac{1}{||w||} \ subject \,to\, y_i(w^Tx_i + b) \geq r*$$</p><p>转为凸函数以后，使用拉格朗日乘子法和KTT条件求解对偶问题。</p><p>②用拉格朗日乘子法和KKT条件求解最优值：</p><p>$$\min\ \frac{1}{2}||w||^2$$</p><p>$$s.t.\ -y_i(w^Tx_i+b)+1\leq 0,\ i=1,2,..,m$$</p><p>整合成：</p><p>$$L(w, b, \alpha) = \frac{1}{2}||w||^2+\sum^m_{i=1}\alpha_i(-y_i(w^Tx_i+b)+1)$$</p><p>推导：$\min\ f(x)=\min \max\ L(w, b, \alpha)\geq \max \min\ L(w, b, \alpha)$</p><p>根据KKT条件：</p><p>$$\frac{\partial }{\partial w}L(w, b, \alpha)=w-\sum\alpha_iy_ix_i=0,\ w=\sum\alpha_iy_ix_i$$</p><p>$$\frac{\partial }{\partial b}L(w, b, \alpha)=\sum\alpha_iy_i=0$$</p><p>带入$ L(w, b, \alpha)$</p><p>$\min\  L(w, b, \alpha)=\frac{1}{2}||w||^2+\sum^m_{i=1}\alpha_i(-y_i(w^Tx_i+b)+1)$</p><p>$\qquad\qquad\qquad=\frac{1}{2}w^Tw-\sum^m_{i=1}\alpha_iy_iw^Tx_i-b\sum^m_{i=1}\alpha_iy_i+\sum^m_{i=1}\alpha_i$</p><p>$\qquad\qquad\qquad=\frac{1}{2}w^T\sum\alpha_iy_ix_i-\sum^m_{i=1}\alpha_iy_iw^Tx_i+\sum^m_{i=1}\alpha_i$</p><p>$\qquad\qquad\qquad=\sum^m_{i=1}\alpha_i-\frac{1}{2}\sum^m_{i=1}\alpha_iy_iw^Tx_i$</p><p>$\qquad\qquad\qquad=\sum^m_{i=1}\alpha_i-\frac{1}{2}\sum^m_{i,j=1}\alpha_i\alpha_jy_iy_j(x_ix_j)$</p><p>再把max问题转成min问题：</p><p>$\max\ \sum^m_{i=1}\alpha_i-\frac{1}{2}\sum^m_{i,j=1}\alpha_i\alpha_jy_iy_j(x_ix_j)=\min \frac{1}{2}\sum^m_{i,j=1}\alpha_i\alpha_jy_iy_j(x_ix_j)-\sum^m_{i=1}\alpha_i$</p><p>$s.t.\ \sum^m_{i=1}\alpha_iy_i=0,$</p><p>$ \alpha_i \geq 0,i=1,2,…,m$</p><p>以上为SVM对偶问题的对偶形式</p><hr><h4 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h4><p>在低维空间计算获得高维空间的计算结果，也就是说计算结果满足高维（满足高维，才能说明高维下线性可分）。</p><h4 id="soft-margin-amp-slack-variable"><a href="#soft-margin-amp-slack-variable" class="headerlink" title="soft margin &amp; slack variable"></a>soft margin &amp; slack variable</h4><p>引入松弛变量$\xi\geq0$，对应数据点允许偏离的functional margin 的量。</p><p>目标函数：$\min\ \frac{1}{2}||w||^2+C\sum\xi_i\qquad s.t.\ y_i(w^Tx_i+b)\geq1-\xi_i$ </p><p>对偶问题：</p><p>$$\max\ \sum^m_{i=1}\alpha_i-\frac{1}{2}\sum^m_{i,j=1}\alpha_i\alpha_jy_iy_j(x_ix_j)=\min \frac{1}{2}\sum^m_{i,j=1}\alpha_i\alpha_jy_iy_j(x_ix_j)-\sum^m_{i=1}\alpha_i$$</p><p>$$s.t.\ C\geq\alpha_i \geq 0,i=1,2,…,m\quad \sum^m_{i=1}\alpha_iy_i=0,$$</p><hr><h4 id="Sequential-Minimal-Optimization"><a href="#Sequential-Minimal-Optimization" class="headerlink" title="Sequential Minimal Optimization"></a>Sequential Minimal Optimization</h4><p>首先定义特征到结果的输出函数：$u=w^Tx+b$.</p><p>因为$w=\sum\alpha_iy_ix_i$</p><p>有$u=\sum y_i\alpha_iK(x_i, x)-b$</p><hr><p>$\max \sum^m_{i=1}\alpha_i-\frac{1}{2}\sum^m_{i=1}\sum^m_{j=1}\alpha_i\alpha_jy_iy_j&lt;\phi(x_i)^T,\phi(x_j)&gt;$</p><p>$s.t.\ \sum^m_{i=1}\alpha_iy_i=0,$</p><p>$ \alpha_i \geq 0,i=1,2,…,m$</p><hr><p>参考资料：</p><p>[1] :<a href="http://blog.csdn.net/xianlingmao/article/details/7919597" target="_blank" rel="noopener">Lagrange Multiplier and KKT</a></p><p>[2] :<a href="https://my.oschina.net/dfsj66011/blog/517766" target="_blank" rel="noopener">推导SVM</a></p><p>[3] :<a href="http://pytlab.org/2017/08/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-SVM-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">机器学习算法实践-支持向量机(SVM)算法原理</a></p><p>[4] :<a href="http://blog.csdn.net/wds2006sdo/article/details/53156589" target="_blank" rel="noopener">Python实现SVM</a></p><h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><p>以下是利用sklearn的一个简单实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span>  train_test_split</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_data</span><span class="params">()</span>:</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">    df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span><br><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="keyword">if</span> data[i,<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            data[i,<span class="number">-1</span>] = <span class="number">-1</span></span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">return</span> data[:,:<span class="number">2</span>], data[:,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成数据集并显示 </span></span><br><span class="line">X, y = create_data()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.25</span>)</span><br><span class="line">plt.scatter(X[:<span class="number">50</span>,<span class="number">0</span>],X[:<span class="number">50</span>,<span class="number">1</span>], label=<span class="string">'0'</span>)</span><br><span class="line">plt.scatter(X[<span class="number">50</span>:,<span class="number">0</span>],X[<span class="number">50</span>:,<span class="number">1</span>], label=<span class="string">'1'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181224224634.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>数据集如上。</p><p>SVM实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVM</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_iter=<span class="number">100</span>, kernel=<span class="string">'linear'</span>)</span>:</span></span><br><span class="line">        self.max_iter = max_iter</span><br><span class="line">        self._kernel = kernel</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_args</span><span class="params">(self, features, labels)</span>:</span></span><br><span class="line">        self.m, self.n = features.shape</span><br><span class="line">        self.X = features</span><br><span class="line">        self.Y = labels</span><br><span class="line">        self.b = <span class="number">0.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将Ei保存在一个列表里</span></span><br><span class="line">        self.alpha = np.ones(self.m)</span><br><span class="line">        self.E = [self._E(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m)]</span><br><span class="line">        <span class="comment"># 松弛变量</span></span><br><span class="line">        self.C = <span class="number">1.0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_KKT</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        y_g = self._g(i)*self.Y[i]</span><br><span class="line">        <span class="keyword">if</span> self.alpha[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> y_g &gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="number">0</span> &lt; self.alpha[i] &lt; self.C:</span><br><span class="line">            <span class="keyword">return</span> y_g == <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> y_g &lt;= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># g(x)预测值，输入xi（X[i]）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_g</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        r = self.b</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.m):</span><br><span class="line">            r += self.alpha[j]*self.Y[j]*self.kernel(self.X[i], self.X[j])</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 核函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kernel</span><span class="params">(self, x1, x2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._kernel == <span class="string">'linear'</span>:</span><br><span class="line">            <span class="keyword">return</span> sum([x1[k]*x2[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n)])</span><br><span class="line">        <span class="keyword">elif</span> self._kernel == <span class="string">'poly'</span>:</span><br><span class="line">            <span class="keyword">return</span> (sum([x1[k]*x2[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n)]) + <span class="number">1</span>)**<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># E（x）为g(x)对输入x的预测值和y的差</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_E</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._g(i) - self.Y[i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_alpha</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 外层循环首先遍历所有满足0&lt;a&lt;C的样本点，检验是否满足KKT</span></span><br><span class="line">        index_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m) <span class="keyword">if</span> <span class="number">0</span> &lt; self.alpha[i] &lt; self.C]</span><br><span class="line">        <span class="comment"># 否则遍历整个训练集</span></span><br><span class="line">        non_satisfy_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> index_list]</span><br><span class="line">        index_list.extend(non_satisfy_list)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> index_list:</span><br><span class="line">            <span class="keyword">if</span> self._KKT(i):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            E1 = self.E[i]</span><br><span class="line">            <span class="comment"># 如果E2是+，选择最小的；如果E2是负的，选择最大的</span></span><br><span class="line">            <span class="keyword">if</span> E1 &gt;= <span class="number">0</span>:</span><br><span class="line">                j = min(range(self.m), key=<span class="keyword">lambda</span> x: self.E[x])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = max(range(self.m), key=<span class="keyword">lambda</span> x: self.E[x])</span><br><span class="line">            <span class="keyword">return</span> i, j</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_compare</span><span class="params">(self, _alpha, L, H)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> _alpha &gt; H:</span><br><span class="line">            <span class="keyword">return</span> H</span><br><span class="line">        <span class="keyword">elif</span> _alpha &lt; L:</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> _alpha      </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, features, labels)</span>:</span></span><br><span class="line">        self.init_args(features, labels)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(self.max_iter):</span><br><span class="line">            <span class="comment"># train</span></span><br><span class="line">            i1, i2 = self._init_alpha()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 边界</span></span><br><span class="line">            <span class="keyword">if</span> self.Y[i1] == self.Y[i2]:</span><br><span class="line">                L = max(<span class="number">0</span>, self.alpha[i1]+self.alpha[i2]-self.C)</span><br><span class="line">                H = min(self.C, self.alpha[i1]+self.alpha[i2])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = max(<span class="number">0</span>, self.alpha[i2]-self.alpha[i1])</span><br><span class="line">                H = min(self.C, self.C+self.alpha[i2]-self.alpha[i1])</span><br><span class="line">                </span><br><span class="line">            E1 = self.E[i1]</span><br><span class="line">            E2 = self.E[i2]</span><br><span class="line">            <span class="comment"># eta=K11+K22-2K12</span></span><br><span class="line">            eta = self.kernel(self.X[i1], self.X[i1]) + self.kernel(self.X[i2], self.X[i2]) - <span class="number">2</span>*self.kernel(self.X[i1], self.X[i2])</span><br><span class="line">            <span class="keyword">if</span> eta &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print('eta &lt;= 0')</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            alpha2_new_unc = self.alpha[i2] + self.Y[i2] * (E2 - E1) / eta</span><br><span class="line">            alpha2_new = self._compare(alpha2_new_unc, L, H)</span><br><span class="line">            </span><br><span class="line">            alpha1_new = self.alpha[i1] + self.Y[i1] * self.Y[i2] * (self.alpha[i2] - alpha2_new)</span><br><span class="line">            </span><br><span class="line">            b1_new = -E1 - self.Y[i1] * self.kernel(self.X[i1], self.X[i1]) * (alpha1_new-self.alpha[i1]) - self.Y[i2] * self.kernel(self.X[i2], self.X[i1]) * (alpha2_new-self.alpha[i2])+ self.b </span><br><span class="line">            b2_new = -E2 - self.Y[i1] * self.kernel(self.X[i1], self.X[i2]) * (alpha1_new-self.alpha[i1]) - self.Y[i2] * self.kernel(self.X[i2], self.X[i2]) * (alpha2_new-self.alpha[i2])+ self.b </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; alpha1_new &lt; self.C:</span><br><span class="line">                b_new = b1_new</span><br><span class="line">            <span class="keyword">elif</span> <span class="number">0</span> &lt; alpha2_new &lt; self.C:</span><br><span class="line">                b_new = b2_new</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 选择中点</span></span><br><span class="line">                b_new = (b1_new + b2_new) / <span class="number">2</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            self.alpha[i1] = alpha1_new</span><br><span class="line">            self.alpha[i2] = alpha2_new</span><br><span class="line">            self.b = b_new</span><br><span class="line">            </span><br><span class="line">            self.E[i1] = self._E(i1)</span><br><span class="line">            self.E[i2] = self._E(i2)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'train done!'</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        r = self.b</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">            r += self.alpha[i] * self.Y[i] * self.kernel(data, self.X[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> r &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span></span><br><span class="line">        right_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_test)):</span><br><span class="line">            result = self.predict(X_test[i])</span><br><span class="line">            <span class="keyword">if</span> result == y_test[i]:</span><br><span class="line">                right_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right_count / len(X_test)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># linear model</span></span><br><span class="line">        yx = self.Y.reshape(<span class="number">-1</span>, <span class="number">1</span>)*self.X</span><br><span class="line">        self.w = np.dot(yx.T, self.alpha)</span><br><span class="line">        <span class="keyword">return</span> self.w</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="人工智能" scheme="https://joshuaqyh.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习|K近邻算法及python实现</title>
    <link href="https://joshuaqyh.github.io/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://joshuaqyh.github.io/2018/12/24/机器学习-K近邻算法/</id>
    <published>2018-12-24T12:05:05.000Z</published>
    <updated>2019-03-08T06:32:03.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181224203312.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>k 近邻算法是一种经典且简单的机器学习算法之一，用于分类和回归。在本文只探讨分类问题中的 k 近邻法。</p><p>k 近邻算法是一种少数服从多数的思想。给定一个训练数据集，数据集中的每一条数据都由一个特征向量表出如$(x_1, x_2…)$，每一条数据对应一个类别即标签。</p><p>我们输入一个新数据的向量到该数据集中，我们找到与该实例<strong>最邻近</strong>的 $K$ 个实例，这$K$个实例中的多数属于某个类, 那么我们就把该输入实例分类到这个类中。（注：需要保证样本特征向量的长度一致）。</p><p>数据样本之间的距离可以用<strong>欧式距离和曼哈顿距离</strong>来衡量。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>欧氏距离计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L</span><span class="params">(x, y, p=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="comment"># x1 = [1, 1], x2 = [5,1]</span></span><br><span class="line">    <span class="keyword">if</span> len(x) == len(y) <span class="keyword">and</span> len(x) &gt; <span class="number">1</span>:</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">            sum += math.pow(abs(x[i] - y[i]), p)</span><br><span class="line">        <span class="keyword">return</span> math.pow(sum, <span class="number">1</span>/p)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Knn算法实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, X_train, y_train, n_neighbors=<span class="number">3</span>, p=<span class="number">2</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        parameter: n_neighbors 临近点个数</span></span><br><span class="line"><span class="string">        parameter: p 距离度量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.n = n_neighbors</span><br><span class="line">        self.p = p</span><br><span class="line">        self.X_train = X_train  <span class="comment"># 特征向量</span></span><br><span class="line">        self.y_train = y_train  <span class="comment"># 标签</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span>  <span class="comment"># 输入单一测试样例，给出分类</span></span><br><span class="line">        <span class="comment"># 取出n个点</span></span><br><span class="line">        knn_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], ord=self.p)</span><br><span class="line">            knn_list.append((dist, self.y_train[i]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n, len(self.X_train)):</span><br><span class="line">            max_index = knn_list.index(max(knn_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], ord=self.p)</span><br><span class="line">            <span class="keyword">if</span> knn_list[max_index][<span class="number">0</span>] &gt; dist:</span><br><span class="line">                knn_list[max_index] = (dist, self.y_train[i])</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 统计</span></span><br><span class="line">        knn = [k[<span class="number">-1</span>] <span class="keyword">for</span> k <span class="keyword">in</span> knn_list]</span><br><span class="line">        count_pairs = Counter(knn)</span><br><span class="line">        max_count = sorted(count_pairs, key=<span class="keyword">lambda</span> x:x)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> max_count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span>  <span class="comment"># 测试集的准确率</span></span><br><span class="line">        right_count = <span class="number">0</span></span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> zip(X_test, y_test):</span><br><span class="line">            label = self.predict(X)</span><br><span class="line">            <span class="keyword">if</span> label == y:</span><br><span class="line">                right_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right_count / len(X_test)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
    
      <category term="人工智能" scheme="https://joshuaqyh.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>人工智能 | 人工神经网络学习</title>
    <link href="https://joshuaqyh.github.io/2018/12/17/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    <id>https://joshuaqyh.github.io/2018/12/17/人工神经网络学习/</id>
    <published>2018-12-17T12:06:03.000Z</published>
    <updated>2019-05-16T14:01:57.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="神经元结构"><a href="#神经元结构" class="headerlink" title="神经元结构"></a>神经元结构</h2><p>神经元结构就是一个函数发生器：输入+函数运算+输出。</p><ul><li>输入是多个输入点$a$ 的加权(w)求和。 </li></ul><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181217200818.png" alt=""></p><ul><li><p>函数运算：激活函数。常用sigmoid函数。</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181217200939.png" alt=""></p></li><li><p>输出：一个输出值，可能作为其他神经元的输入点之一。</p></li></ul><h2 id="前馈网络"><a href="#前馈网络" class="headerlink" title="前馈网络"></a>前馈网络</h2><h3 id="单层前馈神经网络（感知器）"><a href="#单层前馈神经网络（感知器）" class="headerlink" title="单层前馈神经网络（感知器）"></a>单层前馈神经网络（感知器）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181217201840.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>​                                                            输入直接连接到输出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;神经元结构&quot;&gt;&lt;a href=&quot;#神经元结构&quot; class=&quot;headerlink&quot; title=&quot;神经元结构&quot;&gt;&lt;/a&gt;神经元结构&lt;/h2&gt;&lt;p&gt;神经元结构就是一个函数发生器：输入+函数运算+输出。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入是多个输入点$a$ 的加权(w)
      
    
    </summary>
    
    
      <category term="人工智能" scheme="https://joshuaqyh.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>基于以太坊的DApp学习开发之路</title>
    <link href="https://joshuaqyh.github.io/2018/12/11/DApp%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>https://joshuaqyh.github.io/2018/12/11/DApp学习之路/</id>
    <published>2018-12-11T13:47:18.000Z</published>
    <updated>2019-05-16T14:00:49.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备的知识"><a href="#准备的知识" class="headerlink" title="准备的知识"></a>准备的知识</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>React.js + Redux 用于前端组件设计和状态管理。拟学习MD组件库。</p><p>web3.js 与区块链数据交互通信 webpack</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>web3.js 与区块链交互 +  express 响应请求/路由功能+mongodb基本增删该查。</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>智能合约+测试部署+调用</p><p>solc + ganache + influa + truffle + metamask</p><p>！ IPFS</p><h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p><a href="https://medium.com/ethereum-developers/the-ultimate-end-to-end-tutorial-to-create-and-deploy-a-fully-descentralized-dapp-in-ethereum-18f0cf6d7e0e" target="_blank" rel="noopener">https://medium.com/ethereum-developers/the-ultimate-end-to-end-tutorial-to-create-and-deploy-a-fully-descentralized-dapp-in-ethereum-18f0cf6d7e0e</a> </p><h2 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h2><p>通过一个简单应用体会全栈Dapp过程。涉及框架 truffle ，IPFS，webpack，react，babel，web3</p><h2 id="开发核心步骤"><a href="#开发核心步骤" class="headerlink" title="开发核心步骤"></a>开发核心步骤</h2><p>步骤</p><ol><li>Setup the project</li><li>Program the Solidity contracts</li><li>Create the frontend application</li><li>Deploy the application online with IPFS</li><li>Use a custom domain for the application</li><li>Play with the final Dapp!</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备的知识&quot;&gt;&lt;a href=&quot;#准备的知识&quot; class=&quot;headerlink&quot; title=&quot;准备的知识&quot;&gt;&lt;/a&gt;准备的知识&lt;/h2&gt;&lt;h3 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前
      
    
    </summary>
    
    
      <category term="区块链" scheme="https://joshuaqyh.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="前端开发" scheme="https://joshuaqyh.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>编译原理 | 语法制导翻译法</title>
    <link href="https://joshuaqyh.github.io/2018/12/11/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%B3%95/"/>
    <id>https://joshuaqyh.github.io/2018/12/11/语法制导翻译法/</id>
    <published>2018-12-11T02:04:36.000Z</published>
    <updated>2019-03-27T13:51:47.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SDTS基本概念"><a href="#SDTS基本概念" class="headerlink" title="SDTS基本概念"></a>SDTS基本概念</h1><p>$语法制导翻译法SDTS = 一个源语言 + 一个目标语言 + 一组翻译规则$</p><p>SDTS的翻译规则是文法中的产生式再加上语义动作。</p><p>SDTS其形式定义T如下：</p><p>$$T = (V_T, V_N, \delta, R, S)$$</p><ul><li>$V_T$ 是一个有穷的输入字母表，包含源语言中的符号。</li><li>$V_N$ 是一个有穷的非终结符号集合。</li><li>$\delta$ 是一个有穷的输出字母表，包含出现翻译串或输出串中的那些符号。</li><li>$R$是形如$A\rightarrow w,y$的规则的有穷集合。</li><li>$S ∈ V_N$是一个开始符号。</li></ul><hr><blockquote><p>解释R中$A\rightarrow w, y$ 。</p></blockquote><p>w 是终结符和（或）非终结符组成的串； y是由$V_N$和（或）$\delta$中符号组成的串。</p><p>w 为规则的源成分；y为规则的翻译成分，出现在w，y中的非终结符必须是一一对应的。</p><hr><blockquote><p>T的基础源文法</p></blockquote><p> SDTS的基础源文法是一个CFG(上下文无关文法context-free-grammar）：$(V_N, V_T, P,S)$ </p><p>$P $是形如$A\rightarrow w（w$ 为源程序成分 )的产生式的集合。</p><p>从T中<strong>去掉输出字母表$\delta$ ，再从T的规则中移走翻译成分y,就可以得到T的基础源文法。</strong></p><hr><blockquote><p>T 的基础目标文法</p></blockquote><p>类似地，从T中去掉字母表$V_T$ 并从T的规则中移去源成分。</p><p>CFG：$(V_N, P, \delta, S)$。</p><p>P是形如$A \rightarrow y$(y为目标成分)产生式的集合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181211113425.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181211113456.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SDTS基本概念&quot;&gt;&lt;a href=&quot;#SDTS基本概念&quot; class=&quot;headerlink&quot; title=&quot;SDTS基本概念&quot;&gt;&lt;/a&gt;SDTS基本概念&lt;/h1&gt;&lt;p&gt;$语法制导翻译法SDTS = 一个源语言 + 一个目标语言 + 一组翻译规则$&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="编译原理" scheme="https://joshuaqyh.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>我的React学习路线</title>
    <link href="https://joshuaqyh.github.io/2018/12/07/%E6%88%91%E7%9A%84React%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://joshuaqyh.github.io/2018/12/07/我的React学习路线/</id>
    <published>2018-12-07T08:30:51.000Z</published>
    <updated>2019-05-16T14:02:37.526Z</updated>
    
    <content type="html"><![CDATA[<base href="gallery-by-react"><h1 id="官方文档入门"><a href="#官方文档入门" class="headerlink" title="官方文档入门"></a>官方文档入门</h1><p><a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">初步体会一个react的小应用</a></p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用组件定义标签</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"shopping-list"</span>&gt;</span><br><span class="line">        &lt;h1&gt;Shopping List <span class="keyword">for</span> &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Instagram&lt;/</span>li&gt;</span><br><span class="line">          &lt;li&gt;WhatsApp&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Oculus&lt;/</span>li&gt;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage: &lt;ShoppingList name="Mark" /&gt;</span></span><br></pre></td></tr></table></figure><hr><p>JSX语法：js内嵌html。</p><hr><p>组件之间传值：通过props</p><hr><p>基本流程：就是继承react组件基类，自定义组件及其行为。实例化之后填入html某一个标签中。</p><hr><p>组件内部结构：</p><ol><li>构造函数（如果要维护内部的state需要有，否则可删除）</li><li>内部自定义函数</li><li>render函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">       <span class="keyword">super</span>(props);</span><br><span class="line">       <span class="keyword">this</span>.state = &#123;</span><br><span class="line">         history: [&#123;</span><br><span class="line">           squares: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">         &#125;],</span><br><span class="line">         xIsNext: <span class="literal">true</span>,</span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;  </span><br><span class="line">   render() &#123;</span><br><span class="line">       <span class="keyword">const</span> history = <span class="keyword">this</span>.state.history;</span><br><span class="line">       <span class="keyword">const</span> current = history[history.length - <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">const</span> winner  = calculateWinner(current.squares);</span><br><span class="line">       <span class="keyword">let</span> status;</span><br><span class="line">       <span class="keyword">if</span> (winner) &#123;</span><br><span class="line">           status = <span class="string">'Winner: '</span> + winner;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           status = <span class="string">'Next player: '</span> + (<span class="keyword">this</span>.state.xIsNext ? <span class="string">'X'</span> : <span class="string">'O'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">       &lt;div className=<span class="string">"game"</span>&gt;</span><br><span class="line">         &lt;div className=<span class="string">"game-board"</span>&gt;</span><br><span class="line">           &lt;Board squares=&#123;current.squares&#125;</span><br><span class="line">           onClick=&#123;(i) =&gt; <span class="keyword">this</span>.handleClick(i)&#125;/&gt;</span><br><span class="line">         &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">         &lt;div className="game-info"&gt;</span></span><br><span class="line"><span class="regexp">           &lt;div&gt;&#123;status&#125;&lt;/</span>div&gt;</span><br><span class="line">           &lt;ol&gt;&#123;<span class="comment">/* TODO */</span>&#125;&lt;<span class="regexp">/ol&gt;</span></span><br><span class="line"><span class="regexp">         &lt;/</span>div&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">     );</span></span><br><span class="line"><span class="regexp">   &#125;</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> /</span><span class="regexp">/ ========================================</span></span><br><span class="line"><span class="regexp"> /</span><span class="regexp">/ 调用函数进行渲染</span></span><br><span class="line"><span class="regexp"> ReactDOM.render(</span></span><br><span class="line"><span class="regexp">   &lt;Game /</span>&gt;,</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"> );</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><hr><p>组件结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Componet</span></span>&#123;</span><br><span class="line">    construct(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;   <span class="comment">// state 存储本组件的变量成员</span></span><br><span class="line">            变量： 值，  <span class="comment">// props 上层组件调用的传入的变量</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他处理的函数</span></span><br><span class="line">    func()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后的渲染函数，返回html元素</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 一些变量处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span>/&gt;</span>);</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"> ReactDOM.render(</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">example</span> /&gt;</span>,  // 此处将组件作为标签渲染</span></span><br><span class="line"><span class="xml">    document.getElementById('root') // 查找root 标签，将组件填入</span></span><br><span class="line"><span class="xml">  );</span></span><br></pre></td></tr></table></figure><h1 id="慕课网视频"><a href="#慕课网视频" class="headerlink" title="慕课网视频"></a>慕课网视频</h1><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181207195500.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181207195542.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上述是一些hook函数，可以以下面的方式调用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181207200247.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><p>定义事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = React.createClass(&#123;</span><br><span class="line">change: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tipE = React.findDOMNode(<span class="string">"tip"</span>);</span><br><span class="line">        <span class="keyword">if</span>(tip.display == <span class="string">'none'</span>)</span><br><span class="line">            tip.display = <span class="string">'inline'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tip.display = <span class="string">'none'</span>;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">        evnet.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick = &#123;<span class="keyword">this</span>.change&#125;&gt; click &lt;button/&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span> = <span class="string">"tip"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    );    </span></span><br><span class="line"><span class="xml">&#125;    </span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><h1 id="React-项目"><a href="#React-项目" class="headerlink" title="React 项目"></a>React 项目</h1><ul><li>yomen使用学习</li><li>体会网页版的todoapp</li></ul><p><a href="https://yeoman.io/codelab/review-generated-files.html" target="_blank" rel="noopener">https://yeoman.io/codelab/review-generated-files.html</a></p><ul><li><p>画廊应用</p></li><li><p>facebook  creact-react-app 项目 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">https://github.com/facebook/create-react-app</a>  npm init react-app my-app</p></li><li><p>Material  design学习</p><p><a href="https://material-ui.com/getting-started/page-layout-examples/" target="_blank" rel="noopener">https://material-ui.com/getting-started/page-layout-examples/</a></p></li><li><p>react 路由实现组件之间的切换</p></li></ul><p><a href="https://www.jianshu.com/p/8fcf8d27b9fe" target="_blank" rel="noopener">https://www.jianshu.com/p/8fcf8d27b9fe</a></p><ul><li>多人投票项目，待办</li><li>MERN 全栈开发 pdf ，待办。</li></ul><h1 id="Redux-学习"><a href="#Redux-学习" class="headerlink" title="Redux 学习"></a>Redux 学习</h1><p><a href="https://redux-docs.netlify.com/introduction/learning-resources" target="_blank" rel="noopener">https://redux-docs.netlify.com/introduction/learning-resources</a> </p><p>官方介绍和推荐学习资源 ！</p><p><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">http://cn.redux.js.org/</a>  中文文档</p><p>action 组件可能的行为，需要先定义分类type，然后再生成行为createaction</p><hr><p>reducer 根据当前状态行为确定下一步状态，(previousState, action) =&gt; newState</p><p> It’s very important that the reducer stays pure. Things you should <strong>never</strong> do inside a reducer:</p><ul><li>Mutate its arguments;</li><li>Perform side effects like API calls and routing transitions;</li><li>Call non-pure functions, e.g. <code>Date.now()</code> or <code>Math.random()</code></li></ul><hr><p>container将redux和react组件绑定在一起</p><hr><p>store 维持应用状态</p><ul><li>Holds application state;</li><li>Allows access to state via <a href="https://redux-docs.netlify.com/api/store#getState" target="_blank" rel="noopener"><code>getState()</code></a>;</li><li>Allows state to be updated via <a href="https://redux-docs.netlify.com/api/store#dispatch" target="_blank" rel="noopener"><code>dispatch(action)</code></a>;</li><li>Registers listeners via <a href="https://redux-docs.netlify.com/api/store#subscribe" target="_blank" rel="noopener"><code>subscribe(listener)</code></a>;</li><li>Handles unregistering of listeners via the function returned by <a href="https://redux-docs.netlify.com/api/store#subscribe" target="_blank" rel="noopener"><code>subscribe(listener)</code></a>.</li></ul><h3 id="官方代码学习："><a href="#官方代码学习：" class="headerlink" title="官方代码学习："></a>官方代码学习：</h3><hr><h3 id="一个简单的计时器应用"><a href="#一个简单的计时器应用" class="headerlink" title="一个简单的计时器应用"></a>一个简单的计时器应用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口文件 index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>  </span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./components/Counter'</span></span><br><span class="line"><span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(counter)  <span class="comment">// 获取存储</span></span><br><span class="line"><span class="keyword">const</span> rootEl = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> ReactDOM.render(</span><br><span class="line">  &lt;Counter</span><br><span class="line">    value=&#123;store.getState()&#125;  <span class="comment">// 将store中的state值传入组件的值</span></span><br><span class="line">    onIncrement=&#123;() =&gt; store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)&#125;  <span class="comment">//为组件注册store中的方法 </span></span><br><span class="line">    onDecrement=&#123;() =&gt; store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)&#125;</span><br><span class="line">  /&gt;,</span><br><span class="line">  rootEl</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">render()  <span class="comment">// 渲染</span></span><br><span class="line">store.subscribe(render) <span class="comment">// 为渲染结果进行stroe的订阅</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducer 文件，根据传入的行为定义响应结果</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = <span class="number">0</span>, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义时钟组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.incrementAsync = <span class="keyword">this</span>.incrementAsync.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.incrementIfOdd = <span class="keyword">this</span>.incrementIfOdd.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  incrementIfOdd() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.value % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.onIncrement()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  incrementAsync() &#123;</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.props.onIncrement, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onIncrement, onDecrement &#125; = <span class="keyword">this</span>.props   <span class="comment">//获取上层调用的参数</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Clicked: &#123;value&#125; times         <span class="comment">// 将上层传来的值绑定在组件的属性之上</span></span><br><span class="line">        &#123;<span class="string">' '</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;onIncrement&#125;&gt;      <span class="comment">// 将上层定义的事件绑定给下层组件</span></span><br><span class="line">          +</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;onDecrement&#125;&gt;</span></span><br><span class="line"><span class="regexp">          -</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">        &#123;<span class="string">' '</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.incrementIfOdd&#125;&gt;</span><br><span class="line">          Increment <span class="keyword">if</span> odd</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;' '&#125;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.incrementAsync&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Increment async</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Counter.propTypes = &#123;  /</span><span class="regexp">/ 组件的属性</span></span><br><span class="line"><span class="regexp">  value: PropTypes.number.isRequired,</span></span><br><span class="line"><span class="regexp">  onIncrement: PropTypes.func.isRequired,</span></span><br><span class="line"><span class="regexp">  onDecrement: PropTypes.func.isRequired</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter</span></span><br></pre></td></tr></table></figure><hr><h3 id="Todos-简单应用学习"><a href="#Todos-简单应用学习" class="headerlink" title="Todos 简单应用学习"></a>Todos 简单应用学习</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/20181211013218.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>react-redux中<strong>Provider</strong>的概念，相当于一个顶层的组件，直接存储了store。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>  <span class="comment">// </span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>  <span class="comment">// render 对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>  <span class="comment">// 从redux引入createStore方法创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span> <span class="comment">// 引入顶层组件，注册store</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>   <span class="comment">// 引入App组件，核心组件</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>  <span class="comment">// 一次性引入多个reducer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer)  </span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><ul><li>学习reducer 如何向其他reducer托管处理行为的逻辑。</li></ul><p>reducer中，index.js中<strong>combineReducers</strong>为汇总的reducer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducers/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">'./todos'</span></span><br><span class="line"><span class="keyword">import</span> visibilityFilter <span class="keyword">from</span> <span class="string">'./visibilityFilter'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;   <span class="comment">//联合其他reducer</span></span><br><span class="line">  todos,</span><br><span class="line">  visibilityFilter</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /reducers/todos.js  ??</span></span><br><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>: <span class="comment">// 添加一条todo</span></span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          id: action.id,</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>: <span class="comment">// 完成todo</span></span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span></span><br><span class="line">        (todo.id === action.id)</span><br><span class="line">          ? &#123;...todo, <span class="attr">completed</span>: !todo.completed&#125;</span><br><span class="line">          : todo</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todos</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reducers/visibilityFillter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; VisibilityFilters &#125; <span class="keyword">from</span> <span class="string">'../actions'</span>  <span class="comment">// 将行为交给其他模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visibilityFilter = <span class="function">(<span class="params">state = VisibilityFilters.SHOW_ALL, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SET_VISIBILITY_FILTER'</span>: <span class="comment">// 设置可视化条件</span></span><br><span class="line">      <span class="keyword">return</span> action.filter</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> visibilityFilter</span><br></pre></td></tr></table></figure><p>定义行为类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以把type和 actioncreator分开</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextTodoId = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = <span class="function"><span class="params">text</span> =&gt;</span> (&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  id: nextTodoId++,</span><br><span class="line">  text</span><br><span class="line">&#125;)  <span class="comment">// 添加todo 行为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibilityFilter = <span class="function"><span class="params">filter</span> =&gt;</span> (&#123;</span><br><span class="line">  type: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">  filter</span><br><span class="line">&#125;)  <span class="comment">// 设置可视化条件，点击active 按钮或者completed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;</span><br><span class="line">  type: <span class="string">'TOGGLE_TODO'</span>,</span><br><span class="line">  id</span><br><span class="line">&#125;)  <span class="comment">// 删除待办</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> VisibilityFilters = &#123;</span><br><span class="line">  SHOW_ALL: <span class="string">'SHOW_ALL'</span>,</span><br><span class="line">  SHOW_COMPLETED: <span class="string">'SHOW_COMPLETED'</span>,</span><br><span class="line">  SHOW_ACTIVE: <span class="string">'SHOW_ACTIVE'</span></span><br><span class="line">&#125;  <span class="comment">// 可视化</span></span><br></pre></td></tr></table></figure><p>表面组件和容器组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./Footer'</span></span><br><span class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">'../containers/AddTodo'</span></span><br><span class="line"><span class="keyword">import</span> VisibleTodoList <span class="keyword">from</span> <span class="string">'../containers/VisibleTodoList'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;AddTodo /&gt;</span><br><span class="line">    &lt;VisibleTodoList /&gt;</span><br><span class="line">    &lt;Footer /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="comment">/////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AddTodo.js</span></span><br><span class="line"><span class="comment">// 这个逻辑比较简单，分发add todo 事件即可</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; addTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AddTodo = <span class="function">(<span class="params">&#123; dispatch &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> input</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="keyword">if</span> (!input.value.trim()) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dispatch(addTodo(input.value))  <span class="comment">// 分发addtodo行为，在action中定义好了</span></span><br><span class="line">        input.value = <span class="string">''</span></span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;input ref=&#123;node =&gt; input = node&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;</span><br><span class="line">          Add Todo</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default connect()(AddTodo)   /</span><span class="regexp">/ 将react组件使用connect建立起redux和react之间的联系</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="comment">////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FilterLink.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; setVisibilityFilter &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'../components/Link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class="line">  active: ownProps.filter === state.visibilityFilter</span><br><span class="line">&#125;) <span class="comment">// Link组件的属性active，通过比较组件当前状态和上级传入状态，确定是否隐藏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class="line">  onClick: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class="line">&#125;) <span class="comment">// link组件的点击事件，根据分发事件来确定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,  </span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Link)    <span class="comment">// 将两个事件处理绑定在link组件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////  组件之中无需注意事件分发逻辑，只需要暴露组件事件分发的接口</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Link = <span class="function">(<span class="params">&#123; active, children, onClick &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">       onClick=&#123;onClick&#125;</span><br><span class="line">       disabled=&#123;active&#125;</span><br><span class="line">       style=&#123;&#123;</span><br><span class="line">           marginLeft: <span class="string">'4px'</span>,</span><br><span class="line">       &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Link.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  active: PropTypes.bool.isRequired,</span></span><br><span class="line"><span class="regexp">  children: PropTypes.node.isRequired,</span></span><br><span class="line"><span class="regexp">  onClick: PropTypes.func.isRequired</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Link</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// visibletodolist.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span></span><br><span class="line"><span class="keyword">import</span> &#123; VisibilityFilters &#125; <span class="keyword">from</span> <span class="string">'../actions'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据fiter 确定reducer todos如何确定操作</span></span><br><span class="line"><span class="keyword">const</span> getVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (filter) &#123;  <span class="comment">// fiter是state.visibilityFilter，一个reducer，会根据分发的action确定返回action.filter,即是显示active还是显示completed，然后todos也是一个reducer将会根据显示条件，对todo进行分类，</span></span><br><span class="line">    <span class="keyword">case</span> VisibilityFilters.SHOW_ALL:</span><br><span class="line">      <span class="keyword">return</span> todos</span><br><span class="line">    <span class="keyword">case</span> VisibilityFilters.SHOW_COMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</span><br><span class="line">    <span class="keyword">case</span> VisibilityFilters.SHOW_ACTIVE:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown filter: '</span> + filter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> (&#123;  <span class="comment">// 得到状态，显示todo</span></span><br><span class="line">  todos: getVisibleTodos(state.todos, state.visibilityFilter) <span class="comment">// state代表一个全局顶层的reducer</span></span><br><span class="line">&#125;) <span class="comment">// state.todos 代表一个reducer，第二个参数也是，返回一个todo的显示与否的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;  <span class="comment">// 分发事件的行为，点击待办，删除</span></span><br><span class="line">  toggleTodo: <span class="function"><span class="params">id</span> =&gt;</span> dispatch(toggleTodo(id))  <span class="comment">// 按id区分行为</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)   <span class="comment">// 对组件todolist todos和toggleTodo属性进行状态和分发事件的绑定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////// todolist 事件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">'./Todo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TodoList = <span class="function">(<span class="params">&#123; todos, toggleTodo &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;todos.map(<span class="function"><span class="params">todo</span> =&gt;</span></span><br><span class="line">      &lt;Todo</span><br><span class="line">        key=&#123;todo.id&#125;</span><br><span class="line">        &#123;...todo&#125;  <span class="comment">// 按照id来分配是否toggletodo事件</span></span><br><span class="line">        onClick=&#123;() =&gt; toggleTodo(todo.id)&#125; <span class="comment">// 先确定行为属于toggleTodo，然后reducer解决处理，确定todo的completed的值，todo.id ,todo代表状态todos中的一条todo，todo.id为todo的序号，传入id后将会对该todo的completed取反，结果会导致本来是横线会变无横线，或者无横线变有横线</span></span><br><span class="line">      /&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">TodoList.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  todos: PropTypes.arrayOf(PropTypes.shape(&#123;</span></span><br><span class="line"><span class="regexp">    id: PropTypes.number.isRequired,</span></span><br><span class="line"><span class="regexp">    completed: PropTypes.bool.isRequired,</span></span><br><span class="line"><span class="regexp">    text: PropTypes.string.isRequired</span></span><br><span class="line"><span class="regexp">  &#125;).isRequired).isRequired,</span></span><br><span class="line"><span class="regexp">  toggleTodo: PropTypes.func.isRequired</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoList</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="comment">// todo.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单条todo的三个属性</span></span><br><span class="line"><span class="keyword">const</span> Todo = <span class="function">(<span class="params">&#123; onClick, completed, text &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li</span><br><span class="line">    onClick=&#123;onClick&#125;</span><br><span class="line">    style=&#123;&#123; <span class="comment">// 属性与上层todolist绑定</span></span><br><span class="line">      textDecoration: completed ? <span class="string">'line-through'</span> : <span class="string">'none'</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;text&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Todo.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  onClick: PropTypes.func.isRequired,</span></span><br><span class="line"><span class="regexp">  completed: PropTypes.bool.isRequired,</span></span><br><span class="line"><span class="regexp">  text: PropTypes.string.isRequired</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Todo</span></span><br></pre></td></tr></table></figure><hr><h3 id="todos-with-undo"><a href="#todos-with-undo" class="headerlink" title="todos-with-undo"></a>todos-with-undo</h3><p>使用redux undo实现用更少的代码撤销或者回退上一步（取消撤销）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义好todos 这一个reducer，然后下面这句，最后export undoabletodos</span></span><br><span class="line"><span class="keyword">const</span> undoableTodos = undoable(todos, &#123; <span class="attr">filter</span>: includeAction([<span class="string">'ADD_TODO'</span>, <span class="string">'TOGGLE_TODO'</span>]) &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在redo 和undo按钮中，注册redo </span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ActionCreators <span class="keyword">as</span> UndoActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux-undo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> UndoRedo = <span class="function">(<span class="params">&#123; canUndo, canRedo, onUndo, onRedo &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;button onClick=&#123;onUndo&#125; disabled=&#123;!canUndo&#125;&gt;</span><br><span class="line">      Undo</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;onRedo&#125; disabled=&#123;!canRedo&#125;&gt;</span></span><br><span class="line"><span class="regexp">      Redo</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">  canUndo: state.todos.past.length &gt; 0,  /</span><span class="regexp">/state.todos相当于undoableTodos</span></span><br><span class="line"><span class="regexp">  canRedo: state.todos.future.length &gt; 0</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = (&#123;</span></span><br><span class="line"><span class="regexp">  onUndo: UndoActionCreators.undo,  /</span><span class="regexp">/ 这一步是 考虑组件变化记忆？？？</span></span><br><span class="line"><span class="regexp">  onRedo: UndoActionCreators.redo</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">UndoRedo = connect(</span></span><br><span class="line"><span class="regexp">  mapStateToProps,</span></span><br><span class="line"><span class="regexp">  mapDispatchToProps</span></span><br><span class="line"><span class="regexp">)(UndoRedo)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default UndoRedo</span></span><br></pre></td></tr></table></figure><hr><p>redux中数据的生命周期主要是以下四个步骤：</p><ol><li>你调用事件分发 store.dispatch(action)</li><li>redux 的store调用给定好的reducer函数</li><li>root reducer将多个reducers函数的输出值装入一个单一的状态树</li><li>​</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;base href=&quot;gallery-by-react&quot;&gt;

&lt;h1 id=&quot;官方文档入门&quot;&gt;&lt;a href=&quot;#官方文档入门&quot; class=&quot;headerlink&quot; title=&quot;官方文档入门&quot;&gt;&lt;/a&gt;官方文档入门&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://react
      
    
    </summary>
    
    
      <category term="前端开发" scheme="https://joshuaqyh.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>IPSec 学习</title>
    <link href="https://joshuaqyh.github.io/2018/12/07/IPSec-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://joshuaqyh.github.io/2018/12/07/IPSec-学习/</id>
    <published>2018-12-07T02:11:34.000Z</published>
    <updated>2018-12-07T03:27:13.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP-Sec-定义"><a href="#IP-Sec-定义" class="headerlink" title="IP Sec 定义"></a>IP Sec 定义</h1><p>IPSec全称是<code>Internet Protocol Security</code> ，因特网协议安全，由IETF官方定义。</p><p><code>RFC-1825 to RFC-1827</code>。属于一种协议套件，通过认证和加密数据包来保证因特网安全通信。</p><ul><li><p>属于端到端的安全模式。</p></li><li><p>保护跨IP网络的应用层通信。但应用层无需设计使用ＩＰＳｅｃ。</p><ul><li>可以使用SSL（安全套接字），TLS（传输层安全），安全壳（SSH）。</li></ul></li><li><p>ＩＰＳｅｃ是ISO标准网络层安全协议的后继者。</p></li><li><p>IP协议的安全性：使用IPＳｅｃ解决</p></li><li><p>IPＳｅｃ提供网络层加密方案，在网络层对内容先加密再传输。</p><ul><li>数据加密方式有<ul><li>传输模式：对数据部分ｐａｙｌｏａｄ加密。</li><li>隧道模式：对整个IP分组进行加密。</li></ul></li></ul></li></ul><h1 id="数据保护措施"><a href="#数据保护措施" class="headerlink" title="数据保护措施"></a>数据保护措施</h1><ul><li>数据保密：使用各种加密手法。主要是对称加密技术。要保证公钥的合法性，我们需要确认发送证书的一方不是伪装的攻击者。Ｘ．５０９证书作为可信第三方为通信双方做身份验证。或者使用预共享的密钥，RSA密钥。</li><li>数据完整性度量：保证数据完整。数据做摘要，完整接收后再进行摘要比对。</li><li>来源认证：确认收发双方，以信息摘要的方式解决。信息摘要种包含了发送方的地址信息HMAC</li><li>防止重放攻击：加上时间戳＋随机数，保证消息唯一区分。</li></ul><h1 id="IPSec-的一些基本理念"><a href="#IPSec-的一些基本理念" class="headerlink" title="IPSec 的一些基本理念"></a>IPSec 的一些基本理念</h1><h3 id="AH认证头协议"><a href="#AH认证头协议" class="headerlink" title="AH认证头协议"></a>AH认证头协议</h3><p>AH比ESP相比具有更强的<strong>认证</strong>能力。能有效在数据传送过程中对数据进行完整性度量度量和来源认证，防止重放攻击。</p><p>工作原理：在IP数据报前加上一个身份验证报头，报头中有一个带密钥的Hash值。</p><p>可单独使用，也可以和ESP协议结合使用。</p><h3 id="ESP封装安全载荷协议"><a href="#ESP封装安全载荷协议" class="headerlink" title="ESP封装安全载荷协议"></a>ESP封装安全载荷协议</h3><p>能够对数据进行完整性度量，来源认证和加密，防止重放攻击。</p><ul><li><p>ESP服务依据建立的SA，对可选项目有所限制</p><ul><li>完整性检查和验证一起进行</li></ul></li><li><p>加密服务是可选的。启用加密，那么也就启用了完整性检车和认证。</p></li><li><p>一般情况下，ESP只加密数据报中有效载荷部分（传输模式），在端对端的隧道通信下，需要开启隧道模式。</p></li><li><p>ESP报头位置在IP报头之后，在TCP，UDP报头之前。</p></li><li><p>可以与AH协议结合使用，也可以单独使用。</p><p>​</p></li></ul><h3 id="Tunnel隧道模式"><a href="#Tunnel隧道模式" class="headerlink" title="Tunnel隧道模式"></a>Tunnel隧道模式</h3><p>加密原IP报文，作为数据内容，在这段数据内容之前，加上ESP或AH协议头，加上新的IP头，形成IPSec报文进行传输。</p><h3 id="Transport-Mode传输模式"><a href="#Transport-Mode传输模式" class="headerlink" title="Transport Mode传输模式"></a>Transport Mode传输模式</h3><p>仅保护IP报文中的有效载荷部分，在该过程中原报文结构被修改。然后在修改后有效载荷前加上新的ESP或AH协议头，装回原来的IP地址，形成IPSec报文。</p><h3 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h3><p>安全关联。可以认为是某一连接被IPSec保护的唯一标识。</p><p>SA是单向的，一次连接，通信双方都需要创建一个SA。</p><h3 id="SAD"><a href="#SAD" class="headerlink" title="SAD"></a>SAD</h3><p>  安全关联数据库。</p><p>SAD条目：</p><ol><li>顺序号计数器</li><li>顺序号溢出计数器</li><li>防止回放窗口</li><li>SA有效期</li><li>AH协议中所使用的算法和密钥</li><li>ESP协议 涉及加密认证的算法和密钥</li><li>IPSec运行模式</li><li>PMTU 两个通信设备间的MTU</li></ol><p>除了SAD外还有 SPI，SPD，IKE</p><h1 id="ESP协议"><a href="#ESP协议" class="headerlink" title="ESP协议"></a>ESP协议</h1><p>１.　主要了解隧道模式下IPSec数据报结构。</p><p>新IP头 + ESP头 + 加密原数据报 + 加密ESP尾 + ESP的MAC验证码</p><p>２.　传输模式下的ＩＰＳｅｃ数据报结构</p><p>原IP头＋ESP头＋加密的原IP数据报文＋加密的ESP尾＋ESP－MAC　</p><h1 id="AH协议"><a href="#AH协议" class="headerlink" title="AH协议"></a>AH协议</h1><p>不加密，供验证。消息高，不防窃听。</p><h1 id="IKE-因特网密钥交换"><a href="#IKE-因特网密钥交换" class="headerlink" title="IKE 因特网密钥交换"></a>IKE 因特网密钥交换</h1><p>几种IKE协议。</p><p>ISAKMP：用于建立SA，密钥。</p><p>Oakley：允许在非安全连接中安全交换密钥</p><p>SKEME：安全密钥交换机制。</p><h1 id="Gateway-模式和Road-Warrior模式"><a href="#Gateway-模式和Road-Warrior模式" class="headerlink" title="Gateway 模式和Road Warrior模式"></a>Gateway 模式和Road Warrior模式</h1><p>IPSec适用于：</p><ol><li>两个私有网络通过因特网对接</li><li>因特网接入私有网络</li></ol><p>需要保护好通信数据。</p><p>Gateway模式是网关之间的通信，只需要在网关上设置好IPSec模式。</p><p>Road Warrior模式一头是网关，另外一头是单个客户端。</p><p><em>注： 私有网络内部主机默认为安全，没有必要对私有网络中的每一个设备配置ＩＰｓｅｃ</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP-Sec-定义&quot;&gt;&lt;a href=&quot;#IP-Sec-定义&quot; class=&quot;headerlink&quot; title=&quot;IP Sec 定义&quot;&gt;&lt;/a&gt;IP Sec 定义&lt;/h1&gt;&lt;p&gt;IPSec全称是&lt;code&gt;Internet Protocol Security&lt;/
      
    
    </summary>
    
    
      <category term="信息安全" scheme="https://joshuaqyh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java实现MD算法并验证</title>
    <link href="https://joshuaqyh.github.io/2018/12/07/Java%E5%AE%9E%E7%8E%B0MD%E7%AE%97%E6%B3%95%E5%B9%B6%E9%AA%8C%E8%AF%81/"/>
    <id>https://joshuaqyh.github.io/2018/12/07/Java实现MD算法并验证/</id>
    <published>2018-12-06T16:44:10.000Z</published>
    <updated>2018-12-06T16:54:24.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验环境说明"><a href="#一、实验环境说明" class="headerlink" title="一、实验环境说明"></a>一、实验环境说明</h2><p>操作系统：window10</p><p>编程语言：Java （JDK版本 11.0.1）</p><p>使用IDE：Intellij IDEA</p><h2 id="二、算法原理概述"><a href="#二、算法原理概述" class="headerlink" title="二、算法原理概述"></a>二、算法原理概述</h2><h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><p> 整个MD5（信息摘要算法5）的基本过程可以概括为以下几个步骤：</p><ol><li><p><strong>填充</strong>：消息为 $K$ bits的原始消息数据尾部填充长度为$P$ bits的标识$1000…0 \, 1\le P \le 512$ （至少要填充一个bit) 。使得填充后的消息位数满足$K + P \equiv 448 (mod \, 512)$ (注：当$K \equiv 448(mod \, 512)$)时，$P = 512$。</p><p>填充好的消息尾部需要在附加 $K$值的低64位即$K \, mod \,2^{64}$。 最终结果得到  $K + P  + 64 \equiv 0 (mod \, 512)$的<strong>填充消息</strong>。</p></li><li><p><strong>分块</strong>：把填充之后的消息结果分割为$L$个$512-bit$ 分组：$Y_0..Y_{L-1}$ 。也是$L$个64字节的分组。</p></li></ol><ol><li><strong>缓冲区初始化</strong>：初始化一个$128-bit$的MD缓冲区，记为$CV_q$，表示成4个$32-bit (4个byte)$ 的寄存器$(A,B,C,D)$；$CV_0 = IV (IV为16进制初值)$。</li></ol><ol><li><p><strong>循环压缩</strong> ：对L个消息分组$Y_q(q = 0, 1,…L-1)$ ，逐个经过4重循环的压缩算法。表示为：</p><p>$$CV_0 = IV$$ </p><p>$$CV_i = H_{MD5}(CV_{i-1}, Y_i)$$</p></li><li><p><strong>得出结果</strong>：最后一个消息分组经过$H_{MD5}$压缩得到MD5结果为MD值，即$MD = CV_L$。</p><p>​</p></li></ol><h3 id="核心压缩步骤"><a href="#核心压缩步骤" class="headerlink" title="核心压缩步骤"></a>核心压缩步骤</h3><ol><li><strong>总控流程</strong>：$H_{MD5}$ 从$CV$输入128位，分配到缓冲区$(A,B,C,D)$，从消息分组输入512位$Y_q$ ，经过4轮循环，每次循环16次迭代（共64次迭代）之后，得到用于下一轮的输入的$CV$值。如果$Yq = Y_{L-1}$，即输出MD5值。</li><li><strong>每轮循环</strong>：结合T表元素$T[]$和消息分组的不同部分$X[]$，每轮固定不同的生成函数$F，G，H，I$做16次迭代运算，生成下一轮循环的输入。</li><li>四个生成函数$F,G,H,I$</li></ol><ol start="4"><li><p>消息分组的内容：需要靠下标k来进行运算得到参与 迭代的消息部分，代表当前处理消息分组的第$k$个$(k = 0…15)32$位字，即$M_{q × 16 + k}$。</p><p>在各轮循环中第$i$ 次迭代$(i = 1..16)$ 使用的$X[k]$ 的确定：</p><p>​    设$j = i -1$：<br>◌    第1轮迭代：$k = j$.</p><pre><code>顺序使用 $ X[0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15]$</code></pre><p>◌    第2轮迭代：$k = (1 + 5j) mod 16$.</p><pre><code>顺序使用$X[1, 6,11, 0, 5,10,15, 4, 9,14, 3, 8,13, 2, 7,12]$</code></pre><p>◌    第3轮迭代：$k = (5 + 3j) mod 16$.</p><pre><code>顺序使用$X[5, 8,11,14, 1, 4, 7,10,13, 0, 3, 6, 9,12,15, 2]$</code></pre><p>◌    第4轮迭代：$k = 7j mod 16$.</p><pre><code>顺序使用$X[0, 7,14, 5,12, 3,10, 1, 8,15, 6,13, 4,11, 2, 9]$</code></pre></li><li><p>T 表元素的生成：共有64个元素，用于64次的迭代，每个元素的计算如下。</p><p>$$T[i] = int(2_{32}×|sin(i)|)$$<br>$$ int为 取整函数，sin正弦函数，以i 作为弧度输入。$$</p></li><li><p>移位数s的确定：<br>s表共有64个元素，用于64次迭代，各次迭代运算采用的左循环移位的s 值：<br>$$s[ 1..16] = { 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22 }$$<br>$$s[17..32] = { 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20 } $$<br>$$s[33..48] = { 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23 }$$<br>$$s[49..64] = { 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 }$$</p></li><li><p><strong>一次迭代运算逻辑</strong>: $a,b,c,d$为寄存器$A,B,C,D$的内容，每轮循环重的一次迭代运算逻辑如下:</p><ol><li>对寄存器A进行迭代：$a \leftarrow b + ((a + g(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)$ </li><li>对缓冲区的内容进行向左循环变换，即$(B,C,D,A) \leftarrow (A,B,C,D)$。<br>$X[k]$为消息分组的部分内容，$g(b,c,d)$为生成函数，$T[i]$为T表元素，$s$为移位数。<br>​</li></ol></li></ol><h2 id="三、程序设计"><a href="#三、程序设计" class="headerlink" title="三、程序设计"></a>三、程序设计</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>本程序使用的数据数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] M;                  <span class="comment">/* 存放消息字节数组 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span>[] T = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">64</span>];   <span class="comment">/* 迭代运算的T表， 64个元素，每个元素有32bits，16进制8位 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*在迭代中的消息数组*/</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span>[] X = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*四个寄存器A，B，C，D，构成128bits的迭代缓冲区*/</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> A = <span class="number">0x67452301</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> B = <span class="number">0xEFCDAB89</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> C = <span class="number">0x98BADCFE</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> D = <span class="number">0x10325476</span>;</span><br></pre></td></tr></table></figure><p>消息数组M的生成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(inputString);   <span class="comment">// 读入文件流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);   <span class="comment">// 将文件流读入缓冲区</span></span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(bis);           <span class="comment">// 将缓冲区数据写入数据流</span></span><br><span class="line"></span><br><span class="line">M = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) (length + paddingLength + <span class="number">8</span>)];     <span class="comment">// 填充消息最终长度  满足于 length + padding + 8 = 0 mod 64  字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件内容读入全部字节数组M中并填充</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + paddingLength; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>( i &lt; length)&#123;</span><br><span class="line">      M[i] = (<span class="keyword">byte</span>)dis.read();</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == length)&#123;</span><br><span class="line">      M[i] = (<span class="keyword">byte</span>)<span class="number">128</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       M[i] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代运算中的T表数据生成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*生成迭代的T表格*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_T_Table</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">64</span>;i++)&#123;</span><br><span class="line">        T[i] = (<span class="keyword">long</span>) (Math.floor(Math.abs(Math.sin(i+<span class="number">1</span>)) * (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>,<span class="number">32</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理消息分组X[]的生成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将 512bit的消息处理为 16个字的X数组*/</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>,k=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++,k+=<span class="number">4</span>)&#123;</span><br><span class="line">   X[j] = ((<span class="keyword">int</span>)M[i * <span class="number">64</span> + k] &amp; <span class="number">0xFF</span>) | ((<span class="keyword">int</span>)M[i*<span class="number">64</span>+k+<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span> |</span><br><span class="line">         ((<span class="keyword">int</span>)M[i*<span class="number">64</span>+k+<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span> | ((<span class="keyword">int</span>)M[i*<span class="number">64</span>+k+<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要模块步骤"><a href="#重要模块步骤" class="headerlink" title="重要模块步骤"></a>重要模块步骤</h3><p>循环左移s位模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*  @ param  x  被移数</span></span><br><span class="line"><span class="comment">*  @ param  s  左移的位数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">rotateLeft</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> s)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (x &lt;&lt; s)| (x &gt;&gt; (<span class="number">32</span> - s)) &amp; <span class="number">0xFFFFFFFL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure><p>四个生成函数和四个迭代函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*四重循环使用的函数*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param a b c d 为四个缓冲区的内容</span></span><br><span class="line"><span class="comment">*        k 为X[k]</span></span><br><span class="line"><span class="comment">*        s 为移位数目</span></span><br><span class="line"><span class="comment">*        i为 T[j]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">F_Func</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> c,<span class="keyword">long</span> d,<span class="keyword">long</span> k,<span class="keyword">long</span> s, <span class="keyword">long</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b + rotate_left(((a + ((b &amp; c) | ((~b) &amp; d)) + k + i) &amp; <span class="number">0xFFFFFFFFL</span>),s)) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">G_Func</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> c,<span class="keyword">long</span> d,<span class="keyword">long</span> k,<span class="keyword">long</span> s, <span class="keyword">long</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b + rotate_left(((a + ((b &amp; d) | (c &amp; (~d))) + k + i) &amp; <span class="number">0xFFFFFFFFL</span>),s)) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">H_Func</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> c,<span class="keyword">long</span> d,<span class="keyword">long</span> k,<span class="keyword">long</span> s, <span class="keyword">long</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b + rotate_left(((a + (b ^ c ^ d) + k + i) &amp; <span class="number">0xFFFFFFFFL</span>) , s)) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">I_Func</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> c,<span class="keyword">long</span> d,<span class="keyword">long</span> k,<span class="keyword">long</span> s, <span class="keyword">long</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b + rotate_left(((a + (c ^ (b | (~d))) + k + i) &amp; <span class="number">0xFFFFFFFFL</span>), s)) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将小端形式转为大端形式*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">encode</span><span class="params">(<span class="keyword">long</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((t &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>) | ((t &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span> | ((t &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span> | (t &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将数据从小端转为大端的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将小端形式转为大端形式*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">encode</span><span class="params">(<span class="keyword">long</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((t &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>) | ((t &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span> | ((t &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span> | (t &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取填充的位数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String inputString = <span class="string">"test1.txt"</span>;       <span class="comment">// 输入的文件名</span></span><br><span class="line">   File file = <span class="keyword">new</span> File(inputString);  <span class="comment">// 文件操作对象</span></span><br><span class="line">   length = file.length();             <span class="comment">// 获取文件的字节长度1</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取填充的位数</span></span><br><span class="line">   <span class="keyword">if</span>(length % <span class="number">64</span> &lt; <span class="number">56</span>)&#123;</span><br><span class="line">       paddingLength = (<span class="keyword">int</span>)(<span class="number">56</span> - length % <span class="number">64</span>); <span class="comment">// 字节</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(length % <span class="number">64</span> == <span class="number">56</span>)&#123;</span><br><span class="line">       paddingLength = <span class="number">64</span>;   <span class="comment">// 64 字节</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(length % <span class="number">64</span> &gt; <span class="number">56</span>)&#123;</span><br><span class="line">       paddingLength = (<span class="keyword">int</span>) (<span class="number">64</span> - (length % <span class="number">64</span> - <span class="number">56</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将消息分块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该循环的作用是：对全部原始消息进行分块，每块大小为64个字节，共512位</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (length + paddingLength + <span class="number">8</span>)/<span class="number">64</span>; i++)&#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>进入4次循环，共64次迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入 4 轮循环，每次循环16次迭代，一共64次迭代</span></span><br><span class="line"> <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j ++)&#123;</span><br><span class="line">     <span class="keyword">int</span> div16 = j / <span class="number">16</span>;  <span class="comment">// div16 代表每次循环的迭代次数</span></span><br></pre></td></tr></table></figure><p>每次循环的迭代过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (div16)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">           <span class="comment">// 第一轮循环，16次迭代</span></span><br><span class="line">           j_factor = j ;</span><br><span class="line">           k_index = j_factor;</span><br><span class="line">           <span class="comment">// 分四个A、B、C、D 缓冲区处理</span></span><br><span class="line">           <span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">              A = F_Func(A,B,C,D,X[k_index],<span class="number">7</span>,T[j]);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                D = F_Func(D,A,B,C,X[k_index],<span class="number">12</span>,T[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                C = F_Func(C,D,A,B,X[k_index],<span class="number">17</span>,T[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                B = F_Func(B,C,D,A,X[k_index],<span class="number">22</span>,T[j]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>原寄存器内容与4重循环后的寄存器内容相加，得到下一轮压缩的寄存器值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = (A + tmpA) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">B = (B + tmpB) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">C = (C + tmpC) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">D = (D + tmpD) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br></pre></td></tr></table></figure><p>全部消息压缩后，输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">"小端形式MD5：%x %x %x %x\n"</span>, A,B,C,D);</span><br><span class="line">A = encode(A);   <span class="comment">// 转为大端形式</span></span><br><span class="line">B = encode(B);</span><br><span class="line">C = encode(C);</span><br><span class="line">D = encode(D);</span><br><span class="line">System.out.format(<span class="string">"大端形式MD5：%x %x %x %x\n"</span>,A,B,C,D);</span><br></pre></td></tr></table></figure><p>使用java自带的MD5函数进行比对验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*调用java自带md5函数 输出md5值*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMd5ForFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] cache = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(cache)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            md5.update(cache, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        BigInteger bigInt = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, md5.digest());</span><br><span class="line">        <span class="keyword">return</span> bigInt.toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、实验环境说明&quot;&gt;&lt;a href=&quot;#一、实验环境说明&quot; class=&quot;headerlink&quot; title=&quot;一、实验环境说明&quot;&gt;&lt;/a&gt;一、实验环境说明&lt;/h2&gt;&lt;p&gt;操作系统：window10&lt;/p&gt;
&lt;p&gt;编程语言：Java （JDK版本 11.0.1）&lt;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="信息安全" scheme="https://joshuaqyh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://joshuaqyh.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C++实现二叉树各种遍历</title>
    <link href="https://joshuaqyh.github.io/2018/12/07/C-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
    <id>https://joshuaqyh.github.io/2018/12/07/C-实现二叉树各种遍历/</id>
    <published>2018-12-06T16:08:04.000Z</published>
    <updated>2019-02-18T14:13:12.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要使用C++ 实现二叉树的遍历：</p><ol><li>前序，中序，后序遍历的递归和非递归实现</li><li>层序遍历</li><li>深度优先遍历</li></ol><hr><h3 id="结点数据结构"><a href="#结点数据结构" class="headerlink" title="结点数据结构"></a>结点数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for binary tree</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>思路：</p><ol><li>初始化一个栈用于存储结点指针</li><li>若结点非空，访问其值，然后将该结点push入栈。并将左孩子置为当前结点。</li><li>若结点为空，那么将当前结点置为栈顶结点的右孩子，并弹出栈顶结点。</li><li>重复2，3，直到栈为空或者无结点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="literal">NULL</span> || !S.empty())&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#125;&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">  S.push(node);</span><br><span class="line">          node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        node = S.top()-&gt;right;</span><br><span class="line">             S.pop();</span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>思想同前序遍历一致，利用栈来实现，唯一不同之处就是访问结点的顺序是在结点出栈的时候才进行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="literal">NULL</span> || !S.empty())&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#125;&#123;</span><br><span class="line">  S.push(node);</span><br><span class="line">          node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">        node = S.top()-&gt;right;</span><br><span class="line">             S.pop();</span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><h3 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>难！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;BTNode*&gt; s;</span><br><span class="line"><span class="comment">//pCur:当前访问节点，pLastVisit:上次访问节点</span></span><br><span class="line">BTNode* pCur, *pLastVisit;</span><br><span class="line"><span class="comment">//pCur = root;</span></span><br><span class="line">pCur = root;</span><br><span class="line">pLastVisit = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//先把pCur移动到左子树最下边</span></span><br><span class="line"><span class="keyword">while</span> (pCur)</span><br><span class="line">&#123;</span><br><span class="line">s.push(pCur);</span><br><span class="line">pCur = pCur-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//走到这里，pCur都是空，并已经遍历到左子树底端(看成扩充二叉树，则空，亦是某棵树的左孩子)</span></span><br><span class="line">pCur = s.top();</span><br><span class="line">s.pop();</span><br><span class="line"><span class="comment">//一个根节点被访问的前提是：无右子树或右子树已被访问过</span></span><br><span class="line"><span class="keyword">if</span> (pCur-&gt;rchild == <span class="literal">NULL</span> || pCur-&gt;rchild == pLastVisit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; pCur-&gt;data;</span><br><span class="line"><span class="comment">//修改最近被访问的节点</span></span><br><span class="line">pLastVisit = pCur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的else语句可换成带条件的else if:</span></span><br><span class="line"><span class="comment">else if (pCur-&gt;lchild == pLastVisit)//若左子树刚被访问过，则需先进入右子树(根节点需再次入栈)</span></span><br><span class="line"><span class="comment">因为：上面的条件没通过就一定是下面的条件满足。仔细想想！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根节点再次入栈</span></span><br><span class="line">s.push(pCur);</span><br><span class="line"><span class="comment">//进入右子树，且可肯定右子树一定不为空</span></span><br><span class="line">pCur = pCur-&gt;rchild;</span><br><span class="line"><span class="keyword">while</span> (pCur)</span><br><span class="line">&#123;</span><br><span class="line">s.push(pCur);</span><br><span class="line">pCur = pCur-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">--------------------- </span><br><span class="line">作者：苏叔叔 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https:<span class="comment">//blog.csdn.net/zhangxiangDavaid/article/details/37115355 </span></span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure><h2 id="层次优先遍历"><a href="#层次优先遍历" class="headerlink" title="层次优先遍历"></a>层次优先遍历</h2><p>使用队列来实现，每访问一个结点就将该结点左右孩子（如果有）加入队列末尾，然后将结点从队头弹出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        TreeNpde* node = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            Q.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            Q.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>使用栈来实现，原理同前序，中序遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">depthOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    S.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">       TreeNode* node = S.pop();</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            S.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            S.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要使用C++ 实现二叉树的遍历：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前序，中序，后序遍历的递归和非递归实现&lt;/li&gt;
&lt;li&gt;层序遍历&lt;/li
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="数据结构" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode | 关于树</title>
    <link href="https://joshuaqyh.github.io/2018/12/06/Leetcode-Practice-1/"/>
    <id>https://joshuaqyh.github.io/2018/12/06/Leetcode-Practice-1/</id>
    <published>2018-12-06T08:26:17.000Z</published>
    <updated>2019-03-14T07:59:49.972Z</updated>
    
    <content type="html"><![CDATA[<p>以下问题，主要是练习递归的使用，体会递归的思想。</p><h2 id="Problem-654-最大数二叉树"><a href="#Problem-654-最大数二叉树" class="headerlink" title="Problem 654 最大数二叉树"></a>Problem 654 最大数二叉树</h2><p><code>Medium</code> <code>C++</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************</span></span><br><span class="line"><span class="comment">Given an integer array with no duplicates. </span></span><br><span class="line"><span class="comment">A maximum tree building on this array is defined as follow:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The root is the maximum number in the array.</span></span><br><span class="line"><span class="comment">The left subtree is the maximum tree constructed </span></span><br><span class="line"><span class="comment">from left part subarray divided by the maximum number.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The right subtree is the maximum tree constructed </span></span><br><span class="line"><span class="comment">from right part subarray divided by the maximum number.</span></span><br><span class="line"><span class="comment">Construct the maximum tree by the given array and output the root node of this tree.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment">Input: [3,2,1,6,0,5]</span></span><br><span class="line"><span class="comment">Output: return the tree root node representing the following tree:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  6</span></span><br><span class="line"><span class="comment">/   \</span></span><br><span class="line"><span class="comment">   3     5</span></span><br><span class="line"><span class="comment">\    /</span></span><br><span class="line"><span class="comment"> 2  0</span></span><br><span class="line"><span class="comment">   \</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">Note:</span></span><br><span class="line"><span class="comment">The size of the given array will be in the range [1,1000].</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// method 1 使用迭代器 快了一点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> it = max_element(nums.begin(), nums.end());</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(*it);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(nums.begin(), it);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(next(it), nums.end());</span><br><span class="line">root-&gt;left = constructMaximumBinaryTree(left);</span><br><span class="line">root-&gt;right = constructMaximumBinaryTree(right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2  性能差</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start == end) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxIndex = findMax(num, start, end);</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode(num[maxIndex]);</span><br><span class="line">root-&gt;left = build(num, start, maxIndex);</span><br><span class="line">root-&gt;right = build(num, maxIndex + <span class="number">1</span>, end);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = start;</span><br><span class="line"><span class="keyword">int</span> max = num[start];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num[i] &gt; max) &#123;</span><br><span class="line">index = i;</span><br><span class="line">max = num[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"><span class="number">1.</span> 使用迭代器速度快了一些</span><br><span class="line"><span class="number">2.</span> 递归循环查找速度显然慢了</span><br><span class="line"><span class="number">3.</span> 非递归版本速度更快，可利用栈实现</span><br><span class="line"></span><br><span class="line">以下是 O(n)实现方式（摘自大佬）</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur = <span class="keyword">new</span> TreeNode(nums[i]);</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.back()-&gt;val &lt; nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;left = stk.back();</span><br><span class="line">                stk.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stk.empty())</span><br><span class="line">                stk.back()-&gt;right = cur;</span><br><span class="line">            stk.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="递归统计二叉树结点在某区间内的和"><a href="#递归统计二叉树结点在某区间内的和" class="headerlink" title="递归统计二叉树结点在某区间内的和"></a>递归统计二叉树结点在某区间内的和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************</span></span><br><span class="line"><span class="comment">Given the root node of a binary search tree, </span></span><br><span class="line"><span class="comment">return the sum of values of all nodes with value </span></span><br><span class="line"><span class="comment">between L and R (inclusive).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The binary search tree is guaranteed to have unique values.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment">Input: root = [10,5,15,3,7,null,18], L = 7, R = 15</span></span><br><span class="line"><span class="comment">Output: 32</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment">Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10</span></span><br><span class="line"><span class="comment">Output: 23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note:</span></span><br><span class="line"><span class="comment">The number of nodes in the tree is at most 10000.</span></span><br><span class="line"><span class="comment">The final answer is guaranteed to be less than 2^31.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">tranverse(root, L, R); <span class="comment">// 递归统计</span></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt;= R &amp;&amp; root-&gt;val &gt;= L) &#123;</span><br><span class="line">sum += root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">tranverse(root-&gt;left, L, R);</span><br><span class="line">tranverse(root-&gt;right, L, R);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简单二叉树剪枝"><a href="#简单二叉树剪枝" class="headerlink" title="简单二叉树剪枝"></a>简单二叉树剪枝</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Question:</span></span><br><span class="line"><span class="comment">We are given the head node root of a binary tree,</span></span><br><span class="line"><span class="comment">where additionally every node's value is either a 0 or a 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return the same tree where every subtree (of the </span></span><br><span class="line"><span class="comment">given tree) not containing a 1 has been removed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(Recall that the subtree of a node X is X, plus </span></span><br><span class="line"><span class="comment">every node that is a descendant of X.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Author: qiuyh</span></span><br><span class="line"><span class="comment">Date: 18/09/16</span></span><br><span class="line"><span class="comment">描述：一个二叉树，节点值为0或1，我们要对一棵</span></span><br><span class="line"><span class="comment">给定的二叉树剪枝，将其子树的节点值全为0的去除掉</span></span><br><span class="line"><span class="comment">思路：利用递归实现，将每一个节点视为根节点，</span></span><br><span class="line"><span class="comment">递归判断是否全为0，为0则该点置为null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">TreeNode* resultNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">TreeNode * <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 找到空节点，就返回</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">// 继续下溯，若返回值可能为空或者不为空</span></span><br><span class="line">root-&gt;left = pruneTree(root-&gt;left);</span><br><span class="line">root-&gt;right = pruneTree(root-&gt;right);</span><br><span class="line"><span class="comment">// 左右节点都为空而且值为0，则返回一个空指针</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; root-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后返回剪枝后的节点</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩阵递归搜索"><a href="#矩阵递归搜索" class="headerlink" title="矩阵递归搜索"></a>矩阵递归搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Question:An image is represented by a 2-D array of integers, </span></span><br><span class="line"><span class="comment">each integer representing the pixel value of the image </span></span><br><span class="line"><span class="comment">(from 0 to 65535).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Given a coordinate (sr, sc) representing the </span></span><br><span class="line"><span class="comment">starting pixel (row and column) of the flood fill,</span></span><br><span class="line"><span class="comment">and a pixel value newColor, "flood fill" the image.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To perform a "flood fill", consider the starting </span></span><br><span class="line"><span class="comment">pixel, plus any pixels connected 4-directionally to </span></span><br><span class="line"><span class="comment">the starting pixel of the same color as the starting pixel, </span></span><br><span class="line"><span class="comment">plus any pixels connected 4-directionally to those </span></span><br><span class="line"><span class="comment">pixels (also with the same color as the starting pixel), </span></span><br><span class="line"><span class="comment">and so on. Replace the color of all </span></span><br><span class="line"><span class="comment">of the aforementioned pixels with the newColor.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">At the end, return the modified image.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Author:qiuyh</span></span><br><span class="line"><span class="comment">Date: 18/09/16</span></span><br><span class="line"><span class="comment">描述：给定一个二维矩阵，和一个起点和一个颜色，</span></span><br><span class="line"><span class="comment">该起点会向相邻水平竖直四个方向的点进行染色，</span></span><br><span class="line"><span class="comment">  然后被染色的点成为新的点</span></span><br><span class="line"><span class="comment">思路：1.从起点开始，进行行列扫描，遇到相邻且颜色相同的点，</span></span><br><span class="line"><span class="comment">继续加入起点，然后继续行列扫描， 时间复杂度大，不建议</span></span><br><span class="line"><span class="comment"> 2. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line"><span class="keyword">int</span> oldColor = image[sr][sc];</span><br><span class="line">image[sr][sc] = newColor;</span><br><span class="line"><span class="keyword">if</span> (sc + <span class="number">1</span> &lt; image[sr].size() &amp;&amp; oldColor == image[sr][sc + <span class="number">1</span>]) &#123;</span><br><span class="line">floodFill(image, sr, sc + <span class="number">1</span>, newColor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sc - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; oldColor == image[sr][sc - <span class="number">1</span>]) &#123;</span><br><span class="line">floodFill(image, sr, sc - <span class="number">1</span>, newColor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sr + <span class="number">1</span> &lt; image.size() &amp;&amp; oldColor == image[sr + <span class="number">1</span>][sc]) &#123;</span><br><span class="line">floodFill(image, sr + <span class="number">1</span>, sc, newColor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sr - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; oldColor == image[sr - <span class="number">1</span>][sc]) &#123;</span><br><span class="line">floodFill(image, sr - <span class="number">1</span>, sc, newColor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归的思想和步骤：</p><ol><li>递归就是找到重复相似的步骤，重复调用同一函数实现。</li><li>需要找到递归的终结条件。</li><li>明确多重递归之间的参数变量关系。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下问题，主要是练习递归的使用，体会递归的思想。&lt;/p&gt;
&lt;h2 id=&quot;Problem-654-最大数二叉树&quot;&gt;&lt;a href=&quot;#Problem-654-最大数二叉树&quot; class=&quot;headerlink&quot; title=&quot;Problem 654 最大数二叉树&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://joshuaqyh.github.io/tags/C/"/>
    
      <category term="algorithm" scheme="https://joshuaqyh.github.io/tags/algorithm/"/>
    
      <category term="Leetcode" scheme="https://joshuaqyh.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 |人脸属性数据集 CelebA</title>
    <link href="https://joshuaqyh.github.io/2018/12/06/%E4%BA%BA%E8%84%B8%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE%E9%9B%86CelebA/"/>
    <id>https://joshuaqyh.github.io/2018/12/06/人脸属性数据集CelebA/</id>
    <published>2018-12-06T08:26:17.000Z</published>
    <updated>2019-03-27T13:54:45.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人脸属性数据集CelebA"><a href="#人脸属性数据集CelebA" class="headerlink" title="人脸属性数据集CelebA"></a>人脸属性数据集CelebA</h1><h2 id="CelebA-解释"><a href="#CelebA-解释" class="headerlink" title="CelebA 解释"></a>CelebA 解释</h2><h3 id="数据集基本描述"><a href="#数据集基本描述" class="headerlink" title="数据集基本描述"></a>数据集基本描述</h3><ul><li>10177 个名人</li><li>202599张人脸图片</li><li>40个属性标记</li><li>人脸bbox标注框</li><li>5个人脸特征点坐标 </li></ul><p>由香港中文大学开放提供，网址在<a href="http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html" target="_blank" rel="noopener">这里</a></p><p>网盘文件夹描述如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic1.zhimg.com/80/v2-e5546e983a24e0e846f11de439068c64_hd.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><ul><li>Anno是bbox、landmark及attribute注释文件；<strong>（标注文件夹）</strong></li><li>Eval是training、validation及testing数据集的划分注释；<strong>（划分描述文件夹）</strong></li><li>Img则是存放相应的人脸图像，<strong>（人脸图片文件夹）</strong></li><li>README.txt是CelebA介绍文件；</li></ul><p>虽然img文件夹提供了多种格式的图片，我们一般只需要用到 .jpg（img_align_celeba.zip)，文件内部的图片都是有排序的。</p><h3 id="标签解释"><a href="#标签解释" class="headerlink" title="标签解释"></a>标签解释</h3><ul><li><strong>人脸标注框</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190309145245.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>人脸5个特征点</strong>， align代表着图片经过处理对齐。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190309145516.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>40个特征属性标记</p><p><img src="https://raw.githubusercontent.com/JoshuaQYH/blogImage/master/img/20190309150157.png" alt=""></p><p>每个属性代表的含义是：</p></li></ul><ol><li>5_o_Clock_Shadow：刚长出的双颊胡须</li><li>Arched_Eyebrows：柳叶眉</li><li>Attractive：吸引人的</li><li>Bags_Under_Eyes：眼袋</li><li>Bald：秃头</li><li>Bangs：刘海</li><li>Big_Lips：大嘴唇</li><li>Big_Nose：大鼻子</li><li>Black_Hair：黑发</li><li>Blond_Hair：金发</li><li>Blurry：模糊的</li><li>Brown_Hair：棕发</li><li>Bushy_Eyebrows：浓眉</li><li>Chubby：圆胖的</li><li>Double_Chin：双下巴</li><li>Eyeglasses：眼镜</li><li>Goatee：山羊胡子</li><li>Gray_Hair：灰发或白发</li><li>Heavy_Makeup：浓妆</li><li>High_Cheekbones：高颧骨</li><li>Male：男性</li><li>Mouth_Slightly_Open：微微张开嘴巴</li><li>Mustache：胡子，髭</li><li>Narrow_Eyes：细长的眼睛</li><li>No_Beard：无胡子</li><li>Oval_Face：椭圆形的脸</li><li>Pale_Skin：苍白的皮肤</li><li>Pointy_Nose：尖鼻子</li><li>Receding_Hairline：发际线后移</li><li>Rosy_Cheeks：红润的双颊</li><li>Sideburns：连鬓胡子</li><li>Smiling：微笑</li><li>Straight_Hair：直发</li><li>Wavy_Hair：卷发</li><li>Wearing_Earrings：戴着耳环</li><li>Wearing_Hat：戴着帽子</li><li>Wearing_Lipstick：涂了唇膏</li><li>Wearing_Necklace：戴着项链</li><li>Wearing_Necktie：戴着领带</li><li>Young：年轻人</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人脸属性数据集CelebA&quot;&gt;&lt;a href=&quot;#人脸属性数据集CelebA&quot; class=&quot;headerlink&quot; title=&quot;人脸属性数据集CelebA&quot;&gt;&lt;/a&gt;人脸属性数据集CelebA&lt;/h1&gt;&lt;h2 id=&quot;CelebA-解释&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://joshuaqyh.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机视觉" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>消息认证和哈希算法</title>
    <link href="https://joshuaqyh.github.io/2018/12/03/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E5%92%8C%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://joshuaqyh.github.io/2018/12/03/消息认证和哈希函数/</id>
    <published>2018-12-03T09:59:20.640Z</published>
    <updated>2018-12-03T09:59:20.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息认证概述"><a href="#消息认证概述" class="headerlink" title="消息认证概述"></a>消息认证概述</h2><p>网络通信针对消息内容的攻击方法：</p><ol><li>伪造消息</li><li>篡改消息内容</li><li>改变消息顺序</li><li>消息重放或者延迟</li></ol><p>消息认证过程：</p><ol><li>接收者确信消息未被改变</li><li>接收者确信消息来自所生成的发送者</li><li>消息中含有序列号，保证正确的消息顺序</li></ol><p>消息认证的三种方式：</p><ol><li><p>消息认证加密。对消息加密，以密文作为消息的认证标识。</p></li><li><p>消息认证码MAC。使用一个公开函数，加上密钥，为消息产生一个数据块，作为消息的认证标识并附加到消息中一起传输。</p></li><li><p>哈希方法。使用一个公开函数，将消息映射到一个固定长度的散列值，并作为消息认证标识附加到消息中一起传输。</p></li><li><p>数字签名。基于非对称密码技术的数字签名将签名与被签文件绑定，提供了不可依赖不可伪造，容易验证的功能。</p><p>​</p></li></ol><h2 id="MAC-消息认证码"><a href="#MAC-消息认证码" class="headerlink" title="MAC 消息认证码"></a>MAC 消息认证码</h2><p>消息验证码有三部分算法（G：密钥生成算法；S：签名算法；V：消息验证算法）</p><ul><li>基本结构：</li></ul><p>MAC方法双方使用一个共享的密钥，为目标消息生成一个固定的数据块，并加入到消息中，该数据块被称为消息认证码，或者是密码校验和。</p><p>MAC函数类似于加密函数，但<strong>不需要</strong> 可逆性，因此收到攻击的弱点在数学上比加密算法要少。</p><ul><li>使用MAC的理由：<ul><li>主要提供真实性。</li><li>与加密算法比较，代价算法较小。</li><li>认证和保密函数分离较为灵活</li><li>很多信息需要真实性而不是保密性。</li></ul></li><li>模型<ul><li>只用于消息认证的MAC模型</li><li>用于与明文相关的消息认证和保密性的MAC模型</li><li>用于与密文相关的消息认证和保密性的MAC模型</li></ul></li><li>与数字签名都用于消息认证。MAC是通讯双方共享一个私有密钥。而数字签名则是利用公钥密码技术实现。</li></ul><p>##HASH</p><p>输入变长的消息，经过hash输出定常的散列值。</p><h3 id="哈希函数的一些基本要求"><a href="#哈希函数的一些基本要求" class="headerlink" title="哈希函数的一些基本要求"></a>哈希函数的一些基本要求</h3><ol><li>能够映射任意长的分组数据</li><li>产生定长的哈希结果</li><li>可计算，易于计算</li><li>单向性</li><li>抗碰撞（强弱）</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>按规避碰撞能力分：</p><ul><li>强无碰撞</li><li>弱无碰撞</li></ul></li><li><p>按是否需要密钥分：</p><ul><li><p>不带密钥的hash</p></li><li><p>带密钥的hash</p><p>​</p></li></ul></li></ul><p>生日攻击理论：计算哈希碰撞的概率和计算量之间的关系</p><h3 id="hash函数通用模型"><a href="#hash函数通用模型" class="headerlink" title="hash函数通用模型"></a>hash函数通用模型</h3><p>由merkle提出的模型结构:</p><ol><li>将消息M划分为一些固定长度的块Yi</li><li>最后一块padding并使其包含消息M的长度</li><li>设定初始值CV0</li><li>采用压缩函数f，CVi = f（CVi-1， Yi-1）</li><li>最后一个CVi为hash值。</li></ol><h2 id="MD5-算法"><a href="#MD5-算法" class="headerlink" title="MD5 算法"></a>MD5 算法</h2><p>信息摘要5算法。确保信息传输的完整性和一致性。</p><p>使用小端模式，输入不定长度信息，以512bit进行分组，生成4个32bit的数据，最后联合输出固定128bit的信息摘要。</p><p>小端模式，低字节放在低地址处。</p><h4 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h4><ol><li>填充<ol><li>在长度为 $K$ bits的原始消息数据尾部填充长度为 $P$ bits的标识$100…0  。$ $ 1 \le P \le 512$ ,使得填充后的消息位数为$K + P \equiv 448(mod \, 512)$。<ol><li>注意：当$K \equiv 448 (mod\,512)$时，$P = 512$。</li></ol></li><li>向上述填充好的消息尾部附加$K$值得低64位，即$(K \, mod \, 2^{64})$。最后得到一个长度位数为$K + P + 64 \equiv 0 (mod \, 512)$。</li></ol></li><li>分块<ol><li>将填充后得消息结果分割为$L$  个$512-bit$分组,记为:$Y_0, Y_1, …, Y_{L-1}$</li><li>分组结果表示为$N$个$32-bit$字记为$M_0, M_1, …, M_{N-1}, N = L×16 $ </li></ol></li><li>初始化<ol><li>初始化一个$128-bit$ 的MD缓冲区，记为$CV_q$,表示成4个$32-bit$寄存器$(A,B,C,D)$； $CV_0 = IV$。迭代在MD缓冲区进行，最后一步的$128-bit$输出即为算法的结果。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息认证概述&quot;&gt;&lt;a href=&quot;#消息认证概述&quot; class=&quot;headerlink&quot; title=&quot;消息认证概述&quot;&gt;&lt;/a&gt;消息认证概述&lt;/h2&gt;&lt;p&gt;网络通信针对消息内容的攻击方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;伪造消息&lt;/li&gt;
&lt;li&gt;篡改消息内容&lt;/li
      
    
    </summary>
    
    
      <category term="信息安全" scheme="https://joshuaqyh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="加密技术" scheme="https://joshuaqyh.github.io/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>机器学习| K-means and mean-shift</title>
    <link href="https://joshuaqyh.github.io/2018/12/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95-K-means-and-mean-shift/"/>
    <id>https://joshuaqyh.github.io/2018/12/03/机器学习-聚类算法-K-means-and-mean-shift/</id>
    <published>2018-12-03T04:51:17.000Z</published>
    <updated>2019-03-08T06:32:32.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h1><h2 id="K-means-算法"><a href="#K-means-算法" class="headerlink" title="K-means 算法"></a>K-means 算法</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>随机确定好 k个聚类中心</li><li>根据离聚类中心最近的原则给样本点分类</li><li>根据分类后的样本点集合进行平均重新 计算聚类中心。返回2；</li><li>存在聚类中心差异小的时候，结束计算。</li></ol><h3 id="K值的挑选"><a href="#K值的挑选" class="headerlink" title="K值的挑选"></a>K值的挑选</h3><ul><li>cost function ： 分类后的样本点和聚类中心的方差作为代价函数。</li><li>K值变大，cost function 变小</li></ul><p>Elbow method 可以确定变化的骤变点。该点是 K-cost function图像上曲率最大的点。</p><h3 id="使用K-means进行图像分割"><a href="#使用K-means进行图像分割" class="headerlink" title="使用K-means进行图像分割"></a>使用K-means进行图像分割</h3><ol><li>特征聚类</li><li>亮度聚类</li><li>颜色空间聚类</li></ol><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>类密集且区别明显的时候，分类效果好</li><li>强的一致性</li><li>算法复杂度O(NMt)，处理大数据集是高效的</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>初始化中心的选择影响收敛</li><li>需要预先给出k值</li><li>噪声敏感</li><li>收敛到局部最优解，可能效果感人。。</li></ol><h2 id="Mean-shift"><a href="#Mean-shift" class="headerlink" title="Mean shift"></a>Mean shift</h2><p>在数据空间中，确定一个圆区域，计算圆内数据质心，然后圆心漂移到质心，重新在圆内计算质心，直到圆心等于质心。即收敛，达到局部最小值。</p><p>另外一种表述，在窗口中计算均值漂移向量，变换密度窗口，重复计算变换直到收敛。</p><ul><li>不受噪声敏感(除三维颜色，还引入位置坐标信息)</li><li>参数单一 </li><li>维度越高，聚类越慢</li><li>重复计算(染色标记降低冗余)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;聚类算法&quot;&gt;&lt;a href=&quot;#聚类算法&quot; class=&quot;headerlink&quot; title=&quot;聚类算法&quot;&gt;&lt;/a&gt;聚类算法&lt;/h1&gt;&lt;h2 id=&quot;K-means-算法&quot;&gt;&lt;a href=&quot;#K-means-算法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="图像分割" scheme="https://joshuaqyh.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>信息安全 | 认证技术</title>
    <link href="https://joshuaqyh.github.io/2018/11/28/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
    <id>https://joshuaqyh.github.io/2018/11/28/零知识证明/</id>
    <published>2018-11-28T08:24:19.198Z</published>
    <updated>2019-05-16T14:05:46.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><h3 id="Fiat-Shamir-算法"><a href="#Fiat-Shamir-算法" class="headerlink" title="Fiat-Shamir 算法"></a>Fiat-Shamir 算法</h3><ol><li>$n  = p * q。p, q$是大素数。 $n$为可信第三方机构公开，而$p, q$为私有或者销毁</li><li>$s: Alice$的密钥, $0 &lt; s &lt; n$。 Alice 必须证明其知晓密钥$s$,而不需要向任何人出示$s$。</li><li>$v:Alice$的公钥，满足$v \equiv s^2 \, mod \, n$ 。<ol><li>Alice 计算并得出v展示给Bob</li><li>无法从v推导出s。</li></ol></li><li>$r: Alice$随机挑选的一个数字，满足$0 &lt; r &lt; n-1$。</li><li>$x : x = r^2 \, mod \, n$ 作为一个Alice计算后的证据x(evidence)，并发送给Bob。</li><li>$c: $ Bob随机挑选的一个数c(challenger)，范围是{1， 0}。</li><li>$y : y = rs^c \, mod \, n$ 由$Alice$计算得到结果y（response），并发送给Bob。</li><li>Bob通过计算$y^2\, mod \,n \,\,?=  xv^c\, mode \, n$ ,如果相等，则认证完毕。</li></ol><h2 id="认证技术"><a href="#认证技术" class="headerlink" title="认证技术"></a>认证技术</h2><h4 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h4><p>数据协议，定义一个数据目录服务，维护一个用户信息数据库。</p><h4 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h4><p>认证协议，用于证明接收双方的合法性。基于C/S结构的单向认证，弱双向认证。</p><p>##认证攻击类型</p><ul><li>假冒攻击</li><li>重放攻击</li><li>强迫延时攻击</li><li>交错攻击</li><li>Oracle会话攻击</li><li>并行会话攻击</li></ul><h2 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h2><p>PKI 公钥基础设施，通过公开密钥技术和数字证书，来确保系统信息安全，并负责验证数字证书持有者身份的体系。<strong>绝对安全，由国家信用作为背书</strong>。</p><p>应用：VPN，安全电子邮件，web服务安全。</p><h2 id="Kerberos-1"><a href="#Kerberos-1" class="headerlink" title="Kerberos"></a>Kerberos</h2><p>Kerberos  是一种计算机网络认证协议。基于<strong>票据（tickets）</strong> 的工作原理和$Neeedham-Schroeder \, Symmetric \, key \, Protocol$，允许结点以一种安全的策略，在不安全的网络中，互相证明的身份。</p><ul><li>防窃听，防重放攻击。</li><li>C/S 模型，提供双方认证。</li><li>该协议无竞争对手！</li><li>开源，多平台可用。</li></ul><p>该协议建立在对称加密体系之上，并且需要一个<strong>可信的第三方机构</strong> 。在特定的认证情景中使用不同的对称加密算法。</p><h4 id="Neeedham-Schroeder-Symmetric-key-Protocol"><a href="#Neeedham-Schroeder-Symmetric-key-Protocol" class="headerlink" title="* $Neeedham-Schroeder \, Symmetric \, key \, Protocol$"></a>* $Neeedham-Schroeder \, Symmetric \, key \, Protocol$</h4><p>情景：</p><ol><li>TA是一个第三方的可信机构，可分发密钥中心，能够提供双方会话共享密钥。</li><li>E（K，-）是一个对称加密算法（如DES）</li><li>TA拥有一个密钥$K_{AT}$y与Alice一致，同样也有一个$K_{BT}$ 与Bob一致。</li><li>Alice使用一个随机数$r_A$ 来认证TA，并从TA获得一个会话密钥 $K_{AB}$ 。</li><li>Alice使用$K_{BT}$加密$(K_{AB}, r_B) $ 发给bob，bob使用$K_{BT}$解密。</li><li>Bob使用会话密钥$K_{AB}$ 加密$r_B $发送给Alice。</li><li>Alice使用$K_{AB}$解密得到$r_B$，并使用$K_AB$加密$r_B - 1$ 发送给Bob，Bob解密检查结果是否为$r_B -1$  。</li></ol><h3 id="架构"><a href="#架构" class="headerlink" title="* 架构"></a>* 架构</h3><p>AS = 认证服务器（认证机构）</p><p>SS = 提供服务的服务器（服务机构）</p><p>TGS= 票据许可服务器</p><p>TGT = 许可的票据</p><p>ST = 服务票据</p><h3 id="流程"><a href="#流程" class="headerlink" title="* 流程"></a>* 流程</h3><ul><li>用户客户端注册</li><li>客户端认证</li><li>客户服务认证</li><li>客户服务请求</li></ul><p>客户登录步骤：</p><ol><li>用户输入用户名和密码，构成【长期密钥】，用于加密网络传输的数据。</li><li>使用hash函数运行输入的密码，得到客户的主密钥【客户/客户 密钥】，并由客户端保管。</li><li>TGS，SS会话密钥属于短期密钥，利用主密钥实现交换和发布。</li></ol><p>客户认证步骤：</p><ol><li>客户机向AS发送一个明文消息，代表用户请求服务。</li><li>AS校验Bob是否在其数据库中，如果在，则AS返回一下两条信息给客户<ol><li>消息A，用主密钥加密的【客户/TGS】会话密钥。</li><li>消息B， 用TGS加密的票据授权票据TGT，客户网络地址，票据有效期，【客户/TGS会话密钥】。</li></ol></li><li>客户机收到A，B，使用主密钥解密A 得到【客户/TGS 会话密钥】,消息B无法解密，因为没有TGS密钥来解密。</li></ol><p>客户服务认证步骤：</p><ol><li>申请服务时，客户机向TGS发送两条消息：<ol><li>消息C，由消息B和申请服务的ID组成。</li><li>消息D，用【客户/TGS会话密钥】加密的认证。（客户ID+时间戳组成）</li></ol></li><li>基于收到的消息C，D，TGS将从消息C中重新获取消息B，用TGS密钥解密消息B，从而得到【客户/TGS会话密钥】，TGS使用这个密钥解密消息D，成功认证，然后返回两条消息给客户机 ：<ol><li>消息E，用SS服务器加密的客户-SS服务票据ST（客户ID，客户网络地址，【客户/SS会话密钥】，票据有效期）</li><li>消息F：用【客户/TGS会话密钥】加密的【客户/SS会话密钥】。</li></ol></li></ol><p>客户服务申请步骤:</p><ol><li>基于从TGS收到的消息E，F，客户机有足够的消息向SS认证自己。客户机发送消息给SS：<ol><li>消息E，由先前步骤得到的E。</li><li>消息G：用【客户/SS会话密钥】加密的一个新的认证，包括客户ID和时间戳</li></ol></li><li>SS用自己的密钥解密消息E（票据），重新得到 【客户/SS会话密钥】，用这个会话密钥，SS解密消息G得到认证，返回确认函H给客户机，确认该身份真实，并同一向该客户提供服务。<ol><li>消息H：在客户认证中找到时间戳， +1，用【客户/SS会话密钥加密】</li></ol></li><li>客户机使用【客户/SS会话密钥】解密确认函H，并检查时间戳是否被正确地更新，如果是，客户机可以信赖该服务器，并向该服务器发送服务请求。</li><li>服务器向客户机提供所请求地服务。</li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="*  局限性"></a>*  局限性</h3><ul><li>单点故障：中心化</li><li>时钟同步：未同步时间戳认证将会失效。</li><li>管理协议未标准化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;零知识证明&quot;&gt;&lt;a href=&quot;#零知识证明&quot; class=&quot;headerlink&quot; title=&quot;零知识证明&quot;&gt;&lt;/a&gt;零知识证明&lt;/h2&gt;&lt;h3 id=&quot;Fiat-Shamir-算法&quot;&gt;&lt;a href=&quot;#Fiat-Shamir-算法&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="信息安全" scheme="https://joshuaqyh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>python实现DES加密算法</title>
    <link href="https://joshuaqyh.github.io/2018/11/28/DES%20%E7%AE%97%E6%B3%95/"/>
    <id>https://joshuaqyh.github.io/2018/11/28/DES 算法/</id>
    <published>2018-11-28T07:08:57.541Z</published>
    <updated>2019-05-16T14:04:13.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-DES算法原理概述"><a href="#一、-DES算法原理概述" class="headerlink" title="一、 DES算法原理概述"></a>一、 DES算法原理概述</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul><li><p>64位为一个分组，当成明文输入DES算法模型，输出同样长度64位的密文。</p></li><li><p>对称加密，加密密钥也是解密密钥，密钥定义了加密过程。</p></li><li><p>密钥构成：64位，每8位的最后一位用于奇偶校验，所以实际密钥长度为56位。</p></li><li><p>基本过程是换位和置换（根据置换矩阵）</p><p>​</p></li></ul><h3 id="算法核心概要"><a href="#算法核心概要" class="headerlink" title="算法核心概要"></a>算法核心概要</h3><ul><li><p>总体结构</p></li><li><p>Feistel轮函数</p></li><li><p>子密钥生成</p></li><li><p>解密过程</p><p>​</p></li></ul><h3 id="信息空间处理："><a href="#信息空间处理：" class="headerlink" title="信息空间处理："></a>信息空间处理：</h3><ol><li><p>原始明文消息的处理：最后的分组不足64位时，填充的字节为缺失的字节数目。</p></li><li><p>明文分组结构：$M = m_1m_2…m_{64}  \,, m_i  ∈ {0， 1}，i= 1…64 $</p></li><li><p>密文分组结构： $C = c_1c_2…c_{64}  \,, c_i  ∈ {0， 1}，i= 1…64 $</p></li><li><p>密钥结构:$K = k_1k_2…k_{64}  \,, k_i  ∈ {0， 1}，i= 1…64 $</p><p>​</p></li></ol><h3 id="加密过程："><a href="#加密过程：" class="headerlink" title="加密过程："></a>加密过程：</h3><p>64位原始密文M经IP初始置换得到$IP(M)$</p><p>$IP(M)$经过16次迭代$T_1, T_2… T_{16}$ 得到$T_16T_15…T_1IP(M)$</p><p>然后在经过$IP^{-1}$ 逆变换得到密文。</p><h3 id="解密过程："><a href="#解密过程：" class="headerlink" title="解密过程："></a>解密过程：</h3><p>加密逆向进行分析。和加密不同的是，子密钥调度过程为逆序，其他一致。</p><h3 id="初始置换："><a href="#初始置换：" class="headerlink" title="初始置换："></a>初始置换：</h3><p>给定一个固定的初始置换IP矩阵来重排明文块M中的二进制位。得到二进制串$M_0 = IP (M) = L_0R_0$</p><p>表： IP置换表（8 <em> 8）（row </em> col 下同）</p><h3 id="迭代T"><a href="#迭代T" class="headerlink" title="迭代T"></a>迭代T</h3><ol><li><p>迭代规则：交叉迭代。$L_i = R_{i-1} \,\,  R_i = L_{i-1} \bigoplus f(R_{i - 1}, K_i)$. $K_i$为子密钥，长度为$$K_i\,, f$$为$$fiestel$$ 轮函数。</p></li><li><p>16次迭代后产生$L_{16}R_{16}$</p></li><li><p>左右交换输出$R_{16}L_{16}$</p><p>​</p></li></ol><h3 id="逆置换"><a href="#逆置换" class="headerlink" title="逆置换"></a>逆置换</h3><p>$P^{-1}$ $C = IP^{-1}(R_{16}L_{16})$ </p><p>表： 逆置换表（8 * 8）</p><h3 id="轮函数-f-R-i-1-K-i"><a href="#轮函数-f-R-i-1-K-i" class="headerlink" title="轮函数$f(R_{i-1}, K_i)$"></a>轮函数$f(R_{i-1}, K_i)$</h3><p>密码函数<code>f(R, K)</code>接受两个输入：32 位的数据和 48 位的子密钥。然后：</p><ol><li><p>通过表 E 进行<strong>扩展置换</strong> （表），将输入的 32 位数据扩展为 48 位；</p></li><li><p>将扩展后的 48 位数据与 48 位的子密钥进行<strong>异或</strong>运算；</p></li><li><p>将异或得到的 48 位数据分成 8 个 6 位的块，每一个块通过对应的一个 S 表产生一个 4 位的输出。其中，每个 S 表都是 4 行 16 列。<strong>具体的置换过程如下：</strong>把 6 位输入中的第 1 位和第 6 位取出来行成一个两位的二进制数 x ，作为 Si 表中的行数（0~3）；把 6 位输入的中间 4 位构成另外一个二进制数 y，作为 Si 表的列数（0~15）；查出 Si 盒表（8 <em> 4 </em> 16 的矩阵）中 x 行 y 列所对应的整数，将该整数转换为一个 4 位的二进制数。</p></li><li><p>把通过 S 表置换得到的 8 个 4 位连在一起，形成一个 32 位的数据。然后将该 32 位数据通过表 P 进行置换（称为P-置换），置换后得到一个仍然是 32 位的结果数据，这就是<code>f(R, K)</code>函数的输出。</p><p>三个表：E扩展置换表（8 <em> 6），S盒置换表（4 </em> 16），P-置换表（8 * 4）</p><p>​</p></li></ol><h3 id="子密钥生成"><a href="#子密钥生成" class="headerlink" title="子密钥生成"></a>子密钥生成</h3><ol><li><p>对密钥K中的56个非校验位实现PC-1置换，得到$C_0D_0$,即置换后的前28位和后28位。</p></li><li><p>对$C_{i-1} D_{i-1}$ 分别进行循环左移操作，得到$C_{i}D_{i}$,当$i = 1，2，9，16$时二进制串左移一个位置，否则左移两个位置。</p></li><li><p>对56位的$C_iD_i$ 实行PC-2压缩置换，得到48位的$K_i$ 。 然后$i++$。</p></li><li><p>如果已经得到$K_{16}$，密码调度结束，否则转步骤2.</p><p>两个表：压缩置换表PC-1 PC-2</p></li></ol><p>​                                                             </p><h2 id="二、-代码模块"><a href="#二、-代码模块" class="headerlink" title="二、 代码模块"></a>二、 代码模块</h2><h3 id="核心函数展示和描述"><a href="#核心函数展示和描述" class="headerlink" title="核心函数展示和描述"></a>核心函数展示和描述</h3><p>由于解密函数需要的模块基本与加密一致，所以不做呈现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####加密总函数############################################################################</span></span><br><span class="line"><span class="comment"># 1. 初始置换 2. 交叉迭代 3. 逆置换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encryption</span><span class="params">(plainText, secretKey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 开始加密64位明文"</span>)</span><br><span class="line">    M = list(plainText)</span><br><span class="line">    L0, R0 = InitialPermutation(M)</span><br><span class="line">    RL = CrossIterationInEncryption(L0, R0, secretKey)</span><br><span class="line">    cipherText = <span class="string">""</span>.join(InversePermutation(RL))</span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######表格置换函数###########################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: transfrom the binaryStr with the giver permutation table</span></span><br><span class="line"><span class="string">    condition: len(binaryStr) == len(PermutationTable)</span></span><br><span class="line"><span class="string">    return: the permutated binary List.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 传入01字符串列表和置换表，返回置换结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(binaryStr, PermutationTable)</span>:</span></span><br><span class="line">    length = len(PermutationTable)</span><br><span class="line">    PermutatedList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">        PermutatedList.extend(binaryStr[PermutationTable[i] - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> PermutatedList</span><br><span class="line"><span class="comment">############################################################################################</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########加密过程的的交叉迭代####################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: make cross iteration on L0, R0 for 16 times</span></span><br><span class="line"><span class="string">    input: L0--the front 32 bits of 64-bits plain text , R0--the back 32 bits of plain text</span></span><br><span class="line"><span class="string">    return: R16--the back iterated 32-bits result, L16--the front iterated 32-bits result </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 16次交叉迭代，返回RL列表用于逆置换。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CrossIterationInEncryption</span><span class="params">(L_0, R_0, SecretKey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在进行加密过程的交叉迭代"</span>)</span><br><span class="line">    R = <span class="string">""</span></span><br><span class="line">    L = <span class="string">""</span></span><br><span class="line">    tmp_R = R_0</span><br><span class="line">    tmp_L = L_0</span><br><span class="line">    sonKeyList = createSonKey(SecretKey)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">17</span>):</span><br><span class="line">        L = tmp_R</span><br><span class="line">        R = XOROperation(tmp_L,Feistel(tmp_R,sonKeyList[i - <span class="number">1</span>]))</span><br><span class="line">        tmp_R = R</span><br><span class="line">        tmp_L = L</span><br><span class="line">    RL = R + L</span><br><span class="line">    <span class="keyword">return</span> RL </span><br><span class="line"><span class="comment">##############################################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####创建子密钥##################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: create the 16 son keys with the given key</span></span><br><span class="line"><span class="string">    return: sonKeysList: 16 son keys list</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createSonKey</span><span class="params">(SecretKey)</span>:</span></span><br><span class="line">    <span class="comment"># 提取密钥中的非校验位</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在生成16个子密钥"</span>)</span><br><span class="line">    str_56_bits_List = list(SecretKey)</span><br><span class="line">    sonKeyList = []</span><br><span class="line">    <span class="comment"># 进行PC-1置换</span></span><br><span class="line">    Temp_PC_1_PermutationResult_C_i_1, Temp_PC_1_PermutationResult_D_i_1 = PC_1_Permutation(str_56_bits_List) </span><br><span class="line">    C_i = []</span><br><span class="line">    D_i = []     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">17</span>):        </span><br><span class="line">        <span class="comment"># C_i-1 D_i-1</span></span><br><span class="line">        <span class="comment"># 计算C_i D_i</span></span><br><span class="line">        <span class="comment"># 循环左移</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">or</span> i == <span class="number">2</span> <span class="keyword">or</span> i == <span class="number">9</span> <span class="keyword">or</span> i == <span class="number">16</span>:</span><br><span class="line">            C_i = shiftLeft(Temp_PC_1_PermutationResult_C_i_1, <span class="number">1</span>)</span><br><span class="line">            D_i = shiftLeft(Temp_PC_1_PermutationResult_D_i_1, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            C_i = shiftLeft(Temp_PC_1_PermutationResult_C_i_1, <span class="number">2</span>)</span><br><span class="line">            D_i = shiftLeft(Temp_PC_1_PermutationResult_D_i_1, <span class="number">2</span>)</span><br><span class="line">        CD = C_i + D_i</span><br><span class="line">        <span class="comment"># PC2压缩置换</span></span><br><span class="line">        sonKey_i = PC_2_Permutation(CD)</span><br><span class="line">        sonKeyList.append(sonKey_i)  </span><br><span class="line">        Temp_PC_1_PermutationResult_C_i_1 = C_i</span><br><span class="line">        Temp_PC_1_PermutationResult_D_i_1 = D_i</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> sonKeyList</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#####Feistel 函数#############################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: Feistel function to create bit-stR_ing to permute with R_i -- a 32-bit stR_ing</span></span><br><span class="line"><span class="string">    input: R_i_1--the (i-1)th back 32 bits string, K_i--the son secret key</span></span><br><span class="line"><span class="string">    return: Feistel result (string type)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 轮函数：1. E扩展置换； 2. 扩展结果和子密钥进行异或运算 3. 进行S盒6-4转换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Feistel</span><span class="params">(R_i_1, K_i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在执行feistel轮函数"</span>)</span><br><span class="line">    E_ExpandResult = E_Expand(R_i_1)</span><br><span class="line">    xorResult = XOROperation(E_ExpandResult, K_i)</span><br><span class="line">    str_32_bits = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        str_6_bits = xorResult[i * <span class="number">6</span>: i * <span class="number">6</span> + <span class="number">6</span>]</span><br><span class="line">        str_32_bits += S_Box_Transformation(str_6_bits, i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(P_Permutation(str_32_bits))</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####随机生成64位key，8个字符#####################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    return: a 64-bits (8 bytes) string as a secret key</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createSecrteKey</span><span class="params">()</span>:</span></span><br><span class="line">    seed = <span class="string">"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()_+=-"</span></span><br><span class="line">    key = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        key.append(random.choice(seed))</span><br><span class="line">    randomSecretKey = <span class="string">''</span>.join(key)</span><br><span class="line">    <span class="keyword">return</span> randomSecretKey</span><br><span class="line"><span class="comment">################################################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##########8个字符的字符串转为ascii，然后转 0 1串####################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ToBitString</span><span class="params">(string_8_char)</span>:</span></span><br><span class="line">    strList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        strList.append(str(int2bin(ord(string_8_char[i]), <span class="number">8</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(strList)</span><br><span class="line"><span class="comment">##################################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########64位bits转为8个ascci字符###################################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ToAsciiChar</span><span class="params">(string_64_bits)</span>:</span></span><br><span class="line">    strList = []</span><br><span class="line">    bitList = list(string_64_bits)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> int(<span class="string">""</span>.join(bitList[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>]), <span class="number">2</span>) &lt; <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 八个bit一个处理单元，先转为10进制，然后转ascii，存入列表</span></span><br><span class="line">        strList.append(chr(int(<span class="string">""</span>.join(bitList[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>]), <span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(strList)</span><br><span class="line"><span class="comment">##################################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 加密过程和解密过程</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        text_8_bytes = PlainTextFile.read(<span class="number">8</span>)  <span class="comment"># 读取8个ascii字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text_8_bytes:</span><br><span class="line">            print(<span class="string">"读取明文文件到结尾啦"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(text_8_bytes) != <span class="number">8</span>:</span><br><span class="line">            full_flag = <span class="keyword">False</span></span><br><span class="line">          </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bitString = ToBitString(text_8_bytes) <span class="comment"># 8个ascii字符转十进制int，然后再转为64位01</span></span><br><span class="line">            <span class="comment"># 加密</span></span><br><span class="line">            encryptStr = Encryption(bitString, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 加密结果写入文件</span></span><br><span class="line">            CipherTextFile.write(str(ToAsciiChar(encryptStr)))</span><br><span class="line">            <span class="comment"># 解密</span></span><br><span class="line">            decryptStr = Decryption(encryptStr, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 解密结果写入文件 </span></span><br><span class="line">            DecryptTextFile.write(str(ToAsciiChar(decryptStr)))</span><br><span class="line">        <span class="keyword">if</span> full_flag == <span class="keyword">False</span>:  <span class="comment"># 如果尾部字节不足8个，那么每个字节都填入缺失的字节数量</span></span><br><span class="line">            NumOfLostBytes = <span class="number">8</span> - len(text_8_bytes)</span><br><span class="line">            bitStringList = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text_8_bytes)):</span><br><span class="line">                bitStringList.append(int2bin(ord(text_8_bytes[i]), <span class="number">8</span>))</span><br><span class="line">    </span><br><span class="line">            full_8_bits = int2bin(NumOfLostBytes, <span class="number">8</span>)  <span class="comment"># 填充的比特串</span></span><br><span class="line">            <span class="comment"># 填充的字节数 转为bitstring</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(NumOfLostBytes):</span><br><span class="line">                bitStringList.append(full_8_bits)</span><br><span class="line">            bitString = <span class="string">""</span>.join(bitStringList)  <span class="comment">#补全64位分组</span></span><br><span class="line">             <span class="comment"># 加密</span></span><br><span class="line">            encryptStr = Encryption(bitString, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 加密结果写入文件</span></span><br><span class="line">            CipherTextFile.write(str(ToAsciiChar(encryptStr)))</span><br><span class="line">            <span class="comment"># 解密</span></span><br><span class="line">            decryptStr = Decryption(encryptStr, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 解密结果写入文件 </span></span><br><span class="line">            DecryptTextFile.write(str(ToAsciiChar(decryptStr)))</span><br><span class="line">  <span class="comment"># 读取完整的8个字节分组字节，尾部填充8个字节，取值都为08</span></span><br><span class="line">    <span class="keyword">if</span> full_flag == <span class="keyword">True</span>:</span><br><span class="line">        zero_eight = <span class="string">"00001000"</span></span><br><span class="line">        tmpList = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            tmpList.append(zero_eight)</span><br><span class="line">        bitString = <span class="string">""</span>.join(tmpList)</span><br><span class="line">        <span class="comment"># 加密</span></span><br><span class="line">        encryptStr = Encryption(bitString, secretKeyBitString)</span><br><span class="line">        <span class="comment"># 加密结果写入文件</span></span><br><span class="line">        CipherTextFile.write(str(ToAsciiChar(encryptStr)))</span><br><span class="line">        <span class="comment"># 解密</span></span><br><span class="line">        decryptStr = Decryption(encryptStr, secretKeyBitString)</span><br><span class="line">        <span class="comment"># 解密结果写入文件 </span></span><br><span class="line">        DecryptTextFile.write(str(ToAsciiChar(decryptStr)))</span><br></pre></td></tr></table></figure><h3 id="数据结构说明"><a href="#数据结构说明" class="headerlink" title="数据结构说明"></a>数据结构说明</h3><ol><li>明文，密文，解密后的数据</li></ol><p>从明文文件中读取8个ascii字符，存放在string结构中，然后再转换为64个ascii字符的0 1 字符串作为加密的明文。加密结果和解密结果也是转换为ascii字符串，存放在文件中。</p><ol start="2"><li>加密解密过程的0 1 字符串数据</li></ol><p>在实际操作中，由于python中的string不支持赋值以及增删操作，所以通过python里的list即列表来存放字符串，通过list 方便的操作接口来执行加密解密。而string和list之间的转换方式也很简单，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List = list(str)    <span class="comment"># string 转 list</span></span><br><span class="line">str = <span class="string">""</span>.join(List) <span class="comment"># list 转string</span></span><br></pre></td></tr></table></figure><h2 id="三、-完整代码"><a href="#三、-完整代码" class="headerlink" title="三、 完整代码"></a>三、 完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    Autor: qiuyh </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    contact: 576261090@qq.com</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Date: 18/11/1</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Description: achieve an encryption algoriithm -- DES(Data Encryption Standard)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note: To code a nice code !</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#########文件变量</span></span><br><span class="line">CIPHER_TEXT_FILE = <span class="string">"cipherText.txt"</span>   <span class="comment">#密文文件</span></span><br><span class="line">PLAIN_TEXT_FILE = <span class="string">"plainText.txt"</span>     <span class="comment">#明文文件</span></span><br><span class="line">SECRET_KEY_FILE = <span class="string">"secretKey.txt"</span>     <span class="comment">#密钥文件</span></span><br><span class="line">DECRYPT_TEXT_FILE = <span class="string">"decryptText.txt"</span> <span class="comment">#解密文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######## 显示过程变量,为真显示加密步骤</span></span><br><span class="line">PRINT_FLAG = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########异或运算###################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function:do XOR operation on bits string s1, s2  异或运算</span></span><br><span class="line"><span class="string">    condition: len (s1) == len(s2)</span></span><br><span class="line"><span class="string">    return: xorResult -- the xor result and itstype is list</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XOROperation</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">    length = len(s1)     </span><br><span class="line">    xorResult = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">        <span class="comment"># 转为int类型0，1比特，进行异或操作后，转为string类型</span></span><br><span class="line">        xorResult.extend(str(int(s1[i]) ^ int(s2[i])))</span><br><span class="line">    <span class="keyword">return</span> xorResult</span><br><span class="line"><span class="comment">####################################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########## int 转 二进制 指定位数#####################################################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2bin</span><span class="params">(n, count=<span class="number">24</span>)</span>:</span></span><br><span class="line">    <span class="string">"""returns the binary of integer n, using count number of digits"""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join([str((n &gt;&gt; y) &amp; <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(count<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)])</span><br><span class="line"><span class="comment">######################################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######表格置换函数###################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: transfrom the binaryStr with the giver permutation table</span></span><br><span class="line"><span class="string">    condition: len(binaryStr) == len(PermutationTable)</span></span><br><span class="line"><span class="string">    return: the permutated binary List.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(binaryStr, PermutationTable)</span>:</span></span><br><span class="line">    length = len(PermutationTable)</span><br><span class="line">    PermutatedList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">        PermutatedList.extend(binaryStr[PermutationTable[i] - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> PermutatedList</span><br><span class="line"><span class="comment">####################################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##循环左移############################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: to achieve cycle shift n bits.</span></span><br><span class="line"><span class="string">    return: the shifted result.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftLeft</span><span class="params">(binaryStr, nBits)</span>:</span></span><br><span class="line">    length = len(binaryStr)</span><br><span class="line">    nBits = nBits % nBits</span><br><span class="line">    shiftedList = list(binaryStr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">        <span class="keyword">if</span> i &lt; nBits:</span><br><span class="line">            shiftedList.extend(shiftedList[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> shiftedList[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> shiftedList</span><br><span class="line"><span class="comment">####################################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##字节转比特#########################################################################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ByteToBit</span><span class="params">(ByteString)</span>:</span></span><br><span class="line">    bitList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">        bitList.insert(<span class="number">0</span>, str(ByteString%<span class="number">2</span>))</span><br><span class="line">        ByteString = int(ByteString / <span class="number">2</span>)</span><br><span class="line">    bitResult = <span class="string">""</span>.join(bitList)</span><br><span class="line">    <span class="keyword">return</span> bitResult</span><br><span class="line"><span class="comment">####################################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#########初始P置换####################################################################################</span></span><br><span class="line">InitialPermutationTable=[<span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>,<span class="number">2</span>,</span><br><span class="line">                        <span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span>,</span><br><span class="line">                        <span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">6</span>,</span><br><span class="line">                        <span class="number">64</span>,<span class="number">56</span>,<span class="number">48</span>,<span class="number">40</span>,<span class="number">32</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">8</span>,</span><br><span class="line">                        <span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">1</span>,</span><br><span class="line">                        <span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,</span><br><span class="line">                        <span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,</span><br><span class="line">                        <span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: Initial permutation function</span></span><br><span class="line"><span class="string">    input: M_0--64bit plain text block</span></span><br><span class="line"><span class="string">    return: L_0--the front 32 bits of M_0 , R0--the back 32 bits of M_0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InitialPermutation</span><span class="params">(M_0)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 进行初始IP置换"</span>)</span><br><span class="line">    InitialPermutationResult = Permutation(M_0, InitialPermutationTable)</span><br><span class="line">    L_0 = InitialPermutationResult[<span class="number">0</span>:int((len(InitialPermutationResult)/<span class="number">2</span>))]</span><br><span class="line">    R_0 = InitialPermutationResult[int((len(InitialPermutationResult)/<span class="number">2</span>)):int(len(InitialPermutationResult))]</span><br><span class="line">    <span class="keyword">return</span> L_0, R_0 <span class="comment"># List type</span></span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####PC-1置换#########################################################################################</span></span><br><span class="line">PC_1Table = [<span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,</span><br><span class="line">            <span class="number">1</span>,<span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,</span><br><span class="line">            <span class="number">10</span>,<span class="number">2</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,</span><br><span class="line">            <span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,</span><br><span class="line">            <span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,</span><br><span class="line">            <span class="number">7</span>,<span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,</span><br><span class="line">            <span class="number">14</span>,<span class="number">6</span>,<span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,</span><br><span class="line">            <span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: PC-1 permutation</span></span><br><span class="line"><span class="string">    input: 56 not checked bits of secret ley</span></span><br><span class="line"><span class="string">    return: C_0, D_0 </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PC_1_Permutation</span><span class="params">(SecretKey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 进行PC-1 置换"</span>)</span><br><span class="line">    PC_1_PermutationResult = Permutation(SecretKey, PC_1Table)</span><br><span class="line">    C_0 = PC_1_PermutationResult[<span class="number">0</span>: int(len(PC_1_PermutationResult)/<span class="number">2</span>)]</span><br><span class="line">    D_0 = PC_1_PermutationResult[int(len(PC_1_PermutationResult)/<span class="number">2</span>): int(len(PC_1_PermutationResult))]</span><br><span class="line">    <span class="keyword">return</span> C_0, D_0</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########循环左移函数######################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: do ring shift left on a str_28_bits</span></span><br><span class="line"><span class="string">    input: str_28_bits -- a 28 bits string; ShiftFlag -- when it is 1,2,9,16, shift 2 bits</span></span><br><span class="line"><span class="string">    return: shift_result</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RingShiftLeft</span><span class="params">(str_28_bits, ShiftFlag)</span>:</span></span><br><span class="line">    shiftResult = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> ShiftFlag == <span class="number">1</span> <span class="keyword">or</span> ShiftFlag == <span class="number">2</span> <span class="keyword">or</span> ShiftFlag == <span class="number">9</span> <span class="keyword">or</span> ShiftFlag == <span class="number">16</span>:</span><br><span class="line">        shiftResult = shiftLeft(str_28_bits, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shiftResult = shiftLeft(str_28_bits, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> shiftResult</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##########PC-2置换####################################################################################</span></span><br><span class="line">PC_2Table = [<span class="number">14</span>,<span class="number">17</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">5</span>,</span><br><span class="line">            <span class="number">3</span>,<span class="number">28</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">10</span>,</span><br><span class="line">            <span class="number">23</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">26</span>,<span class="number">8</span>,</span><br><span class="line">            <span class="number">16</span>,<span class="number">7</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">2</span>,</span><br><span class="line">            <span class="number">41</span>,<span class="number">52</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">55</span>,</span><br><span class="line">            <span class="number">30</span>,<span class="number">40</span>,<span class="number">51</span>,<span class="number">45</span>,<span class="number">33</span>,<span class="number">48</span>,</span><br><span class="line">            <span class="number">44</span>,<span class="number">49</span>,<span class="number">39</span>,<span class="number">56</span>,<span class="number">34</span>,<span class="number">53</span>,</span><br><span class="line">            <span class="number">46</span>,<span class="number">42</span>,<span class="number">50</span>,<span class="number">36</span>,<span class="number">29</span>,<span class="number">32</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: PC-2 compressed permutation</span></span><br><span class="line"><span class="string">    input:  str_56_bits</span></span><br><span class="line"><span class="string">    return: str_48_bits</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PC_2_Permutation</span><span class="params">(str_56_bits)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 进行PC-2置换"</span>)</span><br><span class="line">    <span class="comment">#  去掉9， 18， 22， 25， 35， 38，43， 54 位</span></span><br><span class="line">    str_48_bits = Permutation(str_56_bits, PC_2Table)</span><br><span class="line">    <span class="keyword">return</span> str_48_bits</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####创建子密钥##################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: create the 16 son keys with the given key</span></span><br><span class="line"><span class="string">    return: sonKeysList: 16 son keys list</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createSonKey</span><span class="params">(SecretKey)</span>:</span></span><br><span class="line">    <span class="comment"># 提取密钥中的非校验位</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在生成16个子密钥"</span>)</span><br><span class="line">    str_56_bits_List = list(SecretKey)</span><br><span class="line">    sonKeyList = []</span><br><span class="line">    <span class="comment"># 获取子密钥</span></span><br><span class="line">    Temp_PC_1_PermutationResult_C_i_1, Temp_PC_1_PermutationResult_D_i_1 = PC_1_Permutation(str_56_bits_List) </span><br><span class="line">    C_i = []</span><br><span class="line">    D_i = []     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">17</span>):        </span><br><span class="line">        <span class="comment"># C_i-1 D_i-1</span></span><br><span class="line">        <span class="comment"># 计算C_i D_i</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">or</span> i == <span class="number">2</span> <span class="keyword">or</span> i == <span class="number">9</span> <span class="keyword">or</span> i == <span class="number">16</span>:</span><br><span class="line">            C_i = shiftLeft(Temp_PC_1_PermutationResult_C_i_1, <span class="number">1</span>)</span><br><span class="line">            D_i = shiftLeft(Temp_PC_1_PermutationResult_D_i_1, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            C_i = shiftLeft(Temp_PC_1_PermutationResult_C_i_1, <span class="number">2</span>)</span><br><span class="line">            D_i = shiftLeft(Temp_PC_1_PermutationResult_D_i_1, <span class="number">2</span>)</span><br><span class="line">        CD = C_i + D_i</span><br><span class="line">        sonKey_i = PC_2_Permutation(CD)</span><br><span class="line">        sonKeyList.append(sonKey_i)  </span><br><span class="line">        Temp_PC_1_PermutationResult_C_i_1 = C_i</span><br><span class="line">        Temp_PC_1_PermutationResult_D_i_1 = D_i</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> sonKeyList</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######E扩展置换#################################################################################</span></span><br><span class="line">E_ExpandTable = [<span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br><span class="line">                <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</span><br><span class="line">                <span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,</span><br><span class="line">                <span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,</span><br><span class="line">                <span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,</span><br><span class="line">                <span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,</span><br><span class="line">                <span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,</span><br><span class="line">                <span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: E_Expand on the 32 bits R(i-1) string</span></span><br><span class="line"><span class="string">    input: R_i_1 -- the (i-1)th back 32 bits string</span></span><br><span class="line"><span class="string">    return: E_R_i_1 -- the 48 bits expanded string</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">E_Expand</span><span class="params">(R_i_1)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在进行E扩展置换"</span>)</span><br><span class="line">    E_R_i_1 = Permutation(R_i_1, E_ExpandTable)</span><br><span class="line">    <span class="keyword">return</span> E_R_i_1</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######S盒置换################################################################################</span></span><br><span class="line">eight_S_Boxes=[[<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>,</span><br><span class="line">                <span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,</span><br><span class="line">                <span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>,</span><br><span class="line">                <span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>,],</span><br><span class="line">                [<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>,</span><br><span class="line">                <span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>,</span><br><span class="line">                <span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>,</span><br><span class="line">                <span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>,],</span><br><span class="line">                [<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,</span><br><span class="line">                <span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>,</span><br><span class="line">                <span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>,</span><br><span class="line">                <span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>],</span><br><span class="line">                [<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>,</span><br><span class="line">                <span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>,</span><br><span class="line">                <span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,</span><br><span class="line">                <span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>,],</span><br><span class="line">                [<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,</span><br><span class="line">                <span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,</span><br><span class="line">                <span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>,</span><br><span class="line">                <span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>],</span><br><span class="line">                [<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,</span><br><span class="line">                <span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>,</span><br><span class="line">                <span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>,</span><br><span class="line">                <span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,],</span><br><span class="line">                [<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>,</span><br><span class="line">                <span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>,</span><br><span class="line">                <span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,</span><br><span class="line">                <span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>],</span><br><span class="line">                [<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>,</span><br><span class="line">                <span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>,</span><br><span class="line">                <span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,</span><br><span class="line">                <span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>]]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: to transfrom a 6-bits string to a 4-bits string with 8 S-Boxes</span></span><br><span class="line"><span class="string">    input: six_bits_str -- 6-bits string; S_Box_Num -- indicate the number of the S-Box [1, 8]</span></span><br><span class="line"><span class="string">    return: four_bits_str -- 4 bits string group</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">S_Box_Transformation</span><span class="params">(six_bits_str, S_Box_Num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在通过S盒进行6-4转换"</span>)</span><br><span class="line">    row = int(six_bits_str[<span class="number">0</span>]) * <span class="number">2</span> + int(six_bits_str[<span class="number">5</span>])</span><br><span class="line">    col = int(six_bits_str[<span class="number">1</span>]) * <span class="number">8</span> + int(six_bits_str[<span class="number">2</span>]) * <span class="number">4</span> + int(six_bits_str[<span class="number">3</span>]) * <span class="number">2</span> + int(six_bits_str[<span class="number">4</span>])</span><br><span class="line">    value = eight_S_Boxes[int(S_Box_Num - <span class="number">1</span>)][int(row * <span class="number">15</span> + col)]</span><br><span class="line">    four_bits_str = list(int2bin(value,<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">return</span> four_bits_str</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########P扩展置换##############################################################################</span></span><br><span class="line">P_Table=[<span class="number">16</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">21</span>,</span><br><span class="line">   <span class="number">29</span>,<span class="number">12</span>,<span class="number">28</span>,<span class="number">17</span>,</span><br><span class="line">   <span class="number">1</span>,<span class="number">15</span>,<span class="number">23</span>,<span class="number">26</span>,</span><br><span class="line">   <span class="number">5</span>,<span class="number">18</span>,<span class="number">31</span>,<span class="number">10</span>,</span><br><span class="line">   <span class="number">2</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">14</span>,</span><br><span class="line">   <span class="number">32</span>,<span class="number">27</span>,<span class="number">3</span>,<span class="number">9</span>,</span><br><span class="line">   <span class="number">19</span>,<span class="number">13</span>,<span class="number">30</span>,<span class="number">6</span>,</span><br><span class="line">   <span class="number">22</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">25</span>]</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: P_Permutation on the 32 bits string</span></span><br><span class="line"><span class="string">    input: str_32bits -- the 32 bits string List</span></span><br><span class="line"><span class="string">    return: FeistelResult -- the output of the feistel function</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">P_Permutation</span><span class="params">(str_32bits)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在进行P置换"</span>)</span><br><span class="line">    FeistelResult = Permutation(str_32bits, P_Table)</span><br><span class="line">    <span class="keyword">return</span> FeistelResult</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####Feistel 函数#########################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: Feistel function to create bit-stR_ing to permute with R_i -- a 32-bit stR_ing</span></span><br><span class="line"><span class="string">    input: R_i_1--the (i-1)th back 32 bits string, K_i--the son secret key</span></span><br><span class="line"><span class="string">    return: Feistel result (string type)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Feistel</span><span class="params">(R_i_1, K_i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在执行feistel轮函数"</span>)</span><br><span class="line">    E_ExpandResult = E_Expand(R_i_1)</span><br><span class="line">    xorResult = XOROperation(E_ExpandResult, K_i)</span><br><span class="line">    str_32_bits = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        str_6_bits = xorResult[i * <span class="number">6</span>: i * <span class="number">6</span> + <span class="number">6</span>]</span><br><span class="line">        str_32_bits += S_Box_Transformation(str_6_bits, i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(P_Permutation(str_32_bits))</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#########加密过程的的交叉迭代过程#####################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: make cross iteration on L0, R0 for 16 times</span></span><br><span class="line"><span class="string">    input: L0--the front 32 bits of 64-bits plain text , R0--the back 32 bits of plain text</span></span><br><span class="line"><span class="string">    return: R16--the back iterated 32-bits result, L16--the front iterated 32-bits result </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CrossIterationInEncryption</span><span class="params">(L_0, R_0, SecretKey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在进行加密过程的交叉迭代"</span>)</span><br><span class="line">    R = <span class="string">""</span></span><br><span class="line">    L = <span class="string">""</span></span><br><span class="line">    tmp_R = R_0</span><br><span class="line">    tmp_L = L_0</span><br><span class="line">    sonKeyList = createSonKey(SecretKey)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">17</span>):</span><br><span class="line">        L = tmp_R</span><br><span class="line">        R = XOROperation(tmp_L,Feistel(tmp_R,sonKeyList[i - <span class="number">1</span>]))</span><br><span class="line">        tmp_R = R</span><br><span class="line">        tmp_L = L</span><br><span class="line">    RL = R + L</span><br><span class="line">    <span class="keyword">return</span> RL </span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#########解密过程的的交叉迭代过程#####################################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: make cross iteration on L0, R0 for 16 times</span></span><br><span class="line"><span class="string">    input: L0--the front 32 bits of 64-bits cipher text , R0--the back 32 bits of cipher text</span></span><br><span class="line"><span class="string">    return: R16--the back iterated 32-bits result, L16--the front iterated 32-bits result </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CrossIterationInDecryption</span><span class="params">(L_0, R_0, SecretKey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在进行解密过程的交叉迭代"</span>)</span><br><span class="line">    R = []</span><br><span class="line">    L = []</span><br><span class="line">    tmp_R = R_0</span><br><span class="line">    tmp_L = L_0</span><br><span class="line">    sonKeyList = createSonKey(SecretKey)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">17</span>):</span><br><span class="line">        L = tmp_R</span><br><span class="line">        R = XOROperation(tmp_L,Feistel(tmp_R,sonKeyList[<span class="number">16</span> - i]))</span><br><span class="line">        tmp_R = R</span><br><span class="line">        tmp_L = L</span><br><span class="line">    RL = R + L</span><br><span class="line">    <span class="keyword">return</span> RL </span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######P 逆置换########################################################################################</span></span><br><span class="line">InversePermutationTable=[<span class="number">40</span>,<span class="number">8</span>,<span class="number">48</span>,<span class="number">16</span>,<span class="number">56</span>,<span class="number">24</span>,<span class="number">64</span>,<span class="number">32</span>,</span><br><span class="line">                        <span class="number">39</span>,<span class="number">7</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">55</span>,<span class="number">23</span>,<span class="number">63</span>,<span class="number">31</span>,</span><br><span class="line">                        <span class="number">38</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">14</span>,<span class="number">54</span>,<span class="number">22</span>,<span class="number">62</span>,<span class="number">30</span>,</span><br><span class="line">                        <span class="number">37</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">21</span>,<span class="number">61</span>,<span class="number">29</span>,</span><br><span class="line">                        <span class="number">36</span>,<span class="number">4</span>,<span class="number">44</span>,<span class="number">12</span>,<span class="number">52</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">28</span>,</span><br><span class="line">                        <span class="number">35</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">19</span>,<span class="number">59</span>,<span class="number">27</span>,</span><br><span class="line">                        <span class="number">34</span>,<span class="number">2</span>,<span class="number">42</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">18</span>,<span class="number">58</span>,<span class="number">26</span>,</span><br><span class="line">                        <span class="number">33</span>,<span class="number">1</span>,<span class="number">41</span>,<span class="number">9</span>,<span class="number">49</span>,<span class="number">17</span>,<span class="number">57</span>,<span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    function: inverse permutation on the R16L16 bit-stR_ing</span></span><br><span class="line"><span class="string">    input: R16--the back iterated 32-bits result, L16--the front iterated 32-bits result </span></span><br><span class="line"><span class="string">    return: ciphterText--64bits</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InversePermutation</span><span class="params">(R_16_L_16)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 正在进行逆置换"</span>)</span><br><span class="line">    cipherText = <span class="string">""</span></span><br><span class="line">    cipherText = Permutation(R_16_L_16, InversePermutationTable)</span><br><span class="line">    <span class="keyword">return</span> cipherText </span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####加密总函数#########################################################################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encryption</span><span class="params">(plainText, secretKey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 开始加密64位明文"</span>)</span><br><span class="line">    M = list(plainText)</span><br><span class="line">    L0, R0 = InitialPermutation(M)</span><br><span class="line">    RL = CrossIterationInEncryption(L0, R0, secretKey)</span><br><span class="line">    cipherText = <span class="string">""</span>.join(InversePermutation(RL))</span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######解密总函数###############################################################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decryption</span><span class="params">(cipherText, secretKey)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PRINT_FLAG == <span class="keyword">True</span>: </span><br><span class="line">        print(<span class="string">"&gt; 开始解密64位密文"</span>)</span><br><span class="line">    M = list(cipherText)</span><br><span class="line">    L0, R0 = InitialPermutation(M)</span><br><span class="line">    RL = CrossIterationInDecryption(L0, R0, secretKey)</span><br><span class="line">    decryptedText = <span class="string">""</span>.join(InversePermutation(RL))</span><br><span class="line">    <span class="keyword">return</span> decryptedText</span><br><span class="line"><span class="comment">##############################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####随机生成64位key，8个字符#####################################################################</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    return: a 64-bits (8 bytes) string as a secret key</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createSecrteKey</span><span class="params">()</span>:</span></span><br><span class="line">    seed = <span class="string">"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()_+=-"</span></span><br><span class="line">    key = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        key.append(random.choice(seed))</span><br><span class="line">    randomSecretKey = <span class="string">''</span>.join(key)</span><br><span class="line">    <span class="keyword">return</span> randomSecretKey</span><br><span class="line"><span class="comment">################################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##########8个字符的字符串转为ascii，然后转 0 1串####################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ToBitString</span><span class="params">(string_8_char)</span>:</span></span><br><span class="line">    strList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        strList.append(str(int2bin(ord(string_8_char[i]), <span class="number">8</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(strList)</span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########64位bits转为8个ascci字符###################################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ToAsciiChar</span><span class="params">(string_64_bits)</span>:</span></span><br><span class="line">    strList = []</span><br><span class="line">    bitList = list(string_64_bits)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> int(<span class="string">""</span>.join(bitList[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>]), <span class="number">2</span>) &lt; <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 八个bit一个处理单元，先转为10进制，然后转ascii，存入列表</span></span><br><span class="line">        strList.append(chr(int(<span class="string">""</span>.join(bitList[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>]), <span class="number">2</span>)))</span><br><span class="line">    <span class="comment">#print("ASCII:" + str(strList))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(strList)</span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    print("执行DES加密算法")</span></span><br><span class="line"><span class="string">    M="0000000100100011010001010110011110001001101010111100110111101111"#测试的明文</span></span><br><span class="line"><span class="string">    K="0001001100110100010101110111100110011011101111001101111111110001"#密钥</span></span><br><span class="line"><span class="string">    print("明文是" + M)</span></span><br><span class="line"><span class="string">    print("加密后:" + Encryption(M, K))</span></span><br><span class="line"><span class="string">    print("解密后" + Decryption(Encryption(M,K), K))</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"【DES程序说明】"</span>)</span><br><span class="line">    print(<span class="string">"1. 明文文件默认为同目录下的plainText.txt，如需加密其他文件，请修改16到20行代码的文件变量。"</span> )</span><br><span class="line">    print(<span class="string">"2. 密钥是随机生成的，保存在同目录的secretKey.txt文件中"</span>)</span><br><span class="line">    print(<span class="string">"3. 如果要显示加密和解密过程，可修改23行代码的打印变量，置为True"</span>)</span><br><span class="line">    print(<span class="string">"---------------------------------------------------------------------"</span>)</span><br><span class="line">    continueSign = input(<span class="string">"请按任意键执行加密和解密过程。。。"</span>)</span><br><span class="line">    print(<span class="string">"随机生成密钥中..."</span>)</span><br><span class="line">    secretKey = createSecrteKey()</span><br><span class="line">    <span class="keyword">with</span> open(SECRET_KEY_FILE, <span class="string">'w'</span>) <span class="keyword">as</span> sf:</span><br><span class="line">        sf.write(secretKey)</span><br><span class="line">    print(<span class="string">"密钥已写入文件"</span> + SECRET_KEY_FILE + <span class="string">"!"</span>)</span><br><span class="line">    secretKeyBitString = ToBitString(secretKey)</span><br><span class="line">    print(<span class="string">"得到密钥的 0 1字符串！"</span>)</span><br><span class="line">    </span><br><span class="line">    full_flag = <span class="keyword">True</span>   <span class="comment"># 分组为8的倍数的标志，为8则真</span></span><br><span class="line">    PlainTextFile = open(PLAIN_TEXT_FILE, <span class="string">'r'</span>)</span><br><span class="line">    CipherTextFile = open(CIPHER_TEXT_FILE, <span class="string">'w'</span>)</span><br><span class="line">    DecryptTextFile = open(DECRYPT_TEXT_FILE, <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        text_8_bytes = PlainTextFile.read(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text_8_bytes:</span><br><span class="line">            print(<span class="string">"读取明文文件到结尾啦"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> len(text_8_bytes) != <span class="number">8</span>:</span><br><span class="line">            full_flag = <span class="keyword">False</span></span><br><span class="line">          </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bitString = ToBitString(text_8_bytes)</span><br><span class="line">            <span class="comment"># 加密</span></span><br><span class="line">            encryptStr = Encryption(bitString, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 加密结果写入文件</span></span><br><span class="line">            CipherTextFile.write(str(ToAsciiChar(encryptStr)))</span><br><span class="line">            <span class="comment"># 解密</span></span><br><span class="line">            decryptStr = Decryption(encryptStr, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 解密结果写入文件 </span></span><br><span class="line">            DecryptTextFile.write(str(ToAsciiChar(decryptStr)))</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> full_flag == <span class="keyword">False</span>:</span><br><span class="line">            NumOfLostBytes = <span class="number">8</span> - len(text_8_bytes)</span><br><span class="line">            bitStringList = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text_8_bytes)):</span><br><span class="line">                bitStringList.append(int2bin(ord(text_8_bytes[i]), <span class="number">8</span>))</span><br><span class="line">    </span><br><span class="line">            full_8_bits = int2bin(NumOfLostBytes, <span class="number">8</span>)  <span class="comment"># 填充的比特串</span></span><br><span class="line">            <span class="comment"># 填充的字节数 转为bitstring</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(NumOfLostBytes):</span><br><span class="line">                bitStringList.append(full_8_bits)</span><br><span class="line">            bitString = <span class="string">""</span>.join(bitStringList)  <span class="comment">#补全64位分组</span></span><br><span class="line">             <span class="comment"># 加密</span></span><br><span class="line">            encryptStr = Encryption(bitString, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 加密结果写入文件</span></span><br><span class="line">            CipherTextFile.write(str(ToAsciiChar(encryptStr)))</span><br><span class="line">            <span class="comment"># 解密</span></span><br><span class="line">            decryptStr = Decryption(encryptStr, secretKeyBitString)</span><br><span class="line">            <span class="comment"># 解密结果写入文件 </span></span><br><span class="line">            DecryptTextFile.write(str(ToAsciiChar(decryptStr)))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 读取完整的8个字节分组字节，尾部填充8个字节，取值都为08</span></span><br><span class="line">    <span class="keyword">if</span> full_flag == <span class="keyword">True</span>:</span><br><span class="line">        zero_eight = <span class="string">"00001000"</span></span><br><span class="line">        tmpList = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            tmpList.append(zero_eight)</span><br><span class="line">        bitString = <span class="string">""</span>.join(tmpList)</span><br><span class="line">        <span class="comment"># 加密</span></span><br><span class="line">        encryptStr = Encryption(bitString, secretKeyBitString)</span><br><span class="line">        <span class="comment"># 加密结果写入文件</span></span><br><span class="line">        CipherTextFile.write(str(ToAsciiChar(encryptStr)))</span><br><span class="line">        <span class="comment"># 解密</span></span><br><span class="line">        decryptStr = Decryption(encryptStr, secretKeyBitString)</span><br><span class="line">        <span class="comment"># 解密结果写入文件 </span></span><br><span class="line">        DecryptTextFile.write(str(ToAsciiChar(decryptStr)))  </span><br><span class="line">    print(<span class="string">"加密成功！"</span>)</span><br><span class="line">    print(<span class="string">"解密成功！"</span>)</span><br><span class="line">    PlainTextFile.close()</span><br><span class="line">    CipherTextFile.close()</span><br><span class="line">    DecryptTextFile.close()</span><br><span class="line">    <span class="keyword">with</span> open(PLAIN_TEXT_FILE, <span class="string">'r'</span>) <span class="keyword">as</span> pf:</span><br><span class="line">        data = pf.read()</span><br><span class="line">        print(<span class="string">"明文为："</span>)</span><br><span class="line">        print(data)</span><br><span class="line">    <span class="keyword">with</span> open(CIPHER_TEXT_FILE, <span class="string">'r'</span>) <span class="keyword">as</span> cf:</span><br><span class="line">        data = cf.read()</span><br><span class="line">        print(<span class="string">"加密结果为："</span>)</span><br><span class="line">        print(data)</span><br><span class="line">    <span class="keyword">with</span> open(DECRYPT_TEXT_FILE, <span class="string">'r'</span>) <span class="keyword">as</span> df:</span><br><span class="line">        data = df.read()</span><br><span class="line">        print(<span class="string">"解密结果为："</span>)</span><br><span class="line">        print(data)</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本次DES算法实践有点崎岖，主要问题在于对整个算法的熟悉以及一些细节的问题处理如ascii字符和01互换，以及在置换过程中出现的溢出问题。debug相对比较困难，因为函数的输出结果经过各种置换后，已经很难分辨是真是假，哪一步出错，只有对算法流程足够熟悉才可以顺利的完成这个实验！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-DES算法原理概述&quot;&gt;&lt;a href=&quot;#一、-DES算法原理概述&quot; class=&quot;headerlink&quot; title=&quot;一、 DES算法原理概述&quot;&gt;&lt;/a&gt;一、 DES算法原理概述&lt;/h2&gt;&lt;h3 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; cla
      
    
    </summary>
    
    
      <category term="信息安全" scheme="https://joshuaqyh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://joshuaqyh.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于时间的概率推理</title>
    <link href="https://joshuaqyh.github.io/2018/11/26/ch15%20%E6%97%B6%E9%97%B4%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87%E6%8E%A8%E7%90%86/"/>
    <id>https://joshuaqyh.github.io/2018/11/26/ch15 时间上的概率推理/</id>
    <published>2018-11-26T14:44:12.876Z</published>
    <updated>2019-05-16T14:00:11.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h1><p>当前状态依赖于前一个状态，单阶的马尔可夫链；</p><p>当前状态依赖于前n个状态，n阶的马尔可夫链；</p><p><strong>传感器模型</strong></p><p>传感器马尔可夫假设： $$P(E_t | X_{0:t}, E_{0:t-1}) = P(E_t | X_t)$$</p><p>等式右边就是我们的传感器模型。 有$X_t$ 就可感应得到$E_t$。</p><p>物理含义就是<strong>当前的证据只与当前状态有关，即便给定了过去所有状态和证据。</strong></p><p><strong>状态转移模型</strong></p><p>$$P(X_i | X_{i-1}) = P(X_t | X_{0:t-1})$$  </p><p>物理含义就是<strong>给定前一个状态，计算当前状态的概率相当于给定所有状态时计算当前状态的概率</strong> 。给定前一个状态和给定过去所有状态的结果是一样的。</p><p>有了上述两个模型之后，加上初始状态模型$P(X_0)$, 我们就可以确定<strong>所有变量上完整的联合概率分布</strong>，从而确定其他类型的概率分布。 公式如下：</p><p>$$P(X_{0:t}, E_{1:t}) = P(X_0) \prod_{i=1}^tP(X_i | X_{i-1})P(E_i | X_i)$$</p><h2 id="形式化基本推理任务"><a href="#形式化基本推理任务" class="headerlink" title="形式化基本推理任务"></a>形式化基本推理任务</h2><ul><li><p>滤波。计算信念状态。给定当前所有证据，计算当前状态的后验概率分布。</p></li><li><p>预测。给定当前所有证据，计算未来状态的后验分布。</p></li><li><p>平滑。给定当前所有证据，计算过去某一状态的后验概率。</p></li><li><p>最可能的解释。给定观察序列，找到最可能生成这些观察结果的状态序列。</p></li><li><p>学习。从观察中学习，推理哪些确实会发生转移，估计。期望最大化算法。EM算法。</p><p>​</p></li></ul><h2 id="滤波过程"><a href="#滤波过程" class="headerlink" title="滤波过程"></a>滤波过程</h2><p>根据当前时刻已知的所有证据变量，计算当前状态的后验概率分布。</p><p>假设存在函数f使得 $P(X_{t+1} | e_{1:t+1}) = f(e_{t+1}, P(X_t | e_{1:t}))$,其物理含义就是已知t时刻的滤波结果$P(X_t | e_{1:t}) $和t+1时刻的证据$e_{t+1}$ ，可以计算下一个时刻t+1的滤波结果$P(X_t | e_{1:t}) $。该过程称为递归估计。</p><p>公式计算过程为：</p><p>$P(X_{t+1} | e_{1: t+1}) = P(X_{t + 1} | e_{1: t}, e_{t+1})$                          // 分解证据</p><p>​              $= \alpha P(e_{t+1} | X_{t+1}, e_{1:t})P(X_{t+1} | e_{1:t})$  // 使用贝叶斯规则</p><p>​                      $= \alpha P(e_{t+1} | X_{t+1}) P(X_{t+1} | e_{1:t})$            // 根据传感器马尔科夫假设</p><p>​            $=\alpha P(e_{t+1} | X_{t+1}) \sum_{x_t} P(X_{t+1}| x_t, e_{1:t})P(x_t | e_{1:t})$  // 分解为求和式</p><p>​            $= \alpha P(e_{t+1} | X_{t+1}) \sum_{x_t} P(X_{t+1} | x_t)P(x_t | e_{1:t})$       // <strong>马尔可夫假设</strong></p><p>上述的求和表达式中，第一个因子来自转移模型，第二个因子来自当前状态分布。由此得到了<strong>递归公式</strong> 。我们可以认为滤波估计$P(e_t | X_t)$ 是沿着序列从1到t的<strong>前向”消息”</strong>：$f_{1:t}$ ，在每一时刻发生转移时得到修正，并根据每一新的观察进行更新，该过程表达为 $f_{1:t+1} = \alpha Forward(f_{1:t}, e_{t+1})$ $Forward$函数实现了马尔可夫假设中的递归过程。</p><h2 id="平滑过程"><a href="#平滑过程" class="headerlink" title="平滑过程"></a>平滑过程</h2><p>给定现在已知的证据，计算过去某一状态的后验分布。</p><p>$$ 对于  0 \le k &lt; t\, 计算P(X_k | e_{1:t})$$ ，计算过程是:</p><p>$P(X_k | e_{1:t})  = P (X_k | e_{1: k}, e_{k+1:t})$                        //  分解证据 </p><p>​             $= \alpha P(X_k | e_{1:k})P(e_{k+1:t}| X_k, e_{1:k})  $ // 使用贝叶斯规则</p><p>​            $  = \alpha P(X_k | e_{1:k}) P (e_{k+1:t} | X_k)$          // 使用条件独立性</p><p>​            $ = \alpha f_{1:k} × b_{k+1:t}$</p><p> 结果代表 $\alpha *$ 前向消息 点乘 后向消息。</p><p>前向消息计算方法是通过从1到k的前向滤波过程，而后向消息的计算需要从时刻t到k+1进行反向递归。</p><p>$P(e_{k+1:t} | X_k) = \sum_{x_{k+1}} P(e_{k+1:t} | X_k, x_{k+1})P(X_{k+1} | X_k)$</p><p>​            $ = \sum_{x_{k+1}} P (e_{k+1:t} | x_{k+1}) P (x_{k+1} | X_k)$</p><p>​            $ = \sum_{x_{k+1}}P(e_{k+1} | x_{k+1})P(e_{k+2:t} | x_{k+1})P(x_{k+1} | X_k)$</p><h2 id="隐马尔可夫模型HMM"><a href="#隐马尔可夫模型HMM" class="headerlink" title="隐马尔可夫模型HMM"></a>隐马尔可夫模型HMM</h2><h2 id="卡尔曼滤波器"><a href="#卡尔曼滤波器" class="headerlink" title="卡尔曼滤波器"></a>卡尔曼滤波器</h2><p>使用观测到的离散量来估计连续变量的规律，使用隐马尔可夫模型来建模。</p><p>使用合适的条件概率密度来表示转移模型和传感器模型；</p><p>使用线性高斯分布，意味着下一状态$X_{t+1}$必须是当前状态$X_t$ 的线性函数，并加上一个高斯噪声$\sigma$。</p><p>$$X_{t+1} = \alpha X_t + \sigma$$</p><p>提炼为线性高斯转移模型为：</p><p>$$P(X_{t+ \gamma} = x_{t+\gamma}|X_t = x_t, X’_t = x’_t) = N (x_t + x’<em>t \gamma, \sigma^2)(x</em>{t+\gamma})$$</p><h2 id="动态贝叶斯网络DBN"><a href="#动态贝叶斯网络DBN" class="headerlink" title="动态贝叶斯网络DBN"></a>动态贝叶斯网络DBN</h2><p>每一个隐马尔可夫模型都可以表示为只有一个状态变量和一个证据变量的动态贝叶斯网络。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;马尔可夫过程&quot;&gt;&lt;a href=&quot;#马尔可夫过程&quot; class=&quot;headerlink&quot; title=&quot;马尔可夫过程&quot;&gt;&lt;/a&gt;马尔可夫过程&lt;/h1&gt;&lt;p&gt;当前状态依赖于前一个状态，单阶的马尔可夫链；&lt;/p&gt;
&lt;p&gt;当前状态依赖于前n个状态，n阶的马尔可夫链；&lt;/
      
    
    </summary>
    
    
      <category term="人工智能" scheme="https://joshuaqyh.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>人工智能 |贝叶斯网络基础知识</title>
    <link href="https://joshuaqyh.github.io/2018/11/26/ch%2013%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E9%87%8F%E5%8C%96/"/>
    <id>https://joshuaqyh.github.io/2018/11/26/ch 13不确定性的量化/</id>
    <published>2018-11-26T12:01:22.786Z</published>
    <updated>2019-05-16T14:04:13.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概率分布"><a href="#1-概率分布" class="headerlink" title="1. 概率分布"></a>1. 概率分布</h1><ul><li><p>先验概率等于无条件概率 $P(A)$</p></li><li><p>后验概率等于条件概率 $P(A|B)​$ </p></li><li><p>联合概率分布是由$A ,B$不同取值得到的一个$P(A,B )$概率分布。</p></li><li><p>完全联合分布中的<strong>边缘概率</strong>，是指某一随机变量成立的无条件概率，根据联合分布概率表累加计算可以得到。求得边缘概率的过程称为<strong>边缘化或者是求和消元化</strong>。</p><p>$P(A) = \sum_{z∈Z}P(A, z)$  求和消元化的联合分布表示</p><p>$P(A) = \sum_zP(A|z)P(z)$  根据乘法法则$P(A,z) = P(A | z) P(z)$ 可以求得求和消元化的条件概率分布。该规则也称条件化。</p></li><li><p>归一化常数 $\alpha$: $P(A |B) = \alpha P(AB)$。将$\alpha$替代$1 / P(B)$ 。</p></li><li><p>$P(X|e) = \alpha P(X ,e) = \alpha \sum_yP(X,e,y)$ 。</p></li></ul><h1 id="2-独立性"><a href="#2-独立性" class="headerlink" title="2. 独立性"></a>2. 独立性</h1><p>存在独立性，可进行概率分解降低模型的复杂度。</p><p>！条件独立的含义：事件A，B，C, 若在A概率未知的情况下，AB不独立，如果A概率已知，那么AB就存在条件独立的关系。</p><p>独立性的一个表现就是 $P(A | B) = P (A)$ ，当B与A无互相独立互不影响的时候。</p><p>其他表示: $ P(AB ) = P(A)P(B)$</p><h1 id="3-贝叶斯"><a href="#3-贝叶斯" class="headerlink" title="3. 贝叶斯"></a>3. 贝叶斯</h1><p>$P(Y|X)P(X) = P(X|Y)P(Y) = P(XY)$</p><p>从概率来看到原因的概率分布。</p><p>$ P(Y | X) = \frac{P(X | Y)P(Y)}{P(X)}$</p><p>如果某人是好人(概率为$P(Y)$),  某人偷东西的事件概率为($X$) ，如果发生了A偷东西$P(Y|X)$，那么A是好人的概率$P(Y | X)$。</p><p>放在实例中来观察贝叶斯公式的简单应用。在医疗诊断中，如果医生知道某一疾病发生某些症状的概率，那么可以利用贝叶斯公式估计得知当病人发生某症状时，推测病人发生某病的概率。</p><p>贝叶斯公式其实是反映了原因和结果之间的概率关系。</p><p>$ P(Cause | Effect) = \frac{P(Effect | Cause)P(Cause)}{P(Effect)}= \alpha P(Effect | Cause)P(Cause)$</p><p> 其中的 $P(Cause) P (Effect)$  二者都属于先验概率, $\alpha$ 是让  $P(Effect | Cause)$归一化的常数。</p><ul><li>朴素贝叶斯</li></ul><p>$P(Cause, Effect_1, Effect_2, Effect_3….Effect_n) = P(Cause) \prod_n P(Effect_i | Cause)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概率分布&quot;&gt;&lt;a href=&quot;#1-概率分布&quot; class=&quot;headerlink&quot; title=&quot;1. 概率分布&quot;&gt;&lt;/a&gt;1. 概率分布&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先验概率等于无条件概率 $P(A)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后验概率等于条
      
    
    </summary>
    
    
      <category term="人工智能" scheme="https://joshuaqyh.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>markdown 数学公式表示大集合</title>
    <link href="https://joshuaqyh.github.io/2018/10/22/markdown-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%A4%A7%E9%9B%86%E5%90%88/"/>
    <id>https://joshuaqyh.github.io/2018/10/22/markdown-数学公式表示大集合/</id>
    <published>2018-10-22T05:47:02.506Z</published>
    <updated>2018-10-22T05:47:02.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MarkDown-插入数学公式实验大集合"><a href="#MarkDown-插入数学公式实验大集合" class="headerlink" title="MarkDown 插入数学公式实验大集合"></a>MarkDown 插入数学公式实验大集合</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote><p>最近在学习一些机器学习相关的知识，想把自己学习的东西通过 MD 的形式在线记录下来，但是之前一直没有开始行动，因为里面的公式什么的感觉实在是麻烦。于是今天打算花点时间了解一下<a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fxiahouzuoxin%2Farticle%2Fdetails%2F26478179" target="_blank" rel="noopener"><code>如何在 markdown 中插入数学公式</code></a>，发现其实很简单，大概花一个小时左右就能知道如何编写了。</p></blockquote><h2 id="1-基础认识"><a href="#1-基础认识" class="headerlink" title="1. 基础认识"></a>1. 基础认识</h2><blockquote><p>笔者认为所谓插入数学公式其实就是引入一种规则，然后通过<code>模板？</code>渲染成公式，不知道这个理解对不对，不对望指正。其实你以前可能就看到过有的博客本该出现公式的时候不显示，点击后会链接到一个 new tab 然后显示一张公式的图片，有时却出现一大堆的代码。这里就是通过这段代码解析成公式然后显示的。</p></blockquote><p>这里我们选取 MathJax 引擎。 引入脚本，把下面代码插入 MD 文件里面，如果你怕这份在线文件源别人访问不到的话，可以把这个下下来自己做一个源，这样比较稳定缺点是要自己手动更新源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>好了到这里就可以插入公式了，如果你懂 LaTeX 的话那看一两个例子就知道了，不懂也没关系，自己写一写代码就知道了，可以找一个可以预览 MD 的工具一直尝试。</p><h3 id="1-1-插入方式"><a href="#1-1-插入方式" class="headerlink" title="1.1 插入方式"></a>1.1 插入方式</h3><blockquote><p>这里分两种，一种是行间插入，另一种是另取一行</p></blockquote><h4 id="1-1-1-行间插入"><a href="#1-1-1-行间插入" class="headerlink" title="1.1.1 行间插入"></a>1.1.1 行间插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\(a + b\\)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里是行间插入公式 a + b : (a + b)，特点就是通过<code>(</code> 和 <code>)</code> 包含公式，然后为了模板引擎能够区分该 <code>(</code> 不是普通文本的 <code>(</code> 而是公式的 <code>(</code>，通过 <code>\\</code> 转义一下。这样应该就很好理解这个语法构成了。注意这里方式不唯一，这是笔者喜欢的方式，其他的使用方式自行搜索。下面的介绍同样是这样。</p><p>PS: 这里掘金使用的是 <code>$a + b$</code> : <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%20%2B%20b" alt="a + b" title="">                </div>                <div class="image-caption">a + b</div>            </figure>，如果对您的阅读产生印象，请看最后说明，这里就不做一一更改了。谢谢。</p><h4 id="1-1-2-另取一行"><a href="#1-1-2-另取一行" class="headerlink" title="1.1.2 另取一行"></a>1.1.2 另取一行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$a + b$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里是另取一行</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%20%2B%20b" alt="a + b" title="">                </div>                <div class="image-caption">a + b</div>            </figure><p>特点就是通过<code>$$</code>包含公式。</p><p>笔者认为第二种方式更好，以下没看 JS 源码纯属猜测：行间的需要考虑到当前行的行高并对公式进行处理，而另取一行就更简单一些，可能解析起来更快。最最最最最最主要是看起来漂亮 ^_^ 不太要考虑空间不够换行。</p><h3 id="1-2-基本类型的插入"><a href="#1-2-基本类型的插入" class="headerlink" title="1.2 基本类型的插入"></a>1.2 基本类型的插入</h3><blockquote><p>这里对 <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fhoukai%2Fp%2F3399646.html" target="_blank" rel="noopener">@houkai ：LATEX数学公式基本语法</a> 的思路稍加修改，然后进行介绍。</p></blockquote><h4 id="1-2-1-上、下标"><a href="#1-2-1-上、下标" class="headerlink" title="1.2.1 上、下标"></a>1.2.1 上、下标</h4><p>先看结果再总结语法吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$$x_1$$</span><br><span class="line"></span><br><span class="line">$$x_1^2$$</span><br><span class="line"></span><br><span class="line">$$x^2_1$$</span><br><span class="line"></span><br><span class="line">$$x_&#123;22&#125;^&#123;(n)&#125;$$</span><br><span class="line"></span><br><span class="line">$$&#123;&#125;^*x^*$$</span><br><span class="line"></span><br><span class="line">$$x_&#123;balabala&#125;^&#123;bala&#125;$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=x_1" alt="x_1" title="">                </div>                <div class="image-caption">x_1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=x_1%5E2" alt="x_1^2" title="">                </div>                <div class="image-caption">x_1^2</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=x%5E2_1" alt="x^2_1" title="">                </div>                <div class="image-caption">x^2_1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=x_%7B22%7D%5E%7B(n)%7D" alt="x_{22}^{(n)}" title="">                </div>                <div class="image-caption">x_{22}^{(n)}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%7B%7D%5E*x%5E*" alt="{}^*x^*" title="">                </div>                <div class="image-caption">{}^*x^*</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=x_%7Bbalabala%7D%5E%7Bbala%7D" alt="x_{balabala}^{bala}" title="">                </div>                <div class="image-caption">x_{balabala}^{bala}</div>            </figure><p>可以看到 <code>x</code> 元素的上标通过 <code>^</code> 符号后接的内容体现，下表通过 <code>_</code> 符号后接的内容体现，多于一位是要加 <code>{}</code> 包裹的。 笔者习惯先下标后上标的写法，和我的书写习惯一致：<code>x_{balabala}^{bala}</code>，不管你使用哪一种风格，最好自己注意统一，不要混用。</p><h4 id="1-2-2-分式"><a href="#1-2-2-分式" class="headerlink" title="1.2.2 分式"></a>1.2.2 分式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;x+y&#125;&#123;2&#125;$$</span><br><span class="line"></span><br><span class="line">$$\frac&#123;1&#125;&#123;1+\frac&#123;1&#125;&#123;2&#125;&#125;$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cfrac%7Bx%2By%7D%7B2%7D" alt="frac{x+y}{2}" title="">                </div>                <div class="image-caption">frac{x+y}{2}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cfrac%7B1%7D%7B1%2B%5Cfrac%7B1%7D%7B2%7D%7D" alt="frac{1}{1+frac{1}{2}}" title="">                </div>                <div class="image-caption">frac{1}{1+frac{1}{2}}</div>            </figure><p>这里就出现了一个 <code>frac{}{}</code> 函数的东西，同样，为了区分这是函数不是几个字母，通过 <code>\frac</code>转义，于是 <code>frac</code> 被解析成函数，然后第一个 <code>{}</code> 里面的被解析成分子，第二个 <code>{}</code> 被解析成分母。这里可以试试分数的行间解析<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cfrac%7B1%7D%7B1%2B%5Cfrac%7B1%7D%7B2%7D%7D" alt="frac{1}{1+frac{1}{2}}" title="">                </div>                <div class="image-caption">frac{1}{1+frac{1}{2}}</div>            </figure>。我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果。</p><h4 id="1-2-3-根式"><a href="#1-2-3-根式" class="headerlink" title="1.2.3 根式"></a>1.2.3 根式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$\sqrt&#123;2&#125;&lt;\sqrt[3]&#123;3&#125;$$</span><br><span class="line"></span><br><span class="line">$$\sqrt&#123;1+\sqrt[p]&#123;1+a^2&#125;&#125;$$</span><br><span class="line"></span><br><span class="line">$$\sqrt&#123;1+\sqrt[^p\!]&#123;1+a^2&#125;&#125;$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Csqrt%7B2%7D%3C%5Csqrt%5B3%5D%7B3%7D" alt="sqrt{2}<sqrt[3]{3}" title="">                </div>                <div class="image-caption">sqrt{2}<sqrt[3]{3}< div="">            </sqrt[3]{3}<></div></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Csqrt%7B1%2B%5Csqrt%5Bp%5D%7B1%2Ba%5E2%7D%7D" alt="sqrt{1+sqrt[p]{1+a^2}}" title="">                </div>                <div class="image-caption">sqrt{1+sqrt[p]{1+a^2}}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Csqrt%7B1%2B%5Csqrt%5B%5Ep%5D%7B1%2Ba%5E2%7D%7D" alt="sqrt{1+sqrt[^p]{1+a^2}}" title="">                </div>                <div class="image-caption">sqrt{1+sqrt[^p]{1+a^2}}</div>            </figure><p>读到这里你已经了解了函数的概念，那么这历久很简单了，语法就是 <code>sqrt[]{}</code> 。<code>[]</code> 中代表是几次根式，<code>{}</code> 代表根号下的表达式。第二和第三个的区别在于为了美观微调位置 ^_^。</p><h4 id="1-2-4-求和、积分"><a href="#1-2-4-求和、积分" class="headerlink" title="1.2.4 求和、积分"></a>1.2.4 求和、积分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;k=1&#125;^&#123;n&#125;\frac&#123;1&#125;&#123;k&#125;$$</span><br><span class="line"></span><br><span class="line">$\sum_&#123;k=1&#125;^n\frac&#123;1&#125;&#123;k&#125;$</span><br><span class="line"></span><br><span class="line">$$\int_a^b f(x)dx$$</span><br><span class="line"></span><br><span class="line">$\int_a^b f(x)dx$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%5Cfrac%7B1%7D%7Bk%7D" alt="sum_{k=1}^{n}frac{1}{k}" title="">                </div>                <div class="image-caption">sum_{k=1}^{n}frac{1}{k}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Csum_%7Bk%3D1%7D%5En%5Cfrac%7B1%7D%7Bk%7D" alt="sum_{k=1}^nfrac{1}{k}" title="">                </div>                <div class="image-caption">sum_{k=1}^nfrac{1}{k}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cint_%7Ba%7D%5Eb%20f(x)dx" alt="int_{a}^b f(x)dx" title="">                </div>                <div class="image-caption">int_{a}^b f(x)dx</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cint_a%5Eb%20f(x)dx" alt="int_a^b f(x)dx" title="">                </div>                <div class="image-caption">int_a^b f(x)dx</div>            </figure><p>这里很容易看出求和函数表达式 <code>sum_{起点}^{终点}表达式</code>，积分函数表达式 <code>int_下限^上限 被积函数d被积量</code>。还有一个有趣的是行间的公式都被压缩了。</p><h4 id="1-2-5-空格"><a href="#1-2-5-空格" class="headerlink" title="1.2.5 空格"></a>1.2.5 空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">紧贴 $a\!b$</span><br><span class="line">没有空格 $ab$</span><br><span class="line">小空格 a\,b</span><br><span class="line">中等空格 a\;b</span><br><span class="line">大空格 a\ b</span><br><span class="line">quad空格 $a\quad b$</span><br><span class="line">两个quad空格 $a\qquad b$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%5C!b" alt="a!b" title="">                </div>                <div class="image-caption">a!b</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=ab" alt="ab" title="">                </div>                <div class="image-caption">ab</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%5C%2Cb" alt="a,b" title="">                </div>                <div class="image-caption">a,b</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%5C%3Bb" alt="a;b" title="">                </div>                <div class="image-caption">a;b</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%5C%20b" alt="a b" title="">                </div>                <div class="image-caption">a b</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%5Cquad%20b" alt="aquad b" title="">                </div>                <div class="image-caption">aquad b</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=a%5Cqquad%20b" alt="aqquad b" title="">                </div>                <div class="image-caption">aqquad b</div>            </figure><p>这个直接看上面的文字，介绍很清楚，主要指微调距离，使得公式更加漂亮。请比较下面的积分公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$\int_a^b f(x)\mathrm&#123;d&#125;x$$</span><br><span class="line"></span><br><span class="line">$$\int_a^b f(x)\,\mathrm&#123;d&#125;x$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cint_a%5Eb%20f(x)%5Cmathrm%7Bd%7Dx" alt="int_a^b f(x)mathrm{d}x" title="">                </div>                <div class="image-caption">int_a^b f(x)mathrm{d}x</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cint_a%5Eb%20f(x)%5C%2C%5Cmathrm%7Bd%7Dx" alt="int_a^b f(x),mathrm{d}x" title="">                </div>                <div class="image-caption">int_a^b f(x),mathrm{d}x</div>            </figure><h4 id="1-2-6-公式界定符"><a href="#1-2-6-公式界定符" class="headerlink" title="1.2.6 公式界定符"></a>1.2.6 公式界定符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\\( ( \\)</span><br><span class="line">\\( ) \\)</span><br><span class="line">\\( [ \\)</span><br><span class="line">\\( ] \\)</span><br><span class="line">\\( \\&#123; \\)</span><br><span class="line">\\( \\&#125; \\)</span><br><span class="line">\\( | \\)</span><br><span class="line">\\( \\| \\)</span><br><span class="line"></span><br><span class="line">掘金：</span><br><span class="line">$ ( $</span><br><span class="line">$ ) $</span><br><span class="line">$ [ $</span><br><span class="line">$ ] $</span><br><span class="line">$ \&#123; $</span><br><span class="line">$ \&#125; $</span><br><span class="line">$ | $</span><br><span class="line">$ \| $</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>主要符号有 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5C%7C" alt="(](https://juejin.im/equation?tex=() ![)](https://juejin.im/equation?tex=)) ![[](https://juejin.im/equation?tex=%5B) ![]](https://juejin.im/equation?tex=%5D) ![{](https://juejin.im/equation?tex=%5C%7B) ![}](https://juejin.im/equation?tex=%5C%7D) ![|](https://juejin.im/equation?tex=%7C) ![|" title="">                </div>                <div class="image-caption">(](https://juejin.im/equation?tex=() ![)](https://juejin.im/equation?tex=)) ![[](https://juejin.im/equation?tex=%5B) ![]](https://juejin.im/equation?tex=%5D) ![{](https://juejin.im/equation?tex=%5C%7B) ![}](https://juejin.im/equation?tex=%5C%7D) ![|](https://juejin.im/equation?tex=%7C) ![|</div>            </figure> 那么如何使用呢？ 通过 <code>\left</code> 和 <code>\right</code> 后面跟界定符来对同时进行界定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$\left(\sum_&#123;k=\frac&#123;1&#125;&#123;2&#125;&#125;^&#123;N^2&#125;\frac&#123;1&#125;&#123;k&#125;\right)$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cleft(%5Csum_%7Bk%3D%5Cfrac%7B1%7D%7B2%7D%7D%5E%7BN%5E2%7D%5Cfrac%7B1%7D%7Bk%7D%5Cright)" alt="left(sum_{k=frac{1}{2}}^{N^2}frac{1}{k}ight)" title="">                </div>                <div class="image-caption">left(sum_{k=frac{1}{2}}^{N^2}frac{1}{k}ight)</div>            </figure><h4 id="1-2-7-矩阵"><a href="#1-2-7-矩阵" class="headerlink" title="1.2.7 矩阵"></a>1.2.7 矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;matrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;matrix&#125;$$</span><br><span class="line"></span><br><span class="line">$$\begin&#123;pmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">$$\begin&#123;bmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;bmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">$$\begin&#123;Bmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;Bmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">$$\begin&#123;vmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;vmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">$$\left|\begin&#123;matrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;matrix&#125;\right|$$</span><br><span class="line"></span><br><span class="line">$$\begin&#123;Vmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;Vmatrix&#125;$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Bmatrix%7D1%20%26%202%5C%5C%5C%5C3%20%264%5Cend%7Bmatrix%7D" alt="begin{matrix}1 & 2\\3 &4end{matrix}" title="">                </div>                <div class="image-caption">begin{matrix}1 & 2\\3 &4end{matrix}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Bpmatrix%7D1%20%26%202%5C%5C%5C%5C3%20%264%5Cend%7Bpmatrix%7D" alt="begin{pmatrix}1 & 2\\3 &4end{pmatrix}" title="">                </div>                <div class="image-caption">begin{pmatrix}1 & 2\\3 &4end{pmatrix}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Bbmatrix%7D1%20%26%202%5C%5C%5C%5C3%20%264%5Cend%7Bbmatrix%7D" alt="begin{bmatrix}1 & 2\\3 &4end{bmatrix}" title="">                </div>                <div class="image-caption">begin{bmatrix}1 & 2\\3 &4end{bmatrix}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7BBmatrix%7D1%20%26%202%5C%5C%5C%5C3%20%264%5Cend%7BBmatrix%7D" alt="begin{Bmatrix}1 & 2\\3 &4end{Bmatrix}" title="">                </div>                <div class="image-caption">begin{Bmatrix}1 & 2\\3 &4end{Bmatrix}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Bvmatrix%7D1%20%26%202%5C%5C%5C%5C3%20%264%5Cend%7Bvmatrix%7D" alt="begin{vmatrix}1 & 2\\3 &4end{vmatrix}" title="">                </div>                <div class="image-caption">begin{vmatrix}1 & 2\\3 &4end{vmatrix}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cleft%7C%5Cbegin%7Bmatrix%7D1%20%26%202%5C%5C%5C%5C3%20%264%5Cend%7Bmatrix%7D%5Cright%7C" alt="left|begin{matrix}1 & 2\\3 &4end{matrix}ight|" title="">                </div>                <div class="image-caption">left|begin{matrix}1 & 2\\3 &4end{matrix}ight|</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7BVmatrix%7D1%20%26%202%5C%5C%5C%5C3%20%264%5Cend%7BVmatrix%7D" alt="begin{Vmatrix}1 & 2\\3 &4end{Vmatrix}" title="">                </div>                <div class="image-caption">begin{Vmatrix}1 & 2\\3 &4end{Vmatrix}</div>            </figure><p>类似于 left right，这里是 begin 和 end。而且里面有具体的矩阵语法，<code>&amp;</code> 区分行间元素，<code>\\\\</code>代表换行。可以理解为 HTML 的标签之类的。</p><h4 id="1-2-8-排版数组"><a href="#1-2-8-排版数组" class="headerlink" title="1.2.8 排版数组"></a>1.2.8 排版数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\mathbf&#123;X&#125; =</span><br><span class="line">\left( \begin&#123;array&#125;&#123;ccc&#125;</span><br><span class="line">x\_&#123;11&#125; &amp; x\_&#123;12&#125; &amp; \ldots \\\\</span><br><span class="line">x\_&#123;21&#125; &amp; x\_&#123;22&#125; &amp; \ldots \\\\</span><br><span class="line">\vdots &amp; \vdots &amp; \ddots</span><br><span class="line">\end&#123;array&#125; \right)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cmathbf%7BX%7D%20%3D%0A%5Cleft(%20%5Cbegin%7Barray%7D%7Bccc%7D%0Ax%5C_%7B11%7D%20%26%20x%5C_%7B12%7D%20%26%20%5Cldots%20%5C%5C%5C%5C%0Ax%5C_%7B21%7D%20%26%20x%5C_%7B22%7D%20%26%20%5Cldots%20%5C%5C%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%0A%5Cend%7Barray%7D%20%5Cright)" alt="mathbf{X} =left( begin{array}{ccc}x_{11} & x_{12} & ldots \\x_{21} & x_{22} & ldots \\vdots & vdots & ddotsend{array} ight)" title="">                </div>                <div class="image-caption">mathbf{X} =left( begin{array}{ccc}x_{11} & x_{12} & ldots \\x_{21} & x_{22} & ldots \\vdots & vdots & ddotsend{array} ight)</div>            </figure><h2 id="2-常用公式举例"><a href="#2-常用公式举例" class="headerlink" title="2. 常用公式举例"></a>2. 常用公式举例</h2><blockquote><p>持续更新……</p></blockquote><h3 id="2-1-多行公式"><a href="#2-1-多行公式" class="headerlink" title="2.1 多行公式"></a>2.1 多行公式</h3><blockquote><p>主要是各种方程的表达</p></blockquote><h4 id="2-1-1-长公式"><a href="#2-1-1-长公式" class="headerlink" title="2.1.1 长公式"></a>2.1.1 长公式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;multline&#125;</span><br><span class="line">x = a+b+c+&#123;&#125; \\\\</span><br><span class="line">d+e+f+g</span><br><span class="line">\end&#123;multline&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\\\</span><br><span class="line">&amp;d+e+f+g</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不对齐</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cleft%7C%20%5Cbegin%7Bmultline%7D%0Ax%20%3D%20a%2Bb%2Bc%2B%7B%7D%20%5C%5C%5C%5C%0Ad%2Be%2Bf%2Bg%0A%5Cend%7Bmultline%7D%20%5Cright%7C" alt="left| begin{multline}x = a+b+c+{} \\d+e+f+gend{multline} ight|" title="">                </div>                <div class="image-caption">left| begin{multline}x = a+b+c+{} \\d+e+f+gend{multline} ight|</div>            </figure><p>对齐</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cleft%7C%20%5Cbegin%7Baligned%7D%0Ax%20%3D%7B%7D%26%20a%2Bb%2Bc%2B%7B%7D%20%5C%5C%5C%5C%0A%26d%2Be%2Bf%2Bg%0A%5Cend%7Baligned%7D%20%5Cright%7C" alt="left| begin{aligned}x ={}& a+b+c+{} \\&d+e+f+gend{aligned} ight|" title="">                </div>                <div class="image-caption">left| begin{aligned}x ={}& a+b+c+{} \\&d+e+f+gend{aligned} ight|</div>            </figure><h4 id="2-1-2-公式组"><a href="#2-1-2-公式组" class="headerlink" title="2.1.2 公式组"></a>2.1.2 公式组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;gather&#125;</span><br><span class="line">a = b+c+d \\\\</span><br><span class="line">x = y+z</span><br><span class="line">\end&#123;gather&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">a &amp;= b+c+d \\\\</span><br><span class="line">x &amp;= y+z</span><br><span class="line">\end&#123;align&#125;</span><br><span class="line">$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Bgather%7D%0Aa%20%3D%20b%2Bc%2Bd%20%5C%5C%5C%5C%0Ax%20%3D%20y%2Bz%0A%5Cend%7Bgather%7D" alt="begin{gather}a = b+c+d \\x = y+zend{gather}" title="">                </div>                <div class="image-caption">begin{gather}a = b+c+d \\x = y+zend{gather}</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Balign%7D%0Aa%20%26%3D%20b%2Bc%2Bd%20%5C%5C%5C%5C%0Ax%20%26%3D%20y%2Bz%0A%5Cend%7Balign%7D" alt="begin{align}a &= b+c+d \\x &= y+zend{align}" title="">                </div>                <div class="image-caption">begin{align}a &= b+c+d \\x &= y+zend{align}</div>            </figure><h4 id="2-1-3-分段函数"><a href="#2-1-3-分段函数" class="headerlink" title="2.1.3 分段函数"></a>2.1.3 分段函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">y=\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x\leq 0 \\\\</span><br><span class="line">x,\quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=y%3D%5Cbegin%7Bcases%7D%0A-x%2C%5Cquad%20x%5Cleq%200%20%5C%5C%5C%5C%0Ax%2C%5Cquad%20x%3E0%0A%5Cend%7Bcases%7D" alt="y=begin{cases}-x,quad xleq 0 \\x,quad x>0end{cases}" title="">                </div>                <div class="image-caption">y=begin{cases}-x,quad xleq 0 \\x,quad x>0end{cases}</div>            </figure><p>里面用到了 (\leq) 符号，下一章会介绍常用数学符号。</p><h3 id="2-2-数组的其他使用"><a href="#2-2-数组的其他使用" class="headerlink" title="2.2 数组的其他使用"></a>2.2 数组的其他使用</h3><h4 id="2-2-1-划线"><a href="#2-2-1-划线" class="headerlink" title="2.2.1 划线"></a>2.2.1 划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left(\begin&#123;array&#125;&#123;|c|c|&#125;</span><br><span class="line">1 &amp; 2 \\\\</span><br><span class="line">\\hline</span><br><span class="line">3 &amp; 4</span><br><span class="line">\end&#123;array&#125;\right)</span><br><span class="line">$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cleft(%20%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D%0A1%20%26%20%5Cldots%20%5C%5C%5C%5C%0A%5Chline%0A%5Cvdots%20%26%20%5Cddots%20%0A%5Cend%7Barray%7D%20%5Cright)" alt="left( begin{array}{|c|c|}1 & ldots \\hlinevdots & ddots end{array} ight)" title="">                </div>                <div class="image-caption">left( begin{array}{|c|c|}1 & ldots \\hlinevdots & ddots end{array} ight)</div>            </figure><h4 id="2-2-2-制表"><a href="#2-2-2-制表" class="headerlink" title="2.2.2 制表"></a>2.2.2 制表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;|c|c|&#125;</span><br><span class="line">\hline</span><br><span class="line">&#123;1111111111&#125; &amp; 2 \\\\</span><br><span class="line">\hline</span><br><span class="line">3 &amp; 4 \\\\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D%0A%5Chline%0A%7B1111111111%7D%20%26%202%20%5C%5C%5C%5C%0A%5Chline%0A%7Bbalabala%7D%20%26%20%E4%BD%A0%E5%A5%BD%E5%95%8A%20%5C%5C%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D" alt="begin{array}{|c|c|}hline{1111111111} & 2 \\hline{balabala} & 你好啊 \\hlineend{array}" title="">                </div>                <div class="image-caption">begin{array}{|c|c|}hline{1111111111} & 2 \\hline{balabala} & 你好啊 \\hlineend{array}</div>            </figure><p>可以看到，其实其他很多东西都可以很灵活的表达出来。碰到其他有趣的我会继续写出来的。</p><h2 id="3-常用数学符号"><a href="#3-常用数学符号" class="headerlink" title="3. 常用数学符号"></a>3. 常用数学符号</h2><blockquote><p>这里提供一个<a href="https://link.juejin.im/?target=http%3A%2F%2Ffiles.cnblogs.com%2Fhoukai%2FLATEX%25E6%2595%25B0%25E5%25AD%25A6%25E7%25AC%25A6%25E5%258F%25B7%25E8%25A1%25A8.rar" target="_blank" rel="noopener">文档下载</a>，如果上面的链接失效，也可以到我的 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmk43%2FBlogResource%2Fblob%2Fmaster%2FLaTex%2FLATEX%25E6%2595%25B0%25E5%25AD%25A6%25E7%25AC%25A6%25E5%258F%25B7%25E8%25A1%25A8.pdf" target="_blank" rel="noopener">GitHub 下载 pdf 版</a>。下面举几个例子。</p></blockquote><h3 id="3-1-希腊字母"><a href="#3-1-希腊字母" class="headerlink" title="3.1 希腊字母"></a>3.1 希腊字母</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;|c|c|c|c|c|c|c|c|&#125;</span><br><span class="line">\hline</span><br><span class="line">&#123;\alpha&#125; &amp; &#123;\backslash alpha&#125; &amp; &#123;\theta&#125; &amp; &#123;\backslash theta&#125; &amp; &#123;o&#125; &amp; &#123;o&#125; &amp; &#123;\upsilon&#125; &amp; &#123;\backslash upsilon&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\beta&#125; &amp; &#123;\backslash beta&#125; &amp; &#123;\vartheta&#125; &amp; &#123;\backslash vartheta&#125; &amp; &#123;\pi&#125; &amp; &#123;\backslash pi&#125; &amp; &#123;\phi&#125; &amp; &#123;\backslash phi&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\gamma&#125; &amp; &#123;\backslash gamma&#125; &amp; &#123;\iota&#125; &amp; &#123;\backslash iota&#125; &amp; &#123;\varpi&#125; &amp; &#123;\backslash varpi&#125; &amp; &#123;\varphi&#125; &amp; &#123;\backslash varphi&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\delta&#125; &amp; &#123;\backslash delta&#125; &amp; &#123;\kappa&#125; &amp; &#123;\backslash kappa&#125; &amp; &#123;\rho&#125; &amp; &#123;\backslash rho&#125; &amp; &#123;\chi&#125; &amp; &#123;\backslash chi&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\epsilon&#125; &amp; &#123;\backslash epsilon&#125; &amp; &#123;\lambda&#125; &amp; &#123;\backslash lambda&#125; &amp; &#123;\varrho&#125; &amp; &#123;\backslash varrho&#125; &amp; &#123;\psi&#125; &amp; &#123;\backslash psi&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\varepsilon&#125; &amp; &#123;\backslash varepsilon&#125; &amp; &#123;\mu&#125; &amp; &#123;\backslash mu&#125; &amp; &#123;\sigma&#125; &amp; &#123;\backslash sigma&#125; &amp; &#123;\omega&#125; &amp; &#123;\backslash omega&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\zeta&#125; &amp; &#123;\backslash zeta&#125; &amp; &#123;\nu&#125; &amp; &#123;\backslash nu&#125; &amp; &#123;\varsigma&#125; &amp; &#123;\backslash varsigma&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\eta&#125; &amp; &#123;\backslash eta&#125; &amp; &#123;\xi&#125; &amp; &#123;\backslash xi&#125; &amp; &#123;\tau&#125; &amp; &#123;\backslash tau&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\Gamma&#125; &amp; &#123;\backslash Gamma&#125; &amp; &#123;\Lambda&#125; &amp; &#123;\backslash Lambda&#125; &amp; &#123;\Sigma&#125; &amp; &#123;\backslash Sigma&#125; &amp; &#123;\Psi&#125; &amp; &#123;\backslash Psi&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\Delta&#125; &amp; &#123;\backslash Delta&#125; &amp; &#123;\Xi&#125; &amp; &#123;\backslash Xi&#125; &amp; &#123;\Upsilon&#125; &amp; &#123;\backslash Upsilon&#125; &amp; &#123;\Omega&#125; &amp; &#123;\backslash Omega&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">&#123;\Omega&#125; &amp; &#123;\backslash Omega&#125; &amp; &#123;\Pi&#125; &amp; &#123;\backslash Pi&#125; &amp; &#123;\Phi&#125; &amp; &#123;\backslash Phi&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://juejin.im/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7Cc%7Cc%7Cc%7Cc%7Cc%7Cc%7C%7D%0A%5Chline%0A%7B%5Calpha%7D%20%26%20%7B%5Cbackslash%20alpha%7D%20%26%20%7B%5Ctheta%7D%20%26%20%7B%5Cbackslash%20theta%7D%20%26%20%7Bo%7D%20%26%20%7Bo%7D%20%26%20%7B%5Cupsilon%7D%20%26%20%7B%5Cbackslash%20upsilon%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5Cbeta%7D%20%26%20%7B%5Cbackslash%20beta%7D%20%26%20%7B%5Cvartheta%7D%20%26%20%7B%5Cbackslash%20vartheta%7D%20%26%20%7B%5Cpi%7D%20%26%20%7B%5Cbackslash%20pi%7D%20%26%20%7B%5Cphi%7D%20%26%20%7B%5Cbackslash%20phi%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5Cgamma%7D%20%26%20%7B%5Cbackslash%20gamma%7D%20%26%20%7B%5Ciota%7D%20%26%20%7B%5Cbackslash%20iota%7D%20%26%20%7B%5Cvarpi%7D%20%26%20%7B%5Cbackslash%20varpi%7D%20%26%20%7B%5Cvarphi%7D%20%26%20%7B%5Cbackslash%20varphi%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5Cdelta%7D%20%26%20%7B%5Cbackslash%20delta%7D%20%26%20%7B%5Ckappa%7D%20%26%20%7B%5Cbackslash%20kappa%7D%20%26%20%7B%5Crho%7D%20%26%20%7B%5Cbackslash%20rho%7D%20%26%20%7B%5Cchi%7D%20%26%20%7B%5Cbackslash%20chi%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5Cepsilon%7D%20%26%20%7B%5Cbackslash%20epsilon%7D%20%26%20%7B%5Clambda%7D%20%26%20%7B%5Cbackslash%20lambda%7D%20%26%20%7B%5Cvarrho%7D%20%26%20%7B%5Cbackslash%20varrho%7D%20%26%20%7B%5Cpsi%7D%20%26%20%7B%5Cbackslash%20psi%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5Cvarepsilon%7D%20%26%20%7B%5Cbackslash%20varepsilon%7D%20%26%20%7B%5Cmu%7D%20%26%20%7B%5Cbackslash%20mu%7D%20%26%20%7B%5Csigma%7D%20%26%20%7B%5Cbackslash%20sigma%7D%20%26%20%7B%5Comega%7D%20%26%20%7B%5Cbackslash%20omega%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5Czeta%7D%20%26%20%7B%5Cbackslash%20zeta%7D%20%26%20%7B%5Cnu%7D%20%26%20%7B%5Cbackslash%20nu%7D%20%26%20%7B%5Cvarsigma%7D%20%26%20%7B%5Cbackslash%20varsigma%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5Ceta%7D%20%26%20%7B%5Cbackslash%20eta%7D%20%26%20%7B%5Cxi%7D%20%26%20%7B%5Cbackslash%20xi%7D%20%26%20%7B%5Ctau%7D%20%26%20%7B%5Cbackslash%20tau%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5CGamma%7D%20%26%20%7B%5Cbackslash%20Gamma%7D%20%26%20%7B%5CLambda%7D%20%26%20%7B%5Cbackslash%20Lambda%7D%20%26%20%7B%5CSigma%7D%20%26%20%7B%5Cbackslash%20Sigma%7D%20%26%20%7B%5CPsi%7D%20%26%20%7B%5Cbackslash%20Psi%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5CDelta%7D%20%26%20%7B%5Cbackslash%20Delta%7D%20%26%20%7B%5CXi%7D%20%26%20%7B%5Cbackslash%20Xi%7D%20%26%20%7B%5CUpsilon%7D%20%26%20%7B%5Cbackslash%20Upsilon%7D%20%26%20%7B%5COmega%7D%20%26%20%7B%5Cbackslash%20Omega%7D%20%5C%5C%5C%5C%0A%5Chline%0A%7B%5COmega%7D%20%26%20%7B%5Cbackslash%20Omega%7D%20%26%20%7B%5CPi%7D%20%26%20%7B%5Cbackslash%20Pi%7D%20%26%20%7B%5CPhi%7D%20%26%20%7B%5Cbackslash%20Phi%7D%20%26%20%7B%7D%20%26%20%7B%7D%20%5C%5C%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D" alt="begin{array}{|c|c|c|c|c|c|c|c|}hline{alpha} & {backslash alpha} & {heta} & {backslash theta} & {o} & {o} & {upsilon} & {backslash upsilon} \\hline{beta} & {backslash beta} & {vartheta} & {backslash vartheta} & {pi} & {backslash pi} & {phi} & {backslash phi} \\hline{gamma} & {backslash gamma} & {iota} & {backslash iota} & {varpi} & {backslash varpi} & {varphi} & {backslash varphi} \\hline{delta} & {backslash delta} & {kappa} & {backslash kappa} & {ho} & {backslash rho} & {chi} & {backslash chi} \\hline{epsilon} & {backslash epsilon} & {lambda} & {backslash lambda} & {varrho} & {backslash varrho} & {psi} & {backslash psi} \\hline{varepsilon} & {backslash varepsilon} & {mu} & {backslash mu} & {sigma} & {backslash sigma} & {omega} & {backslash omega} \\hline{zeta} & {backslash zeta} & {u} & {backslash nu} & {varsigma} & {backslash varsigma} & {} & {} \\hline{eta} & {backslash eta} & {xi} & {backslash xi} & {au} & {backslash tau} & {} & {} \\hline{Gamma} & {backslash Gamma} & {Lambda} & {backslash Lambda} & {Sigma} & {backslash Sigma} & {Psi} & {backslash Psi} \\hline{Delta} & {backslash Delta} & {Xi} & {backslash Xi} & {Upsilon} & {backslash Upsilon} & {Omega} & {backslash Omega} \\hline{Omega} & {backslash Omega} & {Pi} & {backslash Pi} & {Phi} & {backslash Phi} & {} & {} \\hlineend{array}" title="">                </div>                <div class="image-caption">begin{array}{|c|c|c|c|c|c|c|c|}hline{alpha} & {backslash alpha} & {heta} & {backslash theta} & {o} & {o} & {upsilon} & {backslash upsilon} \\hline{beta} & {backslash beta} & {vartheta} & {backslash vartheta} & {pi} & {backslash pi} & {phi} & {backslash phi} \\hline{gamma} & {backslash gamma} & {iota} & {backslash iota} & {varpi} & {backslash varpi} & {varphi} & {backslash varphi} \\hline{delta} & {backslash delta} & {kappa} & {backslash kappa} & {ho} & {backslash rho} & {chi} & {backslash chi} \\hline{epsilon} & {backslash epsilon} & {lambda} & {backslash lambda} & {varrho} & {backslash varrho} & {psi} & {backslash psi} \\hline{varepsilon} & {backslash varepsilon} & {mu} & {backslash mu} & {sigma} & {backslash sigma} & {omega} & {backslash omega} \\hline{zeta} & {backslash zeta} & {u} & {backslash nu} & {varsigma} & {backslash varsigma} & {} & {} \\hline{eta} & {backslash eta} & {xi} & {backslash xi} & {au} & {backslash tau} & {} & {} \\hline{Gamma} & {backslash Gamma} & {Lambda} & {backslash Lambda} & {Sigma} & {backslash Sigma} & {Psi} & {backslash Psi} \\hline{Delta} & {backslash Delta} & {Xi} & {backslash Xi} & {Upsilon} & {backslash Upsilon} & {Omega} & {backslash Omega} \\hline{Omega} & {backslash Omega} & {Pi} & {backslash Pi} & {Phi} & {backslash Phi} & {} & {} \\hlineend{array}</div>            </figure><p>写太累了😂😂😂。。。其他的详见 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmk43%2FBlogResource%2Fblob%2Fmaster%2FLaTex%2FLATEX%25E6%2595%25B0%25E5%25AD%25A6%25E7%25AC%25A6%25E5%258F%25B7%25E8%25A1%25A8.pdf" target="_blank" rel="noopener">PDF</a>。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><blockquote><p>通过这样梳理一下基本的公式都能插入了，而且也会如何查资料。对于自己日后学习 LaTeX 写论文有很大帮助。以下建议带有很强的主观性，仅供参考。</p></blockquote><ul><li>公式一律使用另取一行，并且上下都空一行</li><li>一个公式一个语句，不要写在一个 <code>$$***$$</code> 里，保证<code>独立性</code>，一个公式错误不影响另一个公式。</li><li>风格统一，不要混用。比如上下标的写法：<code>x_{balabala}^{bala}</code></li><li>行间字母可以使用 <code>\\(a\\)</code> 代替 <code>a</code> ，养成自己的写作风格。</li></ul><p>最后：我的 <a href="https://link.juejin.im/?target=http%3A%2F%2Ffitzeng.org%2F" target="_blank" rel="noopener">Blog</a> 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmk43" target="_blank" rel="noopener">GitHub</a>，感谢阅读。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><blockquote><p>十分感谢以下作者的无私分享。</p></blockquote><ol><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fxiahouzuoxin%2Farticle%2Fdetails%2F26478179" target="_blank" rel="noopener">Markdown中插入数学公式的方法</a></li><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fhoukai%2Fp%2F3399646.html" target="_blank" rel="noopener">LATEX数学公式基本语法</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fliam0205.me%2F2014%2F09%2F08%2Flatex-introduction%2F" target="_blank" rel="noopener">一份其实很短的 LaTeX 入门文档</a></li></ol><p>说明：掘金好像有些转义不出来，如果想看效果可以<a href="https://link.juejin.im/?target=http%3A%2F%2Ffitzeng.org%2F2018%2F01%2F23%2FLaTexFormula%2F" target="_blank" rel="noopener">参考这篇</a>自己多试试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MarkDown-插入数学公式实验大集合&quot;&gt;&lt;a href=&quot;#MarkDown-插入数学公式实验大集合&quot; class=&quot;headerlink&quot; title=&quot;MarkDown 插入数学公式实验大集合&quot;&gt;&lt;/a&gt;MarkDown 插入数学公式实验大集合&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="markdown" scheme="https://joshuaqyh.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>区块链挑战，应用和发展</title>
    <link href="https://joshuaqyh.github.io/2018/10/21/%E5%88%9D%E6%8E%A2%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%8C%91%E6%88%98%EF%BC%8C%E5%BA%94%E7%94%A8%E5%92%8C%E5%8F%91%E5%B1%95/"/>
    <id>https://joshuaqyh.github.io/2018/10/21/初探区块链的挑战，应用和发展/</id>
    <published>2018-10-21T01:57:20.688Z</published>
    <updated>2018-10-21T01:58:23.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-引言"><a href="#一、-引言" class="headerlink" title="一、 引言"></a>一、 引言</h3><p>​    区块链技术被认为是继互联网、人工智能以后又一大颠覆式的技术创新，其内在的发展潜力被无数人所追求。以区块链技术为原理的比特币等加密数字货币的兴起，让区块链技术得以走向公众的视线。提及区块链，我们往往会联想到其特性，分布式，可溯源，去中心化，不可篡改，安全匿名，公开透明等等。区块链凭借这些前所未有的技术优势获得了政府，学术界，企业们的青睐和高度的重视。近年来，无论是科技巨头还是中小的初创公司，都在积极的布局着区块链，关于区块链的的技术创新和模式创新不断涌现。但对于区块链这一新型事物，各行各业都处在摸石头过河的阶段，探索着区块链有效的应用场景。</p><p>​    关于如何看待区块链，公众的看法不一。有人一直唱衰，称其为泡沫；有人坚持信念，在区块链的浪潮中砥砺前行，期待区块链价值的焕发，试图成为社会变革的先驱者。区块链发展的主流观点是：区块链将是一种实现信息互联网到价值互联网转变的跨越式技术，一定程度上能够节约生产成本，提高生产效率，并有望成为未来的核心基础设施，推动社会方方面面的变革和进步，包括金融，经济贸易，社会管理，公共服务等等。区块链创造性地去除了许多系统应用的约束，为很多想法的实现提供了新的可能。以比特币为代表的加密数字货币，改变了传统的金融业交易模式；火热的以太坊智能合约，结合日渐发达的物联网，让我们看到了智能合约型社会在未来的可能。</p><p>​    从技术的角度来看，区块链就是一个结合P2P协议和加密技术分布式的公共账本，网络上的每一个节点都有可能在账本上添加记录，但决定记账权的方法是通过多种的共识算法如PoW, PoS来实现的。记账就是把数据打包成一个区块添加到一条最长的区块链上，该区块上的数据可追溯可验证。区块链的分布式存储决定了其去中心化，公开透明，信息共享；基于安全的哈希算法和共识算法，使其具备了不可篡改的特性；非对称加密技术让参与主体安全匿名，隐私得到保护；而时间戳技术让区块链上的数据可追溯可审核。</p><p>​    从社会科学的角度来看，区块链就是一个通过算法来制造信任和定义信用的机器，在任何需要信任的领域，都有区块链的用武之地。我们知道，在中心化的结构体系中，各方参与者只需要服从中心确立好的共识即可，共识的达成将是十分高效的，而对于分布式，各自取其益的情况下，达成共识则非常难。共识机制的建立，使去中心化的区块链记账系统成为了现实。总的来说，区块链创造了一个数字化的，有效地传输价值的信用系统。</p><p>​    区块链技术将有助于实现软件定义的社会系统，是下一代云计算的雏形，有望像互联网一般彻底重塑人类活动形态，并实现从目前的信息互联网向价值互联网的转变。目前整体发展态势虽没有17年比特币大火时那样的激进，围绕币市的各种业务正感受着区块链“泡沫”破灭的寒冬，以往那种投机主义者的空气币，割韭菜的喧嚣正逐渐退去，区块链的真正发展和价值落地才刚刚开始，泡沫破灭的过程恰似一个适者生存，劣者淘汰的过程，只有经过时间和现实情况检验过的优秀项目才能存活下来。</p><p>​    依托成熟的云计算技术体系，业界也出现了“区块链即服务（BaaS）”的平台，主要提供了联盟链及公有链这2种服务，包括IBM的Bluemix，微软的Bletchley，腾讯的TBaaS；与此同时，我国在《“十三五”国家信息化规划》中把区块链作为一项重点前沿的技术，明确提出需加强区块链等新技术的创新，试验和应用，以实现抢占新一代信息技术主导权。目前，我国区块链技术持续创新，区块链产业初步形成，开始在供应链金融、征信、产品溯源、版权交易、数字身份、电子证据等领域快速应用，有望推动我国经济体系实现技术变革，组织变革和效率变革，为构建现代化经济体系作出重要贡献。</p><h3 id="二、区块链面临的挑战"><a href="#二、区块链面临的挑战" class="headerlink" title="二、区块链面临的挑战"></a>二、区块链面临的挑战</h3><p>​    开放，共享，去中心化是互联网的重要精神，而区块链则高度契合了这一精神。从时间跨度上看，区块链的诞生时间比较晚，具有极大的发展潜力和空间，而相关的行业发展经验和学术研究仍是不足的，更是决定了区块链技术在今后的发展中仍然还会面临极大的挑战。本文主要总结了以下几个较为明显和迫切的挑战：</p><ol><li><p>技术层面仍有不足之处<br>1.1安全性问题</p><p>​    我们知道在比特币的共识过程中，如果汇聚了超过51%的算力时，就有可能达成篡改区块链的数据。我们通常所说的区块链的数据不可篡改其实是相对而言的，因为共识过程需要消耗大量的算力，当篡改成本远远大于实际成本时，可以近似看作不可篡改，但这一威胁的存在并不能忽视，更为安全有效的共识机制有待更深入的研究和设计。</p><p>​    随着量子计算等新型计算技术的发展，区块链的密码学保护可能会变得越来越脆弱，非对称的加密技术有可能在今后得到破解，所以对加密技术的研究的进程仍要跟上，不能止步于前。</p><p>​    而区块链中的隐私匿名保护特性其实也存在着被追踪的可能性，有学者也提供了一种根据比特币交易事务进行时追踪用户IP地址的情况。随着各类反匿名身份甄别技术的发展, 加上区块链上的数据公开透明，实现部分重点目标的定位和标识也存在可能。如何加强匿名保护的技术，也是当前区块链研究的热点方向。</p><p>1.2效率问题</p><p>​    区块链的效率问题一直为人诟病，甚至有人宣称区块链技术存在天然瓶颈。交易效率慢，如比特币区块链每秒仅能处理7笔交易，这极大限制了区块链在商业世界的应用。还有有一种说法就是区块链实际就是一个造价昂贵的缓慢数据库，与其花大价钱来打造分布式的区块链数据库不如精心去维护好集中式的数据库。而且当数据区块越来越大的时候，因为分布式存储的原因，区块链数据将会变的臃肿庞大。</p><p>​    不过短时间内效率低并不是阻碍区块链的重要原因，对于共识机制效率如何改善相信会有好的进展。从另一个角度来讲，效率低也是安全的一种保证。可能我们在安全和效率之间需要一个良好的折衷方案吧。</p></li><li><p>监管问题</p><p>​    提及到监管问题，首先想到区块链的去中心化，接着是匿名性。去中心化意味着不受中心的掌控，匿名性意味着难以追踪参与者。从负面效果来看，去中心化是不受控制，放任自由，为所欲为；匿名则意味着包庇，躲避正义的追踪。</p><p>​    举个例子，一开始比特币流通的环境是在暗网，交易双方信息保密，只关注交易事务本身不关注交易双方。比特币的匿名性跟暗网的隐匿性有天然的契合度，利用比特币在暗网交易，走私，贩毒，洗钱等等难以追查，成了犯罪分子的天堂。</p><p>​    利用区块链来进行洗钱的途径也是存在的，尤其不能忽视发行代币的风险，要时刻警惕空气币，ICO的陷阱，防止其破坏金融市场的稳定，减少无良资本家割韭菜的局面。在监管层面必须做到对虚拟货币的发行，控制，管理，甚至禁止。在区块链发展的同时，相应的法律法规和政策也要跟上脚步。国家在发展布局区块链的时候，干预力度和引导的力度要如何拿捏才能更好地发挥区块链的社会价值呢，这是个值得挖掘的问题。</p></li><li><p>趋中心化问题</p><p>​    区块链自从走入公众视野就以去中心化的特点引起无数人的兴趣和追捧，这得益于分布式的共识机制，所谓人人都有记账权，人人都享有一份公共一致的账本，人人都有对账本上写入的记录的监督权。但是现有的共识机制，依旧有中心化的趋势，真正的去中心化可能渐渐消失。</p><p>​    以比特币的PoW共识机制为例，挖矿的矿工如果集中到一起，形成一个足够大的矿池，获得记账权的概率就更大，去中心化可能会演变成中心化，记账权掌握在少数人手里。PoW就是比拼谁的算力大，谁的算力越大获得的比特币奖励就越多，这个过程跟买彩票一样，越有钱的人买的彩票越多，中奖几率越大，而事实是越有钱的人会购买算力更大性能更优的矿机，挖到比特币的可能性更多发生在这些挖矿专业户手中。比特币的奖励集中到某些一小部分人的手上，比特币价格居高不下，财富就越是汇聚到这些人的手上。相似地，基于PoS的共识机制也会出现相同的问题，那些持有币数量越大，币龄越高的人越有可能获得记账权。这近乎是一种马太效应！弱中心化和重回中心化的威胁不容小觑！</p><p>​    或许完全去中心化的共识机制只是一个乌托邦式的幻想，就像人们曾经热衷于追求永动机一般，但这并不意味着人们要停止对区块链的探索，更为安全有效的共识机制仍要很长的一段时间去检验其有效性和正确性，去中心化未必能完美准确地达成，但近似地有效地达成去中心化的特性，将无疑带给社会一次前所未有的变革。</p></li></ol><h3 id="三、-区块链的多元化应用"><a href="#三、-区块链的多元化应用" class="headerlink" title="三、 区块链的多元化应用"></a>三、 区块链的多元化应用</h3><p>​    区块链行业的应用非常多元，但实际落地条件可能还需要多次实践和配套基础设施的建立和完善。各国政府对待区块链的态度和政策也从很大程度上左右着区块链的发展方向和未来，区块链未来会是在哪些行业发光发彩。而在当前，各类与行业特点相结合的区块链项目如雨后春笋般涌现，预示着整个区块链产业的潜力。与“互联网+”类似，本文主要讨论几个当前较为大众所热议以及具有较为清晰发展前景的应用，以供了解。</p><ol><li><p>金融</p><p>​    金融领域是与科技界联系较为紧密的领域，许多技术的创新都能很快被金融领域所嗅探到，并且得到很好的应用，所以在金融业也出现了“金融科技（FinTech）”等理念。诚然，金融领域几乎是天然与区块链系统契合的，金融领域的许多痛点仿佛在区块链的技术支撑下找到了良好的解决方案。传统金融的中心化，交易繁琐复杂，安全性有限都是亟需解决的痛点，“区块链+”</p><p>1.1 数字货币</p><p>​    最具代表性的数字货币当属比特币，同时也是目前世界影响最为广泛的一个应用。比特币可以安全方便地将数字资产转移给另外一个人，得以于这些特性，比特币很快就在交易相关的行业发展。比特币是一个工具，系统无法限制人们使用它的方式，比如一个较为灰色的例子，暗网上的“丝绸之路”网站就通过比特币定价并且进行交易，随后被美国FBI查封并且收缴了26000比特币，虽然数字货币存在被不法分子不正当利用的情形，但我们依旧能看到数字货币在市场上流通实验的成功实践。</p><p>​    不过数字货币去中心化的特点依旧对许多国家的货币机制产生了威胁，常常被认为是金融不稳定的因素。如何看待ICO，如何加强数字货币的监督管控，是每个国家都要面对和思考的问题。目前数字货币还没有在全世界的国家之间达成共识，如何制定有效的法律法规来引导数字货币的发展，数字币作为一个新生儿，仍然不断接收着世人的拷问。</p><p>1.2 供应链金融</p><p>​    供应链金融是银行将核心企业和上下游企业联系在一起提供灵活运用的金融产品和服务的一种融资模式。供应链金融参与方主要包括：核心企业，中小企业，金融机构和第三方支持服务。核心企业通常对上下游的供应商、经销商在定价、账期等方面要求苛刻，供应链中的中小企业常出现资金紧张、周转困难等情况，导致供应链效率大幅降低甚至停止运转。因此，供应链金融产业面临的核心问题是中小企业融资难，融资贵，成本高，周转效率低。供应链金融平台、核心企业系统交易本身的真实性难以验证，导致资金端风控成本居高不下。</p><p>​    区块链分布式记账以及共识机制，恰好建立了一套可信的信用体系，在数据验证和追溯上提供了有力的技术支撑，贯穿了金融供应链上下游的各方的信用。运用区块链技术，可以将核心企业的信用数字化，写入智能合约，依托智能合约来防范金融风险，使信用在供应链上有效传导，降低合作成本，提高生产效率。还可以使用智能合约来实现对供应链资金的拆分和流转，提高资金的周转效率，为中小企业解决融资难，融资贵的问题。</p><p>1.3 贸易金融</p><p>​    区块链就是一个用共识算法建立起来的具备信用的公共账本，开放共享的特性在贸易金融领域也有一番用武之地。传统银行之间存在着信息不对称以及交流不畅，信用鉴定繁琐的痛点，银行之间的业务报文的传递还大多依靠着国际组织Swift，EDI等等。利用区块链来建立银行之间的业务报文收发联盟的问题，简化业务流程，着手打造自己基于区块链系统的贸易金融平台，也就是通常讲的联盟链，已经成为一种新的发展思路。</p><p>​    往更开阔的角度来思考其应用，区块链多方可参与的特点有利于连接一切利益相关者，如区块链相关企业，政府部门一起来构建一个更完善，更自动化，更具信用价值的贸易金融生态。</p><p>1.4财务管理</p><p>​    区块链可审查，可追溯，不可篡改的特性也在财务管理方面有着出色的表现。在交易清算方面，区块链让多方共享一套可信互相认可的公共账本体系，所有的交易清算可实时的记录在区块链账本上，不可篡改，可追溯，大大提高了对账的准确率和效率。搭载智能合约之后，还能实现自动化的交易清结算，减少对账人员的成本和差错率。在审计方面，区块链能提高对企业财务信息的监督水平，虚假交易和账目造假难度大大提升。另外，通过区块链网络的实时性以及可审核性，审计效率也能大大提升，节约人力成本。而且区块链还能显著降低审计数据被攻击的风险，分布式的存储让审计数据的保护变得稳定可靠。</p><p>除了上述四点，区块链和金融场景的结合还有诸多的可能，电子信用凭证，跨境汇款查询应用，风险管理，企业改革等等，在未来将会有炫目的表现。</p></li><li><p>物联网</p><p>​    如今的物联网实现物物通信的方式是经由中心化的云服务器，该模式存在的弊端是当接入设备大幅增加时，服务器面临的负载将会越重，而在未来，上亿级的设备互联是必然的。到了那时云服务将会带来巨额成本，这是物联网发展的一个绊脚石。而且传统物联网数据容易受到攻击，具有诸多信息安全风险问题。区块链+物联网则通过多个节点参与验证，将全网达成交易的数据记录在分布式账本之中，取代中央服务器的作用，同时也能依赖区块链的非对称加密技术，共识机制，分布式存储降低数据丢失的风险。</p><p>​    在物联网中的电子商务行业，通过智能合约的方式实现交易的自动化，提供可靠性。去中心化的机制也能去除第三方的接入，让交易更为直接，有效率。</p><p>​    此外，物联网时代中的个人隐私安全更需要高度重视，人机交互，物物互联极大提高了暴露个人隐私数据的危险。利用非对称加密技术来对用户信息进行加密是一种有效的办法。</p><p>​    物流方面，结合智能硬件，区块链的可追溯性，实时性安全性也能得到充分发挥。在未来进一步发展的物联网社会，区块链将能不一样的智能体验。</p></li><li><p>医疗健康</p><p>​    区块链+医疗也是一个热门的场景。电子医疗数据的处理是当今区块链研究的一大热点，人们致力于如何将医疗数据安全共享。区块链作为一种多方维护，分布式存储，安全加密的记账技术，在解决医疗行业患者敏感信息共享与保护方面将会是一个很好的创新。借助区块链，我们可以搭建一个医疗信息区块链平台，实现多方数据共享，满足获取患者电子病历等历史数据，并将共享数据用于AI建模，图像检索，健康咨询等等。</p></li><li><p>社会公共服务和基础设施</p><p>​    新一代的社会公共服务，以及新型的基础设施建设，将会是当前区块链行业极为重要的机会，但这一发展道路还很漫长，公共服务和基础设施都需要发展到一定规模才能提供良好的服务。当前区块链发展仍在早期阶段，价值互联网的时代虽然呼之欲出，但实际普及的时间点还很难说。而加大基础设施的建设，提供更多的社会公共服务将会加大这一进程的步伐。</p><p>​    例如在产权登记版权注册方面，利用区块链技术来保障个体或集体的权益不受侵犯。在教育行业，将区块链和学生征信管理，升学就业，学术，资质证明等方面相结合，对教育就业的健康发展具有重要价值。在节约能源方面，区块链也有独特的创新之处，现有专家学者也建议通过发行能源币的方式来鼓励可再生资源的使用。</p><p>总体来说，区块链在很多行业和领域都能有独特的创造性应用，只要是和价值挂钩的信息以及需要建立可靠信用流通性强的场景，都和区块链有天然的亲和性，可以结合在一起发展除新的方式来满足不同行业的需求。我们必须明确，在多元的场景下，多元的区块链实现是有必要的，价值互联网的构建离不开多元场景需求的驱动。</p></li></ol><h3 id="四、-区块链的未来发展方向和趋势"><a href="#四、-区块链的未来发展方向和趋势" class="headerlink" title="四、 区块链的未来发展方向和趋势"></a>四、 区块链的未来发展方向和趋势</h3><p>​    区块链领域已经成为行业创新创业的热土，技术的不断攻坚和创新，将在社会层面上带来一场变革。本文将从技术层面和社会应用层面来简述对区块链未来的理解和看法。技术和社会层面是相互作用的两条发展主线，技术的创新开拓了社会应用的场景和空间，社会应用遇到的痛点和发展需求又是技术创新的一大动力。</p><ol><li><p>技术层面</p><p>1.1 自身技术的迭代更新</p><p>区块链自身的机制仍有不足之处，如共识机制，效率问题，加密技术等等，都等待着专家学者，各行各业的技术人员进行优化改进。结合未来多样化的场景，区块链自身也存在着变革和重构的可能。在未来，单一的公有链，或者联盟链，私有链可能不能满足价值更为多元的传递。为方面数字资产在不同区块链之间的转移，开发安全有效的侧链技术，也是一个研究的热点。而且在加大区块链系统的吞吐量，提高效率方面，高性能的系统方案如分片技术，多通道技术仍在不断探索中。此外，随着区块链技术的发展，谋求一个统一的技术标准对整体发展局面和速度有着极大的作用，如同互联网发展初期基于TCP/IP等传输协议带给互联网信息通信的影响一样。当拟定一个权威标准之后，区块链产业才能有条不紊地前进。</p><p>1.2 与其他技术的融合创新</p><p>跳开自身技术的”瓶颈“，区块链技术和其他高新技术仍存在这融合创新的可能。在大数据方面，可以结合区块链来提升大数据管理和大数据分析的可靠性，分布式存储非对称加密技术提供数据安全和保障，而时间戳技术和不可篡改可以帮助准确的大数据分析，实现精准营销。在人工智能方面，智能硬件搭配智能合约将重塑契约模式，让智能合约更智能，加速价值互联网的到来，实现虚拟价值和实体价值的进一步转化。</p></li><li><p>社会经济层面</p><p>2.1 经济上实现”弯道超车“，打造”可信数字化“实体经济</p><p>区块链作为价值互联网的基础，引领着世界新一轮的技术创新和产业变革。由区块链引发的技术创新和模式创新与实体经济紧密深度的融合在一起，推动社会实体经济的发展，改变产业运作方式，简化业务流程，减少人力物力的同时提高生产效率。从底层架构的区块链到细分场景的应用，从国家战略到企业实践，区块链的应用逐渐从金融领域辐射出去，带动着其他行业的发展和改革。区块链对生产关系的改造力，降低了传统过程中因为信息不对称，信用不可靠而早就的资源浪费。在实体经济中，基于算法搭建的无第三方介入的信用机制更是将数字化提升到一个新的层面，即”可信数字化“，极大地加速了实体经济中资金的流通，为经济上实现”弯道超车“提供了新的动力。</p><p>2.2 完善去中心化基础设施，奠定社会信任基石</p><p>去中心化的技术优势使得未来基于区块链理念的各类去中心化应用，去中心化自治组织，去中心化自治公司，甚至去中心化社会成为可能。不断完善的去中心化基础设施，逐步构建起来的社会信用体系，将为智能社会进一步赋能。就现状而言，智能合约会是未来一个重要的去中心化基础设施，预计之恶能合约会从自动化向智能化方向演变。而现阶段的智能合约本质逻辑是”IF-THEN“类型的条件响应规则，迈向更为智能的”WHAT-IF“推演过程。社会信任体系将从第三方中心的监督机制，转向由共识算法定义的信用体系。避开人性的贪婪，将数据资产交付给理性的机器合约，或许是行之有效的一种方向。</p><p>2.3 区块链驱动的平行社会</p><p>有关学者认为，区块链将引领世界从物理+网络的CPS实际世界走向精神层面的人工世界，形成物理+网络+人工的人-机-物一体化的三元耦合系统，称为社会物理信息系统CPSS。基于CPSS的平行社会已有了雏形，其核心本质特征是虚实互动与平行演化。而区块链就是实现CPSS平行社会的基础架构之一，为分布式社会系统和人工智能系统，物联网系统，提供了行之有效的去中心化数据结构，交互机制和计算范式，为实现平行社会奠定了坚实的数据基础和信用基础。智能合约的可编程性驱动着平行社会的进展，搭载物联网中的智能硬件，将虚拟空间和现实物理世界联通在一起，通过可靠有效的人物交互和智能识别，实现社会管理和社会模式的优化。</p><p>​</p></li></ol><p>区块链的浪潮已经到来，由虚向实，更多区块链项目正在落地，进一步的数字化生活逐渐有了雏形。积极拥抱区块链，把握区块链发展态势，于个人，于企业，于国家，目前看，都是一个正确但要付出很大的努力去摸索的选择。</p><blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 袁勇, 王飞跃. 区块链技术发展现状与展望. 自动化学报, 2016, 42(4): 481-494</p><p>[2] Zibin Zheng, Shaoan Xie, Hong-Ning Dai,Xiangping Chen,Huaimin Wang.Blockchain Challenges and Opportunities: A Survey. Int. J. Web and Grid Services</p><p>[3]袁勇,周涛, 周傲英,段永朝, 王飞跃.区块链技术: 从数据智能到知识自动化.自动化学报,2017,43(9):1485-1490</p><p>[4] 2018 年中国区块链产业白皮书 [Online], available:<a href="http://www.miit.gov.cn/n1146290/n1146402/n1146445/c6180238/part/6180297.pdf" target="_blank" rel="noopener">http://www.miit.gov.cn/n1146290/n1146402/n1146445/c6180238/part/6180297.pdf</a>, 2018-05-20.</p><p>[5]黄俊飞,刘杰. 区块链技术研究综述.  北京邮电大学学报,2018,41(2):1-8</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、-引言&quot;&gt;&lt;a href=&quot;#一、-引言&quot; class=&quot;headerlink&quot; title=&quot;一、 引言&quot;&gt;&lt;/a&gt;一、 引言&lt;/h3&gt;&lt;p&gt;​    区块链技术被认为是继互联网、人工智能以后又一大颠覆式的技术创新，其内在的发展潜力被无数人所追求。以区块链技
      
    
    </summary>
    
    
      <category term="区块链" scheme="https://joshuaqyh.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 基本概念理解</title>
    <link href="https://joshuaqyh.github.io/2018/08/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89--%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>https://joshuaqyh.github.io/2018/08/15/机器学习（一）--概念理解/</id>
    <published>2018-08-14T16:07:06.722Z</published>
    <updated>2019-02-18T14:11:09.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔记基于《机器学习》周志华一书所作的整理。</p></blockquote><blockquote><p>机器学习是什么，如何理解机器学习？</p></blockquote><p>人在认知事物的时候，必须经过一定的经验积累和认识，然后做出相应合理的决策。也就是说人在某一领域上经验的积累会提高人对事物的处理和反应能力。类比到机器学习中，机器学习正是这样一门学科，致力于如何通过计算的手段，利用所谓的经验来让系统具有一定的功能或者改善自己的性能，比如计算机视觉让计算机有“看物体”的能力，并使视觉能力不断增强，自然语言处理让计算机有“翻译，对话”能力，大量的模拟和计算使机器更“懂人话”。</p><p>在计算机系统中，“经验” 通常以“数据”的方式存在。机器学习所要研究的主要内容就是，关于在计算机上从数据中产生一个模型的算法，即“学习算法”。基于提供的经验和数据我们对系统进行提炼和优化模型，当系统接收到相应输入时，根据已有的经验去进行响应，做出符合“智能”定义的行为。机器学习，主要是数据+算法。通常情况下，数据的采集和处理显得更为重要，一般来说数据集越大，学习能力越强，但也意味着更长的训练时间和修正优化时间。</p><blockquote><p>机器学习需要的数据基础</p></blockquote><p>要进行机器学习，先要有数据。比如判定西瓜的好坏，需要先给出许多西瓜的数据例子：（色泽=青绿，根蒂=硬挺 … )[]，（色泽=白色，根蒂=蜷缩）[ ]等等，这些数据记录的集合称为<strong>数据集</strong>，每一条记录都是<strong>样本</strong>或者<strong>示例</strong>，每一条记录里有对象的<strong>属性或特征。</strong> 属性张开的空间称为<strong>属性空间</strong>，样本张开的空间称为<strong>样本空间</strong> 。在数学上，我们使用线性代数中的向量来表示物体的空间，空间的维度由我们数据记录中的属性个数决定，比如西瓜有色泽，根蒂，响声三个属性，那么我们以这三个属性张开的空间就可以表示所有的西瓜，每一个西瓜都能在这个空间中找到自己的坐标位置。由于空间中的每一个点对应一个坐标向量，因此我们也把一个示例称为一个<strong>特征向量</strong>。</p><p>一般地，令D = {x1， x2..， Xm } 表示包含m 个示例的数据集，每个<br>示例由d 个属性描述(例如上面的西瓜数据使用了3 个属性)，则每个示例<br>Xi = (Xi1; Xi2; . . . ; Xid) 是d 维样本空间X 中的一个向量， Xi ε X ， 其中Xij 是xi在第j 个属性上的取值(例如上述第3 个西瓜在第2 个属性上的值是”硬<br>挺” ), d 称为样本xi的”维数” (dimensionality)。</p><blockquote><p>机器学习的过程</p></blockquote><p>从数据中学的模型的过程称为“学习”或者“训练”。整个过程通过执行某些算法来完成（我们将了解到十大算法CNN，RNN），训练过程 中使用的数据称为<strong>“训练数据”</strong>， 每一个样本称为<strong>“训练样本”</strong>，训练样本的集合称为<strong>“训练集”</strong>。 学得模型对应了关于数据的某种潜在规律，亦称<strong>假设（后续会根据数据的训练做不断地修正）</strong>, 机器学习本身就是一个不断逼近事实真相的过程。</p><p><strong>模型有时被称为“学习器”，可看作学习算法在给定数据和参数空间上的实例化</strong></p><blockquote><p>机器学习所能完成的事和划分</p></blockquote><ul><li><p>预测</p><p>要建立一个可预测的模型，我们需要获得训练样本的结果信息，通常称为标记。一个样本具有标记时可成为<strong>样例</strong>。 标记集合也成为<strong>标记空间或者输出空间</strong>。比如要判断西瓜的好坏时，我们除了给出西瓜色泽，敲声等属性时，还要给出在这些属性下瓜的好坏，即赋予每一个样本标记 。根据预测对象的不同时，我们定义了不同的学习任务。</p><ul><li>分类：当预测的对象是离散值（例如好瓜，坏瓜），此类学习任务称为分类。</li><li>回归：当预测的对象是连续值（例如西瓜的成熟度），此类学习任务称为回归。</li></ul><p>当预测的类别只有两个时，称为“二分类”任务，涉及多个时，称为“多分类”任务。</p><p>一般地，预测任务是希望通过对训练集{(X1’ Y1) , (X2 , Y2) ,…, (Xm, Ym)} 进行学习，建立一个从输入空间X 到输出空间y 的映射f: X 叶y. 对二分类任务，通常令Y = {-1 ，+1} 或{0 ， l};  对多分类任务， IYI &gt;2; 对回归任务， Y= R，R为实数集.</p></li></ul><p>学得模型之后，使用其进行预测的过程称为“测试”。被预测的样本称为测试样本“。也就是说学习的过程是建立一个准确率更高的关于输入到输入的映射关系。</p><ul><li><p>训练数据处理：聚类clustering</p><p>将训练集中的西瓜分成若干组，每一组称为一个簇，这些自动形成的簇可以对应一些潜在的概念划分，比如西瓜中按照色泽划分为”深色瓜“和”浅色瓜“。 这样有助于我们了解数据内在的规律，更为深入地分析数据建立基础。<strong>但是在聚类学习中，我们事先并不知道西瓜是根据哪些属性特征来划分为簇的，在学习过程中使用的训练样本通常不拥有标记信息。</strong></p><p>​</p></li></ul><p>根据训练样本是否拥有标记信息，学习任务大致可以划分为两类：<strong>监督学习</strong>和<strong>无监督学习</strong>。没有标记的当然是无监督学习，这意味着在无监督学习中没有标准答案给机器，只能依靠机器分析内部的数据特征来做响应的判断，而有标记的学习，则可以理解为在得到标准答案后，机器的一次次自我修正，以期下次遇到相似的问题时，能得到和标准答案更为接近的答案。显然，分类和回归属于监督学习，聚类属于无监督学习。</p><p><strong>泛化：</strong> 机器学习不仅在已有的训练样本上表现出高准确率，在新的未尝试过的样本上也能体现较高的准确率。显然强泛化的模型，更适用于整个样本空间，虽然样只是空间中一个很小的采样。 </p><blockquote><p>假设空间：由对象所可能存在的不同属性值所张成的空间</p></blockquote><ul><li>归纳： 从特殊到一般的“泛化”过程，而从“样例”中学习显然是一个归纳的过程，所以也称为“归纳学习”。<ul><li>狭义归纳：要求从训练数据集中获得概念，所以也称<strong>概念学习</strong>或者<strong>概念形成</strong>。 概念学习中最简单的就是布尔概念学习，即让机器判断对或错，黑或白，类似预测中的二分类学习。</li></ul></li><li>演绎：从一般到特殊的“特化”过程，从基础原理推演到具体的情况。在数学公理系统中，基于公理和推理推导出与之相恰的定理。</li></ul><p>模拟搜索西瓜问题的假设空间有多种做法，例如<strong>从顶向下，从一般到特殊，从底向上，从特殊到一般</strong>。 搜索过程遇到和训练集的“正确答案”不一致时，需要删除或者调整参数使之逼近真相。</p><p>在现实问题中，存在着很大的假设空间。但学习过程是基于有限的样本训练集来进行的，可能有多个假设和训练集一致。即存在一个与训练集一致的假设集合，称为“版本空间”。不同训练集对应不同的版本空间，版本空间属于假设空间的一部分。</p><blockquote><p>归纳偏好</p></blockquote><p>版本空间的问题：如果有三个与训练集一致的假设，但在不同模型的情况下，面临新的样本，却会产生不同的输出判断。也就是说不同的模型具有不同的偏好，对某种类型的假设的偏好。</p><p><strong>在训练集之外的样本误差的计算方法</strong> P8~9</p><p>总误差和实际学习算法无关，任意两个学习算法的总误差相同。 也就是说学习算法所具有的不同训练集外误差的期望性相同。这就是“没有免费午餐定理” NFL。定理的前提：我们希望学习的真实目标函数f均匀分布，实际并非如此。该定理揭示的是，脱离具体问题，空泛谈“什么学习算法”更好是毫无意义的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;笔记基于《机器学习》周志华一书所作的整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;机器学习是什么，如何理解机器学习？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人在认知事物的时候，必须经过一定的经验积累和认识，然后做出
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 | 前向和反向传播Python代码实现</title>
    <link href="https://joshuaqyh.github.io/2018/07/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%89%8D%E5%90%91%E5%92%8C%E6%96%B9%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    <id>https://joshuaqyh.github.io/2018/07/30/神经网络-前向和方向传播/</id>
    <published>2018-07-30T05:58:03.051Z</published>
    <updated>2019-03-08T06:31:30.476Z</updated>
    
    <content type="html"><![CDATA[<p>Just show the code.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">神经网络模型简介：</span></span><br><span class="line"><span class="string">单层神经元（感知机）：</span></span><br><span class="line"><span class="string">1. 输入向量Wi： 多个同维向量，其中包括多个输入节点和标注为+1的偏置节点</span></span><br><span class="line"><span class="string">2. 输入权值j1： 每个输入向量（除去偏置节点）在输入神经元时都需要乘上一个相应的权值</span></span><br><span class="line"><span class="string">3. 输入值 ΣWiji + b：   为每个输入节点乘上相应的权值然后求和再加上偏置节点</span></span><br><span class="line"><span class="string">4. 激活函数： 通常使用sigmoid函数，作为激活函数，有单极性和双极性之分</span></span><br><span class="line"><span class="string">5. 输出值：   激活函数的返回值，为神经元网络的输出或者为下一个神经元的输入</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多层神经元模型：</span></span><br><span class="line"><span class="string">为单层神经元的级联，每一层的结构包括多个神经元，接受上一层神经元的输入</span></span><br><span class="line"><span class="string">产生下一神经元的输出，不同层的神经元之间有相应的权值。</span></span><br><span class="line"><span class="string">* 层次结构：输入层+隐藏层+输出层</span></span><br><span class="line"><span class="string">1. 输入层：包含多个输入节点和一个标注为+1的偏置节点，偏置节点不接受输入。</span></span><br><span class="line"><span class="string">2. 隐藏层：为多个神经元级联而成，每一层数目与输入层数目一致</span></span><br><span class="line"><span class="string">3. 输出层：只有一个神经元结构，最后一层的隐藏层的作为输出层的输入，输出整个神经网络的结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">前向传播与后向（反向）传播</span></span><br><span class="line"><span class="string">--- 前向传播对应预测（分类），后向传播对应训练</span></span><br><span class="line"><span class="string">* 前向传播：就是给定模型参数即输入层的输入和偏置节点，逐一计算各层的输出值，直到最后输出神经网络的结果</span></span><br><span class="line"><span class="string">* 后向传播：</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单极性激活函数，优点连续可导</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid1</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">:sigmoid单极性函数 1/(1+e^-x)</span></span><br><span class="line"><span class="string">:param: x， 函数自变量</span></span><br><span class="line"><span class="string">:return: sigmoid函数值</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span> + math.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单极性激活函数的导数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dsigmoid1</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">:sigmoid 单极性函数的导数</span></span><br><span class="line"><span class="string">:param  y 函数自变量:</span></span><br><span class="line"><span class="string">:return 函数 运算结果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> y*(<span class="number">1</span>-y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#双极性激活函数 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">：sigmoid双极性函数 tanh （z）</span></span><br><span class="line"><span class="string">: param x,函数自变量 </span></span><br><span class="line"><span class="string">: return 函数因变量</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> math.tanh(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#双性极性激活函数的导数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dsigmoid2</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">: sigmoid双极性函数的导数</span></span><br><span class="line"><span class="string">：param x,函数自变量</span></span><br><span class="line"><span class="string">：return 函数因变量</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span> - y ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 神经网络前向传播实现方法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">前向传播算法，神经网络的输出值即预测值可作为后向传播误差的计算</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runNN</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">：前向传播进行分类</span></span><br><span class="line"><span class="string">：param: inputs-输入参数</span></span><br><span class="line"><span class="string">：return: 所属类别</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 输入的数目必须为每一层规定节点数-1，除去偏置节点，不接受输入</span></span><br><span class="line"><span class="keyword">if</span> len(inputs) != self.ni - <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"incorrect number of inputs"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入向量映射到神经元的输入节点值</span></span><br><span class="line"><span class="comment"># ai - 输入层</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(self.ni - <span class="number">1</span>):</span><br><span class="line">self.ai[i] = inputs[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入层到隐藏层，隐藏层的运算</span></span><br><span class="line"><span class="comment"># ah - 隐藏层的输出值</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(self.nh):</span><br><span class="line">sum = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(self.ni):</span><br><span class="line">    sum += (self.ai[i] * self.wi[i][j]) <span class="comment"># wi为输入层到隐藏层的权值 权值求和 </span></span><br><span class="line">self.ah[j] = sigmoid(sum)  <span class="comment">#输入激活函数，产生下一神经元的输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#隐藏层到输出层，输出层运算</span></span><br><span class="line"><span class="comment"># ao - 最终输出结果</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(self.no):</span><br><span class="line">sum = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(self.nh):</span><br><span class="line">    sum += (self.ah[j] * self.wo[j][k]) <span class="comment"># wo为隐藏层到输出层的权值</span></span><br><span class="line">self.ao[k] = sigmoid(sum) </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self.ao</span><br><span class="line"></span><br><span class="line"> <span class="string">"""</span></span><br><span class="line"><span class="string">后向传播</span></span><br><span class="line"><span class="string">指的是在训练的时候，根据最终输出的误差（预测值-目标值的平方和/2）</span></span><br><span class="line"><span class="string"> 来调整倒数第二层、倒数第三层……第一层的参数的过程。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">主要有三种调整</span></span><br><span class="line"><span class="string">1. 输出层权值的调整</span></span><br><span class="line"><span class="string">2. 隐藏层权值的调整</span></span><br><span class="line"><span class="string">3. 偏置节点的调整</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">算法步骤</span></span><br><span class="line"><span class="string">1. 随机初始化参数（指权值和偏置节点），对输入利用前向传播计算输出</span></span><br><span class="line"><span class="string">2. 对输出和隐藏节点进行调整，计算delta。公式比较难写。。</span></span><br><span class="line"><span class="string">3. 计算梯度可定义学习率影响训练速度，并更新权值参数偏置参数。</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">backPropagate</span><span class="params">(self, targets, N, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        后向传播算法</span></span><br><span class="line"><span class="string">        :param targets: 实例的类别 </span></span><br><span class="line"><span class="string">        :param N: 本次学习率</span></span><br><span class="line"><span class="string">        :param M: 上次学习率</span></span><br><span class="line"><span class="string">        :return: 最终的误差平方和的一半</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># http://www.youtube.com/watch?v=aVId8KMsdUU&amp;feature=BFa&amp;list=LLldMCkmXl4j9_v0HeKdNcRA</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 计算输出层 deltas</span></span><br><span class="line">        <span class="comment"># dE/dw[j][k] = (t[k] - ao[k]) * s'( SUM( w[j][k]*ah[j] ) ) * ah[j]</span></span><br><span class="line">        output_deltas = [<span class="number">0.0</span>] * self.no</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(self.no):</span><br><span class="line">            error = targets[k] - self.ao[k]</span><br><span class="line">            output_deltas[k] = error * dsigmoid(self.ao[k])</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 更新输出层权值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.nh):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(self.no):</span><br><span class="line">                <span class="comment"># output_deltas[k] * self.ah[j] 才是 dError/dweight[j][k]</span></span><br><span class="line">                change = output_deltas[k] * self.ah[j]</span><br><span class="line">                self.wo[j][k] += N * change + M * self.co[j][k]</span><br><span class="line">                self.co[j][k] = change</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 计算隐藏层 deltas</span></span><br><span class="line">        hidden_deltas = [<span class="number">0.0</span>] * self.nh</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.nh):</span><br><span class="line">            error = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(self.no):</span><br><span class="line">                error += output_deltas[k] * self.wo[j][k]</span><br><span class="line">            hidden_deltas[j] = error * dsigmoid(self.ah[j])</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 更新输入层权值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.ni):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.nh):</span><br><span class="line">                change = hidden_deltas[j] * self.ai[i]</span><br><span class="line">                <span class="comment"># print 'activation',self.ai[i],'synapse',i,j,'change',change</span></span><br><span class="line">                self.wi[i][j] += N * change + M * self.ci[i][j]</span><br><span class="line">                self.ci[i][j] = change</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 计算误差平方和</span></span><br><span class="line">        <span class="comment"># 1/2 是为了好看，**2 是平方</span></span><br><span class="line">        error = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(targets)):</span><br><span class="line">            error = <span class="number">0.5</span> * (targets[k] - self.ao[k]) ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> error</span><br></pre></td></tr></table></figure><p> 来源来自大牛 <a href="http://www.hankcs.com/ml/back-propagation-neural-network.html" target="_blank" rel="noopener">http://www.hankcs.com/ml/back-propagation-neural-network.html</a>  thx！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Just show the code.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="人工智能" scheme="https://joshuaqyh.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="python" scheme="https://joshuaqyh.github.io/tags/python/"/>
    
      <category term="机器学习" scheme="https://joshuaqyh.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>认识经济学原理</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E8%AE%A4%E8%AF%86%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/认识经济学原理/</id>
    <published>2018-07-27T15:28:32.813Z</published>
    <updated>2018-11-28T07:16:14.810Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-643020.jpg" alt=""></p><h1 id="经济学学习"><a href="#经济学学习" class="headerlink" title="经济学学习"></a>经济学学习</h1><p>##十大曼昆经济学原理</p><p>###原理一：人们面临交替关系</p><p>典型的交替关系就是 “大炮和黄油”的交替，花更多钱在大炮研发上就注定了减少黄油生产的投入。</p><p>这其中 涉及到一个资源配置做出决策的问题。</p><p>认识到人们面临交替关系本身并没有告诉我们，人们将会或应该作出什么决策。一<br>个学生不应该仅仅由于要增加用于学习经济学的时间而放弃心理学的学习。社会不应该<br>仅仅由于环境控制降低了我们的物质生活水平而不再保护环境。也不应该仅仅由于帮助<br>穷人扭曲了工作激励而忽视了他们。然而，认识到生活中的交替关系是重要的，因为人<br>们只有了解他们可以得到的选择，才能作出良好的决策。</p><h3 id="原理二：某种东西的成本是为了得到它而放弃的东西"><a href="#原理二：某种东西的成本是为了得到它而放弃的东西" class="headerlink" title="原理二：某种东西的成本是为了得到它而放弃的东西"></a>原理二：某种东西的成本是为了得到它而放弃的东西</h3><p>许多行为选择的成本有时不是那么明显，收益也分为长期和短期，时间成本 ，金钱成本，人力成本都是需要考量的。</p><h3 id="原理三：-理性人考虑边际量"><a href="#原理三：-理性人考虑边际量" class="headerlink" title="原理三： 理性人考虑边际量"></a>原理三： 理性人考虑边际量</h3><p>做决策考虑行为所花的额外成本和额外收益，通过比较这种边际收益和边际成本来，评价比较合理。</p><h3 id="原理四：人们会对激励做出反应"><a href="#原理四：人们会对激励做出反应" class="headerlink" title="原理四：人们会对激励做出反应"></a>原理四：人们会对激励做出反应</h3><p>激励在决定行为中的中心作用是重要的。激励在贸易中可能体现为商品的成本或者收益。</p><hr><p><em>列出并简要解释个人作出决策的四个原理</em></p><hr><h3 id="原理五：-贸易能使每个人状况更好"><a href="#原理五：-贸易能使每个人状况更好" class="headerlink" title="原理五： 贸易能使每个人状况更好"></a>原理五： 贸易能使每个人状况更好</h3><p>贸易竞争能使国家和个人在相互交易的过程中收益。国与国之间的贸易未必就是像体育比赛一样一方赢，一方输，事实恰好相反，两国之间贸易可以使每个国家状况更好。</p><h3 id="原理六：市场通常是组织经济活动的一种好方法"><a href="#原理六：市场通常是组织经济活动的一种好方法" class="headerlink" title="原理六：市场通常是组织经济活动的一种好方法"></a>原理六：市场通常是组织经济活动的一种好方法</h3><p>经济学家亚当·斯密（Adam Smith）在他 1776 年的著作《国富论》中提出了全部<br>经济学中最有名的观察结果：家庭和企业在市场上相互交易，他们仿佛被一只“看不见<br>的手”所指引，引起了合意的市场结果。本书的目的之一就是要解释这只看不见的手如<br>何施展它的魔力。当你学习经济学时，你将会知道，价格就是看不见的手用来指引经济<br>活动的工具。价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本</p><p>关于看不见的手在指引经济活动中的技巧有一个重要推论：当政府阻止价格根据供<br>求自发地调整时，它就限制了看不见的手协调组成经济的千百万家庭和企业的能力。这<br>个推论解释了为什么税收对资源配置有不利的影响：税收扭曲了价格，从而扭曲了家庭<br>和企业的决策。这个推论还解释了租金控制这类直接控制价格的政策所引起的更大伤<br>害。而且，这个推论也解释了共产主义的失败。在共产主义国家中，价格不是在市场上<br>决定的，而是由中央计划者指定。这些计划者缺乏那种在价格对市场力量自由地作出反<br>应时反映在价格中的信息。中央计划者之所以失败，是因为它们在管理经济时把市场上<br>那只看不见的手缚起来了。</p><p>###原理七：政府有时可以改善市场结果</p><p>政府干预经济的原因：促进效率和促进平等。政策的目标不是做大经济蛋糕二十改变蛋糕的分割。</p><p>​    看不见的手通常会使市场有效地配置资源。但是，由于各种原因，有时看不见的手<br>不起作用。经济学家用市场失灵这个词来指市场本身不能有效配置资源的情况。<br>市场失灵的一个可能原因是外部性。外部性是一个人的行动对旁观者福利的影响。<br>污染是一个典型的例子。如果一家化工厂并不承担它排放烟尘的全部成本，它就会大量<br>排放。在这种情况下，政府就可以通过环境保护来增加经济福利。<br>    市场失灵的另一个可能原因是市场势力。市场势力是指一个人（或一小群人）不适<br>当地影响市场价格的能力。例如，假设镇里的每个人都需要水，但只有一口井。这口井<br>的所有者对水的销售就有市场势力——在这种情况下，它是一个垄断者。这口井的所有<br>者并不受残酷竞争的限制，而正常情况下看不见的手正是以这种竞争来制约个人的私<br>利。你将会知道，在这种情况下，规定垄断者收取的价格有可能提高经济效率。</p><hr><p><em>列出并简要解释关于经济相互交易的三个原理</em></p><hr><h3 id="原理八：-一国的生活水平取决于它生产物品与劳务的能力"><a href="#原理八：-一国的生活水平取决于它生产物品与劳务的能力" class="headerlink" title="原理八： 一国的生活水平取决于它生产物品与劳务的能力"></a>原理八： 一国的生活水平取决于它生产物品与劳务的能力</h3><p>​    用什么来解释各国和不同时期中生活水平的巨大差别呢？答案之简单出人意料之<br>外。几乎所有生活水平的变动都可以归因于各国生产率的差别——这就是一个工人一小<br>时所生产的物品与劳务量的差别。在那些每单位时间工人能生产大量物品与劳务的国<br>家，大多数人享有高生活水平；在那些工人生产率低的国家，大多数人必须忍受贫困的<br>生活。同样，一国的生产率增长率决定了平均收入增长率。</p><p>​    生产率和生活水平之间的基本关系是简单的，但它的意义是深远的。如果生产率是<br>生活水平的首要决定因素，那么，其他解释的重要性就应该是次要的。例如，有人想把<br>上个世纪美国工人生活水平的提高归功于工会或最低工资法。但美国工人的真正英雄行<br>为是他们提高了生产率。另一个例子是，一些评论家声称，美国近年来收入增长放慢是<br>由于日本和其他国家日益激烈的竞争。但真正的敌人不是来自国外的竞争，而是美国生<br>产率增长的放慢。</p><p>​    生产率与生活水平之间的关系对公共政策也有深远的含义。在考虑任何一项政策如<br>何影响生活水平时，关键问题是政策如何影响我们生产物品与劳务的能力。为了提高生<br>活水平，决策者需要通过让工人受到良好的教育，拥有生产物品与劳务需要的工具，以<br>及得到获取最好技术的机会。</p><h3 id="原理九：-当政府发行了过多的货币之后，物价上涨"><a href="#原理九：-当政府发行了过多的货币之后，物价上涨" class="headerlink" title="原理九： 当政府发行了过多的货币之后，物价上涨"></a>原理九： 当政府发行了过多的货币之后，物价上涨</h3><p>货币发行量超量，会导致通货膨胀</p><h3 id="原理十：社会面临通货膨胀与失业之间的短期交替关系"><a href="#原理十：社会面临通货膨胀与失业之间的短期交替关系" class="headerlink" title="原理十：社会面临通货膨胀与失业之间的短期交替关系"></a>原理十：社会面临通货膨胀与失业之间的短期交替关系</h3><p>交替关系称为菲利普斯曲线。</p><p>由于价格是粘性的，各种政府政策都具有不同于长期效应的短期效应。例如，当政<br>府减少货币量时，它就减少了人们支出的数量。较低的支出与居高不下的价格结合在一<br>起就减少了企业销售的物品与劳务量。销售量减少又引起企业解雇工人。因此，对价格<br>的变动作出完全的调整之前，货币量减少就暂时增加了失业。</p><hr><p><em>列出并简要解释描述整体经济如何运行的三个原理。</em></p><hr><p>币值稳定–交换的媒介</p><p>币值不稳定–投机的工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-643020.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;经济学学习&quot;&gt;&lt;a href=&quot;#经济学学习&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="经济学" scheme="https://joshuaqyh.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>湫嘤记-壹</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E6%B9%AB%E5%98%A4%E8%AE%B0-%E5%A3%B9/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/湫嘤记-壹/</id>
    <published>2018-07-27T15:28:32.802Z</published>
    <updated>2018-07-27T15:33:40.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“我意识到在这个地球上，除了你，没有人能够远程控制我的感情。”</p><p>​                                ——记生命中一段绵长的奇迹。</p></blockquote><p><img src="http://p8ekwajjb.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180519114654.jpg" alt=""></p><p>一开始并不是想要讲一个宏大而浪漫的故事。没得讲，也不敢想。那天的白衣和相机，那天的短暂相遇，成了我最意想不到的一场奇迹。</p><h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1><p>十二月份的广州已经有些寒意，凉风把天一点一点吹高，很高，高到目光都不知道多久才能到达流云之上。</p><p>匆匆忙忙出门的路人A，对这次任务并没有一丝的兴趣。高中母校的校庆将至，每个人都要拍一段对母校的祝福。跟摄影师师兄约好的时间，就是今天了。</p><p>要在陌生人面前，对着他手中的相机镜头，挤出商业性微笑，说出一串感性的祝福语吗？开什么玩笑啊……难为情。社交恐惧症，真的很难为情。</p><p>万一是个很猥琐的师兄怎么办？万一很不好说话怎么办？就算不差，也实在是太抗拒陌生人了。路人A无奈地想着。</p><p>啊，他来了。</p><p>“你是XX吗？我就是师兄XXX。”</p><p>什么？师兄……原来是这样子的吗？</p><p>路人A不太记得接下来说了些什么。唯一记忆犹新的，是那个将所有的焦虑和压抑都扫到流云之上去的微笑。</p><p>是光，冬日里不被云朵遮蔽的阳光，照在瞌睡的猫咪身上，绒毛的轮廓是一圈柔光如万千新生命跃动。</p><p>是歌，舒缓得如细水轻盈环绕，又是一股上扬的力量把你托起，升到可以离开所有世俗冷漠的高度。</p><p>路人A一直在小小的世界里搜集的，那种不经意间撞击心灵的感动，不经意间绚烂开放的美，似乎又落脚了。</p><p>没有架子，没有距离感，一直都那么清爽地咧嘴笑着，弯着湖水般的明亮双眼看着A，给她看相机里的画面。</p><p>不值一提的个人片段拍摄结束，故事按理来说到这里也结束了。</p><p>某一天朋友B在吃饭时向路人A提起，“XXX师兄真的是个超级温柔的人啊，从来不发脾气，什么都乐意帮忙，又那么有能力，你不知道，我们这次的策划啊，师兄他……”</p><p>路人A不知道策划的事。她只知道，这大概就是那一类自己很向往但是从来不可能成为的人吧。一直站在中心，那么耀眼，给所有的人善意，到处奉献自己的温柔，向暖，造暖。</p><p>她是个人主义者，不喜集群，闭门造车，琴棋书画只为取悦自己，纷繁复杂能不理则一概不理，从来高傲，却又自卑，无心也无力维持巨大的社交网络，不够有趣便拒之门外，融入世界需要莫大努力，打开心门需要莫大缘分。</p><p>可能是孤独，也有人说是独特。一个人流浪久了，自己也不知道是什么了。但是路人A，也是向暖的，也是想要有变化的，也是想靠近光的。</p><h1 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h1><p>路人A咬咬牙，主动在微信上找了师兄。字字斟酌，反反复复，写学术论文般修改底稿，删除，空格，删除，空格，终于回车。</p><p>“师兄真的很厉害呢。“</p><p>“我想我没办法成为集体喜欢的那种人，但是我真的很欣赏师兄。”</p><p>师兄并没有因为生分而怠于回复，而是真诚地聊了很久，像阔别的旧友。每字每句的温度，恰如哥哥轻拍肩的安心感，暖流注入了A的心房。</p><p>“被集体喜欢很难，而且也未必就是真的喜欢……个人或者集体主义都好，都是中性词。”</p><p>她并没有被冷漠对待，A的心里有小小的欢喜，受宠若惊。</p><p>转念一想，欢喜什么？也许，所谓地暖，就是这样的吧。他生性使然，我怎可自作多情。</p><p>12月份也就这么悠悠晃过去了。没有其他值得提的故事。</p><p>但师兄在A的心中不经意撒下了几叶茶叶，不知不觉已被如获至宝地泡了一壶普洱，愈发醇厚，愈发袭人，空水共氤氲，只是，不敢细细品。</p><p>但A想要把这份勇敢继续下去。从小到大，A的行动力一直不强，很多事情都在安排好了的轨道上，只要往前走，不出意外就能得到。但A知道，十八岁以后，这种安稳已经消失了，从今往后的路不再属于被动前进的人。情感，也是如此。</p><p>1月1日，心血来潮的A在跨年的零点送出了一张小小的明信片。</p><p>“师兄，隐约觉得在师兄身上看到了我缺失的东西——那种冬日阳光般的温柔和热情，愿意付出自己，从不吝啬自己的微笑。愿你继续用那份细腻和温柔治愈世界，时光也一定会眷顾可爱的你……”</p><p>他说，哇，好喜欢！谢谢你。你也要继续简单快乐下去呀。</p><p>他还说，XX，你短头发很温雅的呢。</p><p>被夸了！</p><p>屏幕那边的A在捂嘴笑。温雅……是这样吗？就算是商业性夸奖，也是饮饱喝足的幸福了。</p><p>但是，这个时期的A清楚——或者说，在强迫自己用底线思维去说服自己搞清楚，她并不是真的喜欢上了师兄，她只是向暖，仅此而已，而也足够。应当知足，因为贪婪的悬崖一跃下即万劫不复。 </p><p>也许跨年夜的小小感恩是某种契机吧，一月份的路人A和她阳光一样的师兄开始慢慢变熟，慢慢发现这样那样的共同点，慢慢酝酿这样那样的话题。</p><p>A依然很谨慎，她不会每天都去叨扰师兄，她小心翼翼地选择着合适的时间、合适的频率、合适的话题，像雏鸟的羽毛，时不时轻挠师兄某根神经。</p><h1 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h1><p>有一天，A偶然听到了一首歌，如空谷幽兰，却又仿佛能最深入人心中的每个见不到阳光的缝隙和角落，如天鹅绒的触感紧紧包围，所有的不安都暂时消失在悠悠回荡的歌声中，天地和胸膛，融为一体。如果有翅膀，此时的蓝天，一定最适合飞翔……</p><p>A马上想到的，是分享给师兄。A突然想到那句话：</p><p>“那天我在街上看到一棵形状奇怪的榕树，第一反应竟是拍下来给你看。那时候我就知道，我大事不好了……”</p><p>这一刻她似乎明白了这种感觉。</p><p>A写了一段小小的乐评，连同歌曲一起发给了师兄。</p><p>22点50分，没有反应。</p><p>23点，没有反应。</p><p>23点30分，没有反应。</p><p>0点，    没有反应。</p><p>1点，    ……</p><p>A控制不住自己每过几分钟就看一眼手机，但终究是失望。她把头埋在枕头里，一遍又一遍地提醒自己该冷静一点了。也许只是一阵风吧，吹过了便过，他的好，只是一种逢场的应变，一种高超的社交技巧，一种对任何人都适用的套路，他是一个善于交际的人，给每个人阳光，可是管不了你绚烂不绚烂。</p><p>其实A还是不愿意相信的。师兄不是这样的人。就在两种想法的打架中，她终于撑不住，睡着了。</p><p>第二天醒来第一件事仍是抓起手机打开微信。</p><p>她看到了师兄回复的消息！一条，两条，三条，四条……很多，很长，很用心。</p><p>“细听这首歌，仿似一个歌者在悬崖上低吟浅唱，下视平野，远眺海洋，天空和海洋汇聚成地平线，歌声悠悠的回荡在天地间，还有绕耳的回响……淡淡的孤独与忧伤，却给人从中站起来的力量……”</p><p>原来一直都熬夜的师兄，刚好在那天养生了一回，早早入睡。A的消息，师兄是凌晨醒来才看到的。事情就是这么巧合。</p><p>师兄的那段文字，跟A的感受完美契合，甚至，A想不到更好的语言去表达出来的部分，师兄表达出来了。能够去感知虚无缥缈的东西，并用文字去表达出来的人，是拥有一颗诗意的心的，是有情怀有温度的人，A始终这么相信着。她再次确信了，师兄的内心，有星辰大海，值得她去探索。</p><p>就这么一来二去，A朦胧地感觉到，她和师兄，站在某一座吊桥的两端，相望着对方，想跨出一步，却因为不清楚绳的承重而担忧，是否会因彼此走近而使桥断裂，跌入深渊。</p><p>可是A很快就明白，脚底下的并不是深谷。</p><h1 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h1><p>某一天，朋友C说，你怎么好像变温柔了。</p><p>是的，她不再那么棱角分明，不再那么冷若冰山，偶尔微笑，偶尔体贴，会去想环路上的猫咪是否有个可以安稳睡觉的家，会去想雨夜执勤的保安身上会不会太单薄，家里是否牵挂……难道这种改变毫无理由？她才突然悟到，自己好像被感染了。</p><p>水愈发接近沸腾，躁动的气泡随心跳的频率不断上升，茶香再也无处可逃，飘进了彼此的心里。</p><blockquote><p>然后，他说，你以后就不用再拿我当师兄了，就叫我的名字就好了。</p><p>然后，他说，能和你倾心交流真的很开心，我认识的人太多，但这样的人真的不多。</p><p>然后，他说，晚上走环路的时候如果一个人害怕，也可以叫上我的。</p><p>然后，他说，明天一起复习吗？</p></blockquote><p>那天晚上，A到凌晨三点半才入睡。翻来覆去的，都是一个月前师兄那模糊的身影。再次见面，他会不会对我印象减分？我长得足够好看吗？我的谈吐足够大方吗？我有很多话题跟他讲吗？不断地在心里一遍遍打草稿，想流程，仿佛迎接一场重要的面试。</p><p>令A怎么也没有想到的是，接下来的两天，她几乎都和师兄待在一起。</p><p>也许，如果第一次见面那天晚上，A没有跟师兄说：“今天真的很开心，谢谢你”，师兄也就不会说“明天还继续吗？”，故事可能也就没有接下来的进展了。</p><p>等到很后来才知道，必然，是心的互相吸引；偶然，是彼此一个小小的表示主动的动作，必然和偶然的叠加，便是难以置信的天时地利人和。</p><p>再然后，在人烟稀少的环路，在微风轻拂的中心湖，在碧绿的草地上，在有阳光的树林里，两个人天南地北地聊着，漫无目的，只顾相互接近。彼此的人设一次又一次地崩塌、修缮、重建，越来越真实，越来越完整。</p><p>他们见面越来越频繁。而路人A的心里已经发生了翻天覆地的变化。但A还是不敢多想，她怕自己的细腻和敏感会给自己招来祸事——自作多情，终归破灭。</p><blockquote><p>你很耀眼 你很充实 像一阵风 似乎可以吹动所有的安分和不安分</p><p>但我不知道你会不会眷顾曾经经过的草地</p><p>你的世界像一副完整的拼图 那我应该从哪里进去 </p></blockquote><p>她强行关闭自己少女情窦初开的窗户，若无其事地继续相处。她仍坚守着她的底线思维，奢望太多是要吃亏的，即使感受到了某种电波，也不能得意忘形。</p><p>这样做朋友也非常幸福不是吗？</p><p><strong>果然，低潮来了。</strong></p><p>考试周，整整四天彼此都没有联系。四天，四天里他也许一刻都没有想起过A的事吧。果然还是普通的朋友吧？想得起来了就联系，想不起来就淡如水。A很难过。</p><p>倒数第二天，考完试出来，疲累的A一个人听着歌在内环上慢悠悠地走着，看着轻云追着夕阳跑，看着粉色的云块被红色的云块吞噬，紫色的云块和黄色的云块缠绵。</p><p>好想跟他说话。好想好想。不怕丢脸了，不想矜持了，不怕造成困扰了。久旱何时逢甘霖。</p><p>A终于忍不住拿出手机。聊了那么一两句，A还在码着字，师兄突然说：“先这样吧，我同学催我去打游戏了……”</p><p>A默默把字一个一个删掉，默默地继续走。那天，A不知道怎么的迷迷糊糊走上了外环，在太阳落山之后迷路了，长长的环路逐渐融化在漆黑夜色中，她无奈地打开导航，在狂风中骑车，骑了很久很久，慌乱之中总算赶回了学校。</p><p>晚上，A因为白天的事有点失落，而最后一天又是两门最艰难的专业课，万分疲劳的A扔掉厚重的课本，插上耳机，开始宣泄自己的情感。手指在键盘上飞舞，诗行像疾速前行的火车一样，呼啸着穿过自己的内心。她疯狂地把自己的感情全都宣泄在这密密麻麻的文字里，只怕手速赶不上思维的激流，只怕语言传达不了内心的狂热。</p><p>手机屏幕猝不及防地亮了。是那熟悉的头像。茫茫海雾中航行的船只看到了信号塔的灯光。</p><p>“在复习吗？要不要出来走走？”看一看时刻，十一点半。</p><p>A叫了一声，差点从床上掉下来。她飞快地冲出去，所有的烦乱在这短短的信息里烟消云散。</p><p>“深夜的环路，雾气朦胧的恍若仙境，好棒啊。”</p><p>“呃，什么雾……这是丁达尔效应。”</p><p>“哇，你能不能诗意一点？现在这个氛围，一定要这么理性嘛？诶，工科男的思维啊……”A已经可以放肆一点地打趣了。</p><p>然后文艺到骨子里的文科生A和理性至上的工科生在凌晨寒冷的环路上傻笑了起来。</p><p>回想这几天的事，A突然有点谴责自己。我是不是对师兄太不信任了？事到如今，似乎没有必要再因为一些小事而去怀疑师兄的真诚，没必要不断地去拷问这段朦胧的感情。</p><p>水深火热的考试周终于过去，A第一次主动约了师兄走环路。</p><p>A想杀一个措手不及。“我问你一个问题。你会不会烦我呀？”</p><p>“为什么突然这么说啊？你突然这样，弄得我好不知所措。”</p><p>“如果我频繁地找你会打扰到你，那你可以直接说的……我不想过分地影响你的生活。”</p><p>“我，我不烦你啊……我这个人的性格，不会轻易觉得别人烦的。”<br>这句话让A倒吸一口凉气，她觉得师兄的回答烂透了。A直接就说了，原来你不烦我，是因为你性格的原因，而不是因为我的某些特质或者吸引你的地方啊？</p><p>“不，不是这样的……哎呀，怎么说，我……我感觉我最近像个智障了。不知道怎么表达，可是，可是我真的没有烦你啊！”</p><p>看到师兄慌乱的样子，A窃喜。她相信的，她相信师兄没有觉得她困扰。但是，她就是想逗一逗师兄。</p><p>“你的回答让我伤心了。”</p><p>“你的提问也让我伤心了。”</p><p>“为什么？”</p><p>“居然问我有没有烦你，我肯定伤心啊。”</p><p>哦？似乎师兄的情商，其实一点都不低。</p><h1 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h1><p>次日，师兄约了A一起去看电影。</p><p>从学校到巨幕影院，有将近一个小时的遥远路程。可是A却觉得这简直是一种馈赠，与他一起走，即使是走在永无止境的潘洛斯阶梯，也没有问题。</p><p>晚风清凉，A突然说：“你唱歌给我听好不好？”</p><p>羞涩了一下之后，师兄唱了很多。唱了少女的祈祷，唱了童话镇，唱了怯。</p><blockquote><p>“祈求天地放过一双恋人，怕发生的永远别发生。从来没顺利遇上好景降临，如何能重拾信心……”</p></blockquote><p>A若有所思。</p><p>每次过红绿灯的时候，其实A都在观察师兄的侧脸。这侧脸真的很好看，长长的睫毛，高挺的鼻梁，还有那如水的目光，融化了春天的雪，深藏了如烟的柳絮。</p><p>聊着聊着，他们聊到了有点沉重的话题。A在社团里一直有些自卑，不起眼又被孤立，如今走到退社的境地。A垂下了头，难为情地苦笑。</p><p>一直盯着地面的A，突然感受到一个温暖的手掌，轻轻地拍了拍自己的后脑勺，轻得像羽毛掉落，掉落在A的内心，然后，烟火盛放。</p><p>“不要自卑啦，你很好的，我只希望你好好的呀……”</p><p>A假装镇定自若，心如止水，继续说着什么话，但大脑里早已不知道自己在说什么。</p><p>看电影的过程中，师兄一直把头侧向A的这一边。只要A扶一下眼镜或吸一下鼻子，师兄就警觉地看过来。A抽泣了，他都知道。他会温柔地拍一拍A的额头，用温柔得像哄婴儿的声音说“没事没事，没事哈……”</p><p>看的是印度电影《神秘巨星》。电影中尹希娅的小男友，可爱又浪漫、情商极高的钦腾，一举一动都触动情窦初开少女的心弦。对比了一下有些木讷、不解风情的师兄，A凑近他，悄声说了一句“你看人家，情商多高。学习一下？”</p><p>“啊……怎么办……呜……”师兄一副慌忙又委屈的模样，让A忍俊不禁。</p><p>看完电影的A，感动得怎么也止不住眼泪。“现在不要看我，我妆都花了。”“花了也非常好看。”</p><p>她心里在想着，如果此刻如此脆弱的我，可以得到师兄一个拥抱，哪怕片刻永恒……</p><p>回去的路上，A的腿很酸痛。她开玩笑般地说，师兄可以背我吗？</p><p>“可以啊！上来吧。”</p><p>“不不不……不用了。”A还是没有勇气接受。</p><p>但是A也有自己的小心机。她有意无意地就提起自己走不动了，她多希望，师兄能够扶着她走路。她想要接触，想要接触师兄温暖的手，想要感受到那熟悉的温度，想要靠在他结实的肩膀上看着疏星点点。</p><p>结果并没有。也许师兄也在小心翼翼地着棋吧，生怕下错一步，便不复从前。</p><p>一路无言，只有脚步声和影子，在路灯下演着默剧，揉碎夜的寒冷。</p><p>“你，现在在想什么呀？”师兄打破沉默。</p><p>完了，被将一军了。向来善于表达、自诩情商高的A突然舌头打结，捉摸不透这句话的意味，也想不到很好的回答。</p><p>“那，那你在想什么？”</p><p>“你猜。”</p><p>“我不猜。”</p><p>就这样，两个人各怀心事地继续走着，走回了各自的宿舍。</p><p>A不想要再静默下去，她把考试周的时候写的诗送给了师兄，希望迟钝的他能够在字里行间领会到哪怕一丝期许。</p><blockquote><p>“我习惯了沉默 习惯了自己的高傲 习惯了比孤独更深一层的独特</p><p>习惯了窝在自己的舒适地带 也习惯了冷漠和稀零</p><p>也许我很不起眼 但也希望有人能够注意到我</p><p>我其实也不甘只是这样 也想有改变 想跟着你一起成长 想要被你所带动 所感染 </p><p>也想向你尽可能展示我的光怪陆离 想让你感到至少是不无聊的</p><p>在兵荒马乱的世界 唱一首有点奇怪的歌 至少是让人值得注意的</p><p>很难喜欢君子之交淡如水这句话  只是对淡去的感情无法挽回的一种无奈叹惜</p><p>改变不了的事情 万用的道理去解释 解脱自己或者自我麻痹</p><p>如果可以像浪花一样热烈 像喷泉一样灵动 为什么要选择淡如水 </p><p>这样想的我很自私 我知道 每个人都有自己的生活</p><p>但是</p><p>如果可以用一点点的自私去换一点点的改变 </p><p>用一点点的改变去一点点走进别人的生活</p><p>一点点地让自己变得美好 </p><p>一点点地为别人变得美好而献出自己微弱的光</p><p>该如何感动得泪湿眼眶</p><p>我像橡皮糖很黏 因为无法自我消化 所以渴望别人帮忙咀嚼我的情怀 快乐和烦恼</p><p>我总是无法独立 千头万绪像蒲公英一样飞舞 去寻找值得落下的地方</p><p>去看看——别人的房前屋后 别人的花开花落 </p><p>别人那些在凌晨降临的软肋和在清晨复苏的坚定 那些写在眼里的信念和藏在心里的叹息</p><p>别人那些孤独 冷了深夜铁青的窗沿</p><p>别人那些温柔 爬上老家瓦顶的月光</p><p>我喜欢仰望有趣的灵魂中深藏的星辰大海 拥抱春暖花开</p><p>而你碰巧就在这里 </p><p>那就让相同的彼此懂得 不同的便互相成就</p><p>我希望的</p><p>能有心照不宣 像足迹融化在雪地里 也有口口声声 是光点斑驳了夏季</p><p>顺着一架很长很长的梯子 从今天爬到明天 后天 坐在未来的屋顶</p><p>一起看湛蓝的天空如何变成金色的夕阳 泼墨的流云如何变成厚涂的油画</p><p>编织一个很长很长的故事 也从今天写到明天 后天 写在未来的结尾</p><p>金色的夕阳又唤醒了金色的朝阳 一轮又一轮 </p><p>但我们永远年轻”</p></blockquote><p>但是师兄似乎并不解其中味，他说，诗意的灵魂不拘一格。</p><p>A想要的不是赞赏呀。</p><h1 id="六、"><a href="#六、" class="headerlink" title="六、"></a>六、</h1><p>接下来就是寒假了。A独自坐车回家，师兄还要留在学校几天。</p><p>见不到面的第一天，A有点骚动。深夜，A还是不愿意道晚安。“去睡吧，醒来再聊呀。”</p><p>一个小小的约定，给了A对明天的十足期待。睡吧，一早醒来，说不定还会有思念已久的粿汁可以吃。</p><p>见不到面的第二天，一早醒来，没有早餐。也没有师兄的消息。中午，没有动静。下午，没有动静。晚上，没有动静。</p><p>23点，仍然没有动静。</p><p>A无精打采地趴在床上，发了一个“你不要我了”的表情。</p><p>他很快就回复了。“没有呀！”他说今天很忙。</p><p>那就原谅你吧。</p><p>“抗日神剧好雷啊。为什么有枪不用，用刀……还有好多病句，什么几十位烈士壮烈牺牲……”</p><p>“哎，你看这个就该隐藏智商。它的市场瞄准的又不是我们。你呀，智商该上线的时候不上线，在这时候就上线……”</p><p>A继续聊。突然间，一个巨大方块唐突地跳了出来，密密麻麻的文字霸占了屏幕。</p><blockquote><p>“有好多话没有说呢，无法准确传达我自己，从何说起呢，试着说一下。</p></blockquote><p>总觉得和你有了默契，你是明白我的，我的快乐与忧虑也很想翻译成言语与你分享，除去忧伤，带给你一束光。</p><p>我一开始答应和你走在一起不是因为我要和你在一起，而是你能明白我……</p><p>我特别享受能与你走在夜道中，晚风拂过脸庞，你我倾谈。你伤心需要陪伴的时候，有时说不出来安慰的话，我心头总是一顿软绵绵的无力感，我描述不出那种具体的感觉，但我还是知道的——那叫做喜欢。”</p><p>A的提醒，让师兄“智商终于上线了”</p><p>这就是传说中的……告白吗？</p><blockquote><p>“有好多话没有说呢，无法准确传达我自己，从何说起呢，试着说一下。</p><p>总觉得和你有了默契，你是明白我的，我的快乐与忧虑也很想翻译成言语与你分享，除去忧伤，带给你一束光。</p><p>我一开始答应和你走在一起不是因为我要和你在一起，而是你能明白我……</p><p>我特别享受能与你走在夜道中，晚风拂过脸庞，你我倾谈。你伤心需要陪伴的时候，有时说不出来安慰的话，我心头总是一顿软绵绵的无力感，我描述不出那种具体的感觉，但我还是知道的——那叫做喜欢。”</p></blockquote><p>A还没反应过来，还没意识到这意味着什么，眼泪就先下来了。</p><p>泪水一片一片模糊视线，一个一个的方块字却越来越清晰，仿佛复刻进心里，默念便能倒背如流。</p><p>她不知道，其实在她按捺不住去找师兄聊的这段时间里，师兄已经在开始准备，开始酝酿，开始勇敢地迈出一步。</p><p>“ 我想说，我在2017的尾巴突然变得很幸运……就像我给你的诗写的，你碰巧就在这里，我就那么幸运遇到了你。</p><p>我想要的，有人能跟我一起看夕阳和朝霞。我也愿意去仰望他的天空，他的孤独和快乐。</p><p>跟你一起的日子，我希望内环有八万里。”</p><p>“怪我，在你走的前一天晚上没牵起你的手。让你一个人坐车回去，我很不自在。”</p><p>“那这个锅，你可要好好背着。”</p><p>“下次见面，我就要抱抱你……”</p><p>路人A终于可以卸掉她路人的外衣，就像尹希娅卸掉自己黑色的罩袍。她终于可以说，她不再是路人A，不再是他世界里微不足道的路人，不再是孤独地站在世界边缘的流浪诗人，她是嘤嘤，世界上独一无二的嘤嘤。</p><p>他也不再是触不可及的完美师兄，他也有脆弱的一面， 傻气的一面，浪漫的一面，可爱的一面，他是奕浩，世界上独一无二的奕浩。</p><h1 id="七、"><a href="#七、" class="headerlink" title="七、"></a>七、</h1><p>某天晚上，嘤嘤和奕浩在打电话。</p><p>他说，“我就想这样子跟你浪费时光，什么也不做，跟你说话。”</p><p>她说，“浪费这个词不是很好，改一下。”</p><p>怎么改？</p><p>……想了很久。</p><p>嘤嘤在奕浩的电脑上敲下了：孕育时光。</p><p>然后嘤嘤又想了想，继续敲下了：奕起变老。</p><p>然后奕浩移动光标，在最前面敲下了：颖你而在。</p><p>因你而在，孕育时光，一起变老。</p><p>颖你而在，孕育时光，奕起变老。</p><p>嘤嘤又想起了约会时的对话：</p><blockquote><p> 我们就这样到处走，没有目的地，哪里都是过程。终点就是你，终点就是我。</p></blockquote><p><strong>我们的故事才刚刚开始，并且永远不会结束。</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“我意识到在这个地球上，除了你，没有人能够远程控制我的感情。”&lt;/p&gt;
&lt;p&gt;​                                ——记生命中一段绵长的奇迹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http:/
      
    
    </summary>
    
    
      <category term="love" scheme="https://joshuaqyh.github.io/tags/love/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 | 内存管理</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/内存管理--操作系统第七章/</id>
    <published>2018-07-27T15:28:32.788Z</published>
    <updated>2019-03-27T13:51:36.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指令和数据绑定到内存地址的条件"><a href="#指令和数据绑定到内存地址的条件" class="headerlink" title="指令和数据绑定到内存地址的条件"></a>指令和数据绑定到内存地址的条件</h3><ul><li>编译时— 若知道进程在内存里的驻留地址，直接生成 绝对代码</li><li>加载时— 若不知道进程的驻留地址，那么生成可重定位代码</li><li>执行时— 如果进程需要进行内存段之间的移动，那么需要延迟到执行时才进行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p8ekwajjb.bkt.clouddn.com/1527035732685.png" alt="52703573268" title="">                </div>                <div class="image-caption">52703573268</div>            </figure><h3 id="逻辑地址空间和物理地址空间"><a href="#逻辑地址空间和物理地址空间" class="headerlink" title="逻辑地址空间和物理地址空间"></a>逻辑地址空间和物理地址空间</h3><p>CPU 所生成的地址通常称为逻辑地址( logical address) ，而内存单元所看到的地址(I!IJ<br>加载到内存地址寄存器(memory-address register) 中的地址)通常称为物理地址(physical<br>address) 。</p><p>编译和加载时的地址绑定方法生成相同的逻辑地址和物理地址。但是， 执行时的地址<br>绑定方案导致不同的逻辑地址和物理地址。对于这种情况， 通常称逻辑地址为虚拟地址<br>(virtual address)。在本书中， 对逻辑地址和虚拟地址不作区分。由程序所生成的所有逻辑<br>地址的集合称为逻辑地址空间(logical address space), 与这些逻辑地址相对应的所有物理<br>地址的集合称为物理地址空间(physical address space)。因此， 对千执行时地址绑定方案，<br>逻辑地址空间与物理地址空间是不同的。<br>运行时从虚拟地址到物理地址的映射是由被称为内存管理单元(memory-management<br>unit, MMU)的硬件设备来完成的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p8ekwajjb.bkt.clouddn.com/1527036351509.png" alt="52703635150" title="">                </div>                <div class="image-caption">52703635150</div>            </figure><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接的概念与动态加载相似。只是这里不是将加载延迟到运行时，而<br>是将链接延迟到运行时</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p8ekwajjb.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180523090208.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>迄今为止所讨论的是一个进程的整个程序和数据必须处于物理内存中，以便执行。因<br>此进程的大小受物理内存大小的限制。为了获得更好的内存空间使用率，可以使用动态加<br>载(dynamic loading) 。采用动态加载时，一个子程序只有在调用时才被加载。所有子程序<br>都以可重定位的形式保存在磁盘上。主程序装入内存并执行。当一个子程序需要调用另一<br>个子程序时，调用子程序首先检查另一个子程序是否己加载。如果没有，可重定位的链接<br>程序将用来加载所需要的子程序，并更新程序的地址表以反映这→变化。接着，控制传递<br>给新加载的子程序。<br>动态加载的优点是不用的子程序决不会被加载。如果大多数代码需要用来处理异常情<br>况，如错误处理，那么这种方法特别有用。对于这种情况，虽然总体上程序比较大，但是<br>所使用的部分(即加载的部分)可能小很多。<br>动态加载不需要操作系统提供特别的支持。利用这种方法来设计程序主要是用户的责<br>任。不过，操作系统可以帮助程序员，如提供子程序库以实现动态加载。</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>进程需要在内存中以便执行。不过，进程可以暂时从内存中交换(swap) 到备份存储<br>(backing store) 上，当需要再次执行时再调回到内存中。（例子：轮转法CPU调度）</p><p>如何进程换出roll out进程换入 roll in，操作系统较少采用。</p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><p>内存通常分为两个区域:一个用于驻留操作系统，另一个用于用户进程。操作系统可<br>以位于低内存，也可位于高内存。影响这一决定的主要因素是中断向量的位置。由于中断<br>向量通常位于低内存，因此程序员通常将操作系统也放在低内存。在本书中，只讨论操作<br>系统位于低内存的情况。真他情况的讨论类似。<br>通常需要将多个进程同时放在内存中，因此需要考虑如何为输入队列中需要调入内存<br>的进程分配内存空间。采用连续内存分配( contiguous memo可allocation) 时，每个进程位<br>于一个连续的内存区域。</p><h4 id="内存映射与保护问题"><a href="#内存映射与保护问题" class="headerlink" title="内存映射与保护问题"></a>内存映射与保护问题</h4><p>通过采用重定位寄存器(已在8.1.3 小节讨论)和界限地址寄存器(己在8. 1.1小节讨论)，可以实现这种保护。重定位寄存器含有最小的物理地址值;界限地址寄存器含有逻辑地址的范围值(例如，重定位=100040 ，界限=74600) 。有了重定位寄存器和界限地址寄存器，每个逻辑地址必须小于界限地址寄存器。MMU 动’;ti:ltfp将逻辑地址加上重定位寄存器的值后映射成物理地址。映射后的物理地址再送交内存单元</p><h4 id="内存分配方法"><a href="#内存分配方法" class="headerlink" title="内存分配方法"></a>内存分配方法</h4><p>最为简单的内存分配方法之一就是将内存分为多个固定大小的分区(partition) 。每个分区只能容纳一个进程。因此，多道程序的程度会受分区数所限制。如果使用这种多分区方法(multiple-partition method) ，当一个分区空闲时，可以从输入队列中选择一个进程，以调入到空闲分区。当进程终止时，其分区可以被其他进程所使用。<br>这种方法最初为IBM 08/360 操作系统(称为MFT) 所使用，现在已不再使用。下面所描<br>述的方法是固定分区方案的推广(称为MV凹，它主要用于批处理环境。这里所描述的许<br>多思想也可用于采用纯分段内存管理的分时操作系统。</p><p>在可变分区(variable-partition) 方案里，操作系统有一个表，用于记录哪些内存可用<br>和哪些内存已被占用。-开始，所有内存都可用于用户进程，因此可以作为一大块可用内<br>存，称为孔(hole) 。当有新进程需要内存时，为该进程查找足够大的孔。如果找到，可以<br>从该孔为该进程分配所需的内存，孔内未分配的内存可以下次再用。<br>随着进程进入系统，它们将被加入到输入队列。操作系统根据所有进程的内存需要和<br>现有可用内存情况来决定哪些进程可分配内存。当进程分配到空间时，它就装入内存，并<br>开始竞争CPU 。当进程终It时，它将释放内存，该内存可以被操作系统分配给输入队列中<br>的其他进程。<br>在任意时候，再→组可用孔(块)大小列表和输入队列。操作系统根据调度算法来对<br>输入队列进行排序。内存不断地分配给进程，直到下-个进程的内存需求不能满足为止，<br>这时没有足够大的可用孔来装入进程。操作系统可以等到有足够大的空间，或者往下扫描<br>输入队列以确定是否有其他内存需求较小的进程可以被满足。<br>通常，→组不同大小的孔分散在内存中。当新进程需要内存时，系统为该进程查找足<br>够大的孔。如果孔太大，那么就分为两块:一块分配给新进程，另一块还回到孔集合。当<br>进程终止时，它将释放其内存，该内存将还给孔集合。如果新孔与其他孔相邻，那么将这<br>些孔合并成大孔。这时，系统可以检查是否杳进程在等待内存~间，新合井的内存空间是<br>否满足等待进程。<br>这种方法是通用动态存储分配问题的二种情况(根据一组空闲孔来分配大小为n 的请<br>求)。这个问题有许多解决方法。从-组可用孔中选择-个空闲孔的最为常用方法有首次适<br>应( first岳1)、最佳适应(best-fiO 、最差适应(worst-fit) 。<br>·首次适应:分配第一小足够大的孔。查找可以从头开始，也可以从<strong>上次首次适应结束时开始</strong>(避开碎片）。一旦找到足够大的空闲孔，就可以停止。<br>·最佳适应:分配最小的足够大的孔。必须查找整个列表，除非列表按大小排序。这<br>种方法可以产生最小剩余孔。<br>·最差适应:分配最大孔。同样，必须查找整个列表，除非列表按大小排序。这种<br>方法可以产生最大剩余孔，该孔可能比最佳适应方法产生的较小剩余孔更为有用。<br>模拟结果显示首次适应和最佳适应方法在执行时间和利用空间方面都好于最差适应<br>方法。首次适应和最佳适应方法在利用空间方面难分伯仲，但是首次适应方法要更快些。</p><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>首次适应方法和最佳适应方法算法都有外部碎片问题(external 企agmentation) 0 随着<br>进程装入和移出内存，空闲内存空间被分为小片段。当所有总的可用内存之和可以满足请<br>求，但并不连续时，这就出现了外部碎片问题，该问题可能很严重。在最坏情况下，每两<br>个进程之间就有空闲块(或浪费〉。如果这些内存是一整块，那么就可以再运行多个进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;指令和数据绑定到内存地址的条件&quot;&gt;&lt;a href=&quot;#指令和数据绑定到内存地址的条件&quot; class=&quot;headerlink&quot; title=&quot;指令和数据绑定到内存地址的条件&quot;&gt;&lt;/a&gt;指令和数据绑定到内存地址的条件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;编译时— 若知道进程在内
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://joshuaqyh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计组 | 流水线技术简介</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/流水线技术简介/</id>
    <published>2018-07-27T15:28:32.768Z</published>
    <updated>2019-05-16T14:04:13.623Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h2><h3 id="流水线基础概念"><a href="#流水线基础概念" class="headerlink" title="流水线基础概念"></a>流水线基础概念</h3><p>​    • 指令的执行过程是，对每一条指令做取指令，分析指令，执行指令。</p><p>​    • 取指–移码–执行–访存–写回</p><p>​    • 流水执行是，取指令时间上一条指令的执行阶段，执行指令阶段可能是下一条指令的取指令阶段。</p><p>​    • 抽象概念：把一个重复过程分为若干个子过程，每个子部件由专门的部件实现。多个处理过程在时间上错开错开，依次通过各个部件。</p><p>​    • 流水的段：每个子过程。</p><p>​    • 流水的深度：子过程的个数。例如： 入-取指令-指令译码-执行-存结果-出–》浮点加法：入-求阶差-对阶-尾数相加-规格化-出</p><p>​    • 流水时间是每一个段时间的总和，需要注意的是通过一个段的时间最长的段为流水线设计的瓶颈。流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流。时间长的段将成为流水线的瓶颈</p><p>​    • 时空图：从时间和空间两个方面来描述指令流水执行</p><p>​    • 流水线的性能指标–吞吐率。即单位时间内完成任务的数量或者输出结果的数       量。</p><p>​    </p><p>​    </p><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>​    • 数据相关</p><p>​    • 名相关</p><p>​        ○ 输出相关–写写操作</p><p>​        ○ 反相关–先读后写，读的名和写的名一致</p><p>​    • 控制相关</p><p>​    </p><p>​    每条指令访问读写的寄存器称为名</p><p>​    输出相关–写写操作，两条指令的</p><p>​    反相关—先读后写，读的名和写的名一致</p><p>​    换名技术</p><p>​    </p><h3 id="流水线冒险（冲突）"><a href="#流水线冒险（冲突）" class="headerlink" title="流水线冒险（冲突）"></a>流水线冒险（冲突）</h3><p>​    1. 结构冒险–硬件不支持多条指令在同一时间周期执行–重复，细分部件</p><p>​    2. 数据冒险–一条指令需要等待另外一条指令完成而造成流水线暂停。（所以设计的段的时候时间应尽量保持一致–前推旁路–写后读冲突–在写入i之前，j先读取，会造成读取错误。</p><p>​    为避免数据等待的问题，在每个段之间设计了一个缓冲寄存器（也叫锁存器）</p><p>​    3.控制冒险 （分支冒险）–决策依赖于另外一条指令的结果，但其他指令正在执行当中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;流水线技术&quot;&gt;&lt;a href=&quot;#流水线技术&quot; class=&quot;headerlink&quot; title=&quot;流水线技术&quot;&gt;&lt;/a&gt;流水线技术&lt;/h2&gt;&lt;h3 id=&quot;流水线基础概念&quot;&gt;&lt;a href=&quot;#流水线基础概念&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="计组" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据库 | 关系数据库设计理论简介</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/关系数据库设计理论/</id>
    <published>2018-07-27T15:28:32.735Z</published>
    <updated>2019-03-27T13:50:02.241Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul><li>X→Y，表示Y依赖于X；</li><li>X→Y，且Y→X不成立，Y→Z，则X→Z，表示Z传递依赖于X。</li></ul><h4 id="函数依赖性质"><a href="#函数依赖性质" class="headerlink" title="函数依赖性质"></a>函数依赖性质</h4><ul><li>自反性</li><li>传递性</li><li>增广性  A → C 可以推出 AB → BC</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\ADMINI~1\AppData\Local\Temp\1526869989262.png" alt="52686998926" title="">                </div>                <div class="image-caption">52686998926</div>            </figure><h4 id="函数依赖的种类"><a href="#函数依赖的种类" class="headerlink" title="函数依赖的种类"></a>函数依赖的种类</h4><p>（<strong>完全函数依赖</strong>：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y非函数依赖于X的子集，则称Y完全函数依赖于X。X  f &gt;Y）—&gt; Y依赖于X,但未必都依赖X的子集。</p><p>（<strong>部分函数依赖</strong>：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y函数依赖于X的子集）</p><p>（<strong>函数依赖</strong>：某个属性集决定另一个属性集时，例如学生学号属性集Sno决定学生姓名属性集Sname，称Sname函数依赖于Sname ）</p><p>（<strong>平凡函数依赖</strong>：Y函数依赖于X,并且Y包含于X，例如（Sno）-&gt;(Sno)、（Sno、Sname）-&gt;（Sno））</p><p>（<strong>非平凡函数依赖</strong>：Y函数依赖于X,并且Y不包含于X,例如(Sno,Sname）-&gt;（Ssex））</p><h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><p>候选键： 能够唯一表示一个元组，且不含多属性<br>超键： 是指能够唯一表示一个元组的属性集<br>主属性：表示候选键中的属性<br>非主属性：不包含在主键中的属性</p><p><strong>判断主键的方法</strong> ：若属性集为{ A , B, C}，A+ = ABC。 则A为主键。（属性闭包判断法） </p><h3 id="范式-Normal-Forms"><a href="#范式-Normal-Forms" class="headerlink" title="范式 Normal Forms"></a>范式 Normal Forms</h3><p>（1）第一范式1NF：关系中的所以属性值都是不可分割的原子值；<br>（2）第二范式2NF：如果关系是1NF，且每个非主属性都完全依赖于候选键；<br>（3）第三范式3NF：如果关系是1NF，且每个非主属性都不传递依赖于候选键；<br>（4）<strong>鲍依斯-科得(巴斯)范式</strong>BCNF范式：如果关系是1NF，且每个属性都不传递依赖于候选键。</p><p>BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\ADMINI~1\AppData\Local\Temp\1526870129743.png" alt="52687012974" title="">                </div>                <div class="image-caption">52687012974</div>            </figure><h3 id="属性闭包"><a href="#属性闭包" class="headerlink" title="属性闭包"></a>属性闭包</h3><p>定义：闭包就是由一个属性直接或间接推导出的所有属性的集合。</p><p>表示：B的闭包用B+表示。</p><p>计算：关系R的属性集X的闭包的步骤如下： </p><ol><li>设最终将成为闭包的属性集是Y，把Y初始化为X；<br> .  检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将                 其加入到Y中； </li><li>重复第二步，直到没有属性可以添加到属性集Y中为止。 最后得到的Y就是X＋</li></ol><p>举例：</p><p>例1： R = {A,B,C,D,E}</p><p>​         F = {B→CD， D→E, B→A, E→C， AD→B }</p><p>​             则 B+ = B ;    B+ = BCD;  B+ = BCDA； B+ = BCDAE。（推导过程是属性依赖传递的过程。</p><p>​            所以最终B+ 包含了R中所有属性。 故<strong>B is a key for R。</strong></p><p>例2： 有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)闭包。 </p><p>(1) 令X={AE}，X(0)=AE</p><p>(2)在F中寻找尚未使用过的左边是AE的子集的函数依赖，结果是: A→D， E→C；所以 X(1)=X(0)DC=ACDE，     显然 X(1)≠X(0).</p><p>(3) 在F中寻找尚未使用过的左边是ACDE的子集的函数依赖， 结果是: CD→I；所以 X(2)=X(1)I=ACDEI。虽然X（2）≠X(1)，但F中寻找尚未使用过函数依赖的左边已经没有X（2）的子集，所以不必再计算下去，即(AE)+=ACDEI。</p><p>例3：f={a-&gt;b，b-&gt;c，a-&gt;d，e-&gt;f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}</p><h3 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h3><p>关系模式分解必须遵守两个准则<br>       (1)无损联接性：信息不失真（不增减信息）。<br>       (2)函数依赖保持性：不破坏属性间存在的依赖关系</p><h4 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h4><p>R的无损分解为X Y，那么 x∩y →x  或者 x∩y → y.   </p><p>####Dependency Preserving Decomposition 依赖保持分解</p><p> 关系模式R&lt;U,F&gt;的分解是指R为它的一组子集<br>          ρ={R1&lt;U1,F1&gt;, R2&lt;U2,F2&gt;,…, Rk&lt;Uk,Fk&gt;}所代替的过程。<br>          其中U=U1∪U2∪…∪k ,并且没有Ui≤Uj(表Ui包含于Uj，1≤i,j≤k),<br>          Fi是F在Ui上的投影，即Fi={X→Y∈F+∧XY≤Ui}(表XY包含于Ui）。</p><p>描述：R被分解为 i个关系子集 Ri。Fi为每个子集的函数依赖投影。</p><p>计算函数依赖fi保持的方法就是：Fi∪Fj 推出 fi成立，其中Fi Fj的计算从自身属性和原来函数依赖推导得来。</p><p>模式分解是独立保持的条件就是，所有函数依赖Fi的投影的并集的闭包 = F的闭包</p><p>思考： 可否是Fi的闭包的并集 = F的闭包？</p><p>回答：不可以，因为每个子集的函数依赖Fi，可能产生跨子集的函数依赖，先求Fi的闭包会产生不完整的闭包关系。</p><h4 id="BCNF分解"><a href="#BCNF分解" class="headerlink" title="BCNF分解"></a>BCNF分解</h4><p>BCNF的要求：函数依赖要么平凡，函数依赖的左侧是超键</p><p>如果X→Y违反BCNF, 分解R 为R-Y 和XY。</p><h4 id="第三范式分解"><a href="#第三范式分解" class="headerlink" title="第三范式分解"></a>第三范式分解</h4><p>第三范式的条件：</p><ol><li>平凡依赖</li><li>x 属于超键</li><li>A属于候选键</li></ol><p>部分依赖</p><p>传递依赖</p><p>最小覆盖模型— 简化函数依赖集</p><h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h3><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>在连接运算当中，一种最常用的连接是自然连接。如果关系R与S具有相同的属性组B，且该属性组的值相等时的连接称为自然连接，结果关系的属性集合为<strong>R的属性并上S减去属性B的属性</strong>集合。</p><p>参考的文章</p><p><a href="https://www.cnblogs.com/bewolf/p/4445027.html" target="_blank" rel="noopener">函数依赖集闭包、属性集闭包、超键、候选键和最小函数依赖集</a></p><p><a href="https://www.cnblogs.com/makeupforever-carrie/p/6837325.html" target="_blank" rel="noopener">四种范式的实例</a></p><p><a href="https://blog.csdn.net/fanfan4569/article/details/53910670" target="_blank" rel="noopener">函数依赖不懂看这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;函数依赖&quot;&gt;&lt;a href=&quot;#函数依赖&quot; class=&quot;headerlink&quot; title=&quot;函数依赖&quot;&gt;&lt;/a&gt;函数依赖&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;X→Y，表示Y依赖于X；&lt;/li&gt;
&lt;li&gt;X→Y，且Y→X不成立，Y→Z，则X→Z，
      
    
    </summary>
    
    
      <category term="数据库理论" scheme="https://joshuaqyh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 | 死锁问题</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/读者写者问题/</id>
    <published>2018-07-27T15:28:32.721Z</published>
    <updated>2019-03-27T13:49:15.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>–写者对数据库有排他的访问</p><ul><li>第一读者-写者问题</li></ul><p>若有写者正在访问对象，那么其他读者需要保持等待</p><ul><li>第二读者-写者问题</li></ul><p>如果有写者等待访问对象，那么不会有新读者开始读操作</p><p>以上问题经常出现在数据库的访问读写问题之中。</p><h3 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h3><p>导致出现哲学家饥饿的情况。</p><h3 id="死锁的特征"><a href="#死锁的特征" class="headerlink" title="死锁的特征"></a>死锁的特征</h3><h4 id="！死锁的必要条件："><a href="#！死锁的必要条件：" class="headerlink" title="！死锁的必要条件："></a>！死锁的必要条件：</h4><ol><li>互斥</li><li>占有并等待</li><li>非抢占</li><li>循环等待</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p8ekwajjb.bkt.clouddn.com/%E6%AD%BB%E9%94%81%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6.png" alt="52643424888" title="">                </div>                <div class="image-caption">52643424888</div>            </figure><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>节点集可分为两类：一类是系统活动进程集合（节点连接的线代表申请边，表示申请创建进程），一类是系统所有资源类型的集合（节点连接的线代表分配边，表示请求分配资源）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p8ekwajjb.bkt.clouddn.com/1526434313403.png" alt="52643431340" title="">                </div>                <div class="image-caption">52643431340</div>            </figure><h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><ul><li>使用协议预防或者避免死锁</li><li>允许系统进入死锁状态，然后检测恢复它</li><li>忽视死锁，认为死锁不可能存在。。。（unix windows多采用这种办法，，比较常用</li><li>​</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>只要保证死锁的四个必要条件有一个不成立，就可以起到死锁预防的效果。</p><ol><li>否定互斥条件：这仅仅适用于共享资源。非共享资源必须有互斥条件</li><li>占有并等待：两种协议</li><li>非抢占：协议：一个进程占有资源并申请另外一个无法分配的资源，那么原来的资源将会隐式释放</li><li>循环等待：对所有资源类型进行编号排序，按编号递增顺序来申请资源。</li></ol><p>死锁预防的缺点：低设备利用率和 低吞吐率</p><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>死锁避免的方法：获得申请资源时进程的附加信息：意思是获得资源的先验信息，根据信息来判断是否分配资源或让其等待。</p><p>死锁避免的两个方法：</p><ol><li>安全状态：存在一个安全序列，给进程分配资源，使得永远不会出现死锁，系统状态就是安全的。</li><li>资源分配图：</li><li>银行家算法 ！！！</li></ol><h4 id="！！！死锁避免-银行家算法（重点）"><a href="#！！！死锁避免-银行家算法（重点）" class="headerlink" title="！！！死锁避免-银行家算法（重点）"></a>！！！死锁避免-银行家算法（重点）</h4><p>数据结构</p><ul><li>Allocation：当前进程各种资源分配的的实例数量—-  二维矩阵 — 行代表不同进程，列代表资源</li><li>Max: 当前进程各类型资源的最大需求   —————— 二维矩阵— 同1</li><li>Need: 当前资源仍需要的各种类型资源——————- 二维矩阵— 同1</li><li>Avoidable: 当前系统能再提供的资源———————-  一维数组– 列代表资源类型，只有一行</li></ul><ol><li><p>安全性算法：一个Finish[m]数组判断进程是否完成，  每满足一个进程资源请求设为Finish[i] = true, 最后检测所有Finish是否都为false, 如果不是则不安全。</p></li><li><p>资源请求算法：每个进程有一个请求向量，系统假设满足该请求，然后计算分配后的结果是否安全，不安全则不分配。</p><p><strong>两者最大缺点</strong>：无法提前预知进程对资源的最大需求。</p></li></ol><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>系统需要提供：</p><ol><li>检测出现了死锁的算法</li><li>如何从死锁中恢复过来</li></ol><h4 id="检测算法"><a href="#检测算法" class="headerlink" title="检测算法"></a>检测算法</h4><ul><li>对于资源只有单个实例</li><li>对于资源有两个实例与银行家的安全算法不同的是最大需求矩阵变化为请求矩阵。其他基本一致 。得到一个安全序列的时候则认为系统安全。</li></ul><p>时间复杂度 O （m*n^2)</p><h4 id="恢复算法"><a href="#恢复算法" class="headerlink" title="恢复算法"></a>恢复算法</h4><p>取消死锁的方法</p><ul><li><p>终止一个或者某些进程  </p><ul><li><p>终止所有死锁进程—- 不大好</p></li><li><p>一次终止一个进程直到死锁取消。部分终止需要进程终止进程的选择，但终止完<strong>需要恢复</strong>！调度原则有：</p><ul><li><p>按优先级：优先级低的先终止</p></li><li><p>按执行时间长度：执行时间短的先终止</p></li><li><p>按进程需要的资源：需要资源多的先终止</p><p>需要注意饥饿的情况。。</p></li></ul></li></ul></li><li><p>资源抢占</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读者写者问题&quot;&gt;&lt;a href=&quot;#读者写者问题&quot; class=&quot;headerlink&quot; title=&quot;读者写者问题&quot;&gt;&lt;/a&gt;读者写者问题&lt;/h3&gt;&lt;p&gt;–写者对数据库有排他的访问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一读者-写者问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若有写
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://joshuaqyh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计组 | 课堂笔记</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E7%AC%AC%E5%9B%9B%E7%AB%A0CPU--%E8%AE%A1%E7%BB%84%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-01/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/第四章CPU--计组课堂笔记-01/</id>
    <published>2018-07-27T15:28:32.706Z</published>
    <updated>2019-05-16T14:04:44.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU基础概念"><a href="#CPU基础概念" class="headerlink" title="CPU基础概念"></a>CPU基础概念</h2><p>CPU功能： 指令控制，操作控制，时间控制，数据加工</p><p>CPU控制方式：同步控制，异步控制，联合控制</p><p>CPU指令周期：取值时间+执行时间</p><p>CPU周期：机器周期，总线周期。</p><h2 id="CPU中断逻辑"><a href="#CPU中断逻辑" class="headerlink" title="CPU中断逻辑"></a>CPU中断逻辑</h2><h4 id="中断基础概念"><a href="#中断基础概念" class="headerlink" title="中断基础概念"></a>中断基础概念</h4><ul><li>暂停当前程序的执行，转而去执行其他程序，执行完毕之后，重新恢复中断程序的执行</li></ul><ul><li><p>中断源： 人为设置的中断，程序性事故,  硬件故障，外部事件（比如断电）</p></li><li><p>中断分类：可屏蔽中断和不可屏蔽中断；内部中断和外部中断；软中断和硬中断。</p><p>根据CPU是否可以采取响应判断来分类：可屏蔽中断，不可屏蔽中断。 电源断电，CPU不可禁止响应，另外可以根据中断源是否被屏蔽来确定是否给予响应。</p><p>​</p></li></ul><p>####中断系统需要解决的7个问题：</p><ol><li><p>中断如何向CPU提出诉求</p></li><li><p>多个中断同时发生请求，CPU如何优先处理？</p><ol><li>硬件排队</li><li>软件轮询</li></ol></li><li><p>CPU响应中断的条件，时间，方式。</p><ol><li><p>中断服务程序入口地址的查找：硬件向量法和软件查询法</p></li><li><p>中断响应的条件：中断允许触发器必须为1</p></li><li><p>中断响应时间：当前<strong>指令周期结束</strong>。（而不是指令执行结束）</p><p>（2， 3 为中断响应的充分必要条件）</p></li></ol></li><li><p>CPU响应中断后如何保护现场  </p></li><li><p>中断响应结束之后如何阻止源程序的执行转入中断服务程序的入口地址</p></li><li><p>中断处理结束后，CPU如何恢复现场</p></li><li><p>中断处理结束过程中出现了新的中断请求,CPU该如何处理</p></li></ol><p><strong>处理办法</strong> ：中断处理系统中配置响应的软件和硬件</p><h4 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h4><ul><li><p>实现多重中断的条件：</p><ol><li><p>提前设置开中断指令 </p></li><li><p>优先级高的中断源有权屏蔽优先级别低的中断源</p></li></ol></li><li><p>中断屏蔽的结果</p><ol><li>屏蔽触发器与屏蔽字</li><li>改变中断优先登记以及运行轨迹的变化</li></ol><p><a href="https://blog.csdn.net/Blue_Starry_sky/article/details/53994698" target="_blank" rel="noopener">中断屏蔽字的设置</a></p><p>​</p></li><li><p>多重中断的断点保护</p><ol><li><strong>中断响应轨迹图</strong></li><li>设置中断屏蔽字改变中断响应优先级</li></ol></li></ul><p>发生多重中断时中断响应逻辑类似于CPU调度中的优先级调度。</p><p>引起cpu中断的各种因素（称为中断源）</p><ul><li>人为设置的中断（访管指令）</li><li>程序性事故</li></ul><ul><li>硬件故障</li><li>I/O设备</li><li>外部事件</li></ul><p><img src="http://p8ekwajjb.bkt.clouddn.com/1526351012462.png" alt="52635101246"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CPU基础概念&quot;&gt;&lt;a href=&quot;#CPU基础概念&quot; class=&quot;headerlink&quot; title=&quot;CPU基础概念&quot;&gt;&lt;/a&gt;CPU基础概念&lt;/h2&gt;&lt;p&gt;CPU功能： 指令控制，操作控制，时间控制，数据加工&lt;/p&gt;
&lt;p&gt;CPU控制方式：同步控制，异步控
      
    
    </summary>
    
    
      <category term="计组理论" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>计组 | 单周期CPU设计笔记和总结</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/单周期CPU设计笔记和总结/</id>
    <published>2018-07-27T15:28:32.694Z</published>
    <updated>2019-05-16T14:04:13.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单周期CPU设计与实现（实验"><a href="#单周期CPU设计与实现（实验" class="headerlink" title="单周期CPU设计与实现（实验)"></a>单周期CPU设计与实现（实验)</h3><p>每一个指令都在一个时钟周期内完成，称为单周期CPU。</p><hr><h3 id="单周期CPU数据通路图"><a href="#单周期CPU数据通路图" class="headerlink" title="单周期CPU数据通路图"></a>单周期CPU数据通路图</h3><p>该图描述的是CPU中数据，如何在 PC时钟，指令存储器，寄存器组，控制单元，ALU，数据存储器和控制器中如何传送的过程。</p><h4 id="MIPS指令的三种格式"><a href="#MIPS指令的三种格式" class="headerlink" title="MIPS指令的三种格式"></a>MIPS指令的三种格式</h4><ul><li><p>R类型</p></li><li><p>I类型</p></li><li><p>J类型</p></li></ul><p>算术运算指令</p><p>逻辑运算指令</p><p>移位指令</p><p>比较指令</p><p>存储器读写指令</p><p>分支指令</p><p>跳转指令</p><p>停机指令</p><p>CPU学习笔记 - 5/15</p><p>###逻辑设计</p><ul><li>组合单元— 操作单元 如门 ALU</li></ul><ul><li>状态单元— 存储单元，如存储器，寄存器</li></ul><p>注： 状态单元需要两个输入（时钟信号值和输入数据值） 一个输出（输出数据值）。</p><h3 id="建立数据通路"><a href="#建立数据通路" class="headerlink" title="建立数据通路"></a>建立数据通路</h3><p>部件认识：</p><p>PC程序计数器：存储当前指令的地址，每执行完一条指令，PC+4。（一个指令4个字节）</p><p>指令存储器：</p><p>数据存储器：</p><p>寄存器堆：</p><p>ALU:</p><p>加法器：</p><p><a href="http://www.cnblogs.com/sevenir-code/p/4887994.html" target="_blank" rel="noopener">MIPS指令特点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单周期CPU设计与实现（实验&quot;&gt;&lt;a href=&quot;#单周期CPU设计与实现（实验&quot; class=&quot;headerlink&quot; title=&quot;单周期CPU设计与实现（实验)&quot;&gt;&lt;/a&gt;单周期CPU设计与实现（实验)&lt;/h3&gt;&lt;p&gt;每一个指令都在一个时钟周期内完成，称为单
      
    
    </summary>
    
    
      <category term="计组" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>计组 | Verilog 设计初步</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/Verilog%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%AD%A5/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/Verilog设计初步/</id>
    <published>2018-07-27T15:28:32.680Z</published>
    <updated>2019-05-16T14:04:13.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog设计初步"><a href="#Verilog设计初步" class="headerlink" title="Verilog设计初步"></a>Verilog设计初步</h1><h2 id="Verilog-代码模板"><a href="#Verilog-代码模板" class="headerlink" title="Verilog 代码模板"></a>Verilog 代码模板</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句关键字字母都为小写字母，大小写敏感</span></span><br><span class="line"><span class="comment">//硬件思维来写代码</span></span><br><span class="line"><span class="comment">//命名不能以数字开头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> &lt;顶层模块名&gt; (输入输出端口列表) <span class="comment">//定义输入输出端口列表</span></span><br><span class="line"><span class="keyword">output</span> 输出端口列表；  <span class="comment">//输出端口生声明</span></span><br><span class="line"><span class="keyword">input</span>  输入端口列表；      <span class="comment">//输入输出端口生命 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*定义数据类型，功能定义，函数实现*/</span></span><br><span class="line">    <span class="keyword">reg</span>  信号名；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逻辑功能定义</span></span><br><span class="line"><span class="keyword">assign</span>&lt;结果信号名&gt; = &lt;表达式&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用always块描述逻辑功能</span></span><br><span class="line">    <span class="keyword">always</span> @(&lt;敏感信号&gt;)   </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//过程赋值运算</span></span><br><span class="line">            <span class="comment">//语句，if else while task</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//调用其他模块</span></span><br><span class="line">    &lt;调用模块名module_name&gt;&lt;例化模块名&gt;(&lt;端口列表&gt;)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//门元件例化</span></span><br><span class="line">    门元件关键字&lt;例化门元件名&gt;(&lt;端口列表port_list&gt;);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>四位选择器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux4_1(out,in0, in1, in2,in4,sel);</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">input</span> in0,in1,in2,in3;</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">1</span>:<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">reg</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @（in0 <span class="keyword">or</span> in1 <span class="keyword">or</span> in2 <span class="keyword">or</span> in3 <span class="keyword">or</span> sel)</span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            <span class="keyword">case</span>(sel)</span><br></pre></td></tr></table></figure><h2 id="数据类型及运算符"><a href="#数据类型及运算符" class="headerlink" title="数据类型及运算符"></a>数据类型及运算符</h2><ul><li>整数类型<ul><li>构成是：字符宽度+进制+数值。</li><li>例如：2’0xd5;  宽度为2的十六进制d5。</li></ul></li><li>逻辑类型<ul><li>高低电平 1 0，电路里体现为电压的区间</li><li>x：未知</li><li>z:   高阻</li></ul></li><li>net类型<ul><li>常用的是wire。用法是 wire[7:0] databus。 //databus宽度8</li></ul></li><li>寄存器类型<ul><li>reg </li><li>integer</li><li>time</li><li>real</li><li>realtime</li></ul></li><li>parameter参数 <ul><li>用来定义符号常量。 parameter sel = 8’ha3。</li></ul></li><li>向量类型</li><li>逻辑运算符</li><li>位运算符</li><li>三目运算</li><li>位拼接运算符</li></ul><p>下例采用数据流方式描述1位全加器。</p><p>在本例中，有两个连续赋值语句。这些赋值语句是并发的，与其书写的顺序无关。只要<br>连续赋值语句右端表达式中操作数的值变化(即有事件发生), 连续赋值语句即被执行。如果A<br>变化，则两个连续赋值都被计算，即同时对右端表达式求值，并将结果赋给左端目标。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul><li>initial</li><li>always @（敏感信号）<ul><li>@ (posedge clk) 上升沿</li><li>@ (negedge clk) 下降沿触发</li></ul></li><li>赋值语句<ul><li>连续赋值语句assign 只要连续赋值语句右端表达式中操作数的值变化, 连续赋值语句即被执行。</li><li>阻塞赋值 a = b;         ————-非时序赋值（组合）</li><li>非阻塞赋值  a&lt;=b      ————时序赋值中使用  </li><li>时序和组合在电路上的表现是时序赋值过程中需要等待时钟沿来触发。</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="设计特点"><a href="#设计特点" class="headerlink" title="设计特点"></a>设计特点</h2><h4 id="层次化模块化"><a href="#层次化模块化" class="headerlink" title="层次化模块化"></a>层次化模块化</h4><p>顶层模块和底层模块的设计方法，将模块细分为若干个子模块，在底层实现子模块功能，在顶层组合各个子模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Verilog设计初步&quot;&gt;&lt;a href=&quot;#Verilog设计初步&quot; class=&quot;headerlink&quot; title=&quot;Verilog设计初步&quot;&gt;&lt;/a&gt;Verilog设计初步&lt;/h1&gt;&lt;h2 id=&quot;Verilog-代码模板&quot;&gt;&lt;a href=&quot;#Veril
      
    
    </summary>
    
    
      <category term="计组" scheme="https://joshuaqyh.github.io/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>SQL用法总结</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/SQL%20%E7%94%A8%E6%B3%95--postgresql/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/SQL 用法--postgresql/</id>
    <published>2018-07-27T15:28:32.663Z</published>
    <updated>2019-02-18T14:15:09.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-用法–postgresql"><a href="#SQL-用法–postgresql" class="headerlink" title="SQL 用法–postgresql"></a>SQL 用法–postgresql</h2><p>[TOC]</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><a href="https://www.postgresql.org/docs/9.1/static/functions-geometry.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.1/static/functions-geometry.html</a></p><p>官方链接最全。</p><h4 id="表格操作"><a href="#表格操作" class="headerlink" title="表格操作"></a>表格操作</h4><h5 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> (</span><br><span class="line">    user_id <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, //声明主键</span><br><span class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span>,  //声明非空，唯一</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> </span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (user_id)  </span><br><span class="line">    <span class="keyword">REFERENCES</span> projects (user_id)</span><br><span class="line">    //声明  user_id为外键引用自表格projects</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="改表"><a href="#改表" class="headerlink" title="改表"></a>改表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> new_colum data_type column_constraint [<span class="keyword">AFTER</span> existing_column];  // 加列</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> max_limit,  //删除列</span><br><span class="line"></span><br><span class="line"><span class="keyword">MODIFY</span> fee <span class="built_in">NUMERIC</span> (<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;  //修改列约束</span><br></pre></td></tr></table></figure><h5 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h5><p>TRUNCATE table_name;  // 将行清空，但表头依旧保留</p><p>DROP table table_name;  //删除整个表格</p><table><thead><tr><th></th><th><strong>PRIMARY KEY constraint</strong></th><th><strong>UNIQUE constraint</strong></th></tr></thead><tbody><tr><td>The number of constraints</td><td>One</td><td>Many</td></tr><tr><td>NULL values</td><td>Do not allow</td><td>Allow</td></tr></tbody></table><h3 id="表的连接"><a href="#表的连接" class="headerlink" title="表的连接"></a>表的连接</h3><h4 id="内连接–INNER-JOIN"><a href="#内连接–INNER-JOIN" class="headerlink" title="内连接–INNER JOIN"></a>内连接–INNER JOIN</h4><p>两个表使用内连接，通过指定一个属性来匹配，若两个表的同一属性具有相同值，则保留在连接表中，其余不相等的行则消去。</p><p>图解</p><p>使用示例（内连接也可以连接多张表格）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  A.n</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> B.n = A.n;</span><br><span class="line">INNER JOIN C ON C.n = A.n;</span><br></pre></td></tr></table></figure><h4 id="全连接–FUll-OUTER-JOIN"><a href="#全连接–FUll-OUTER-JOIN" class="headerlink" title="全连接–FUll OUTER JOIN"></a>全连接–FUll OUTER JOIN</h4><p>指定连接条件，属性值相同的行保留，但不重复，属性值不同的值保留，但存在某些为Null的情况。</p><p>用法示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_list</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> B.n = A.n;</span><br></pre></td></tr></table></figure><h4 id="左连接–LEFT-JOIN"><a href="#左连接–LEFT-JOIN" class="headerlink" title="左连接–LEFT JOIN"></a>左连接–LEFT JOIN</h4><p>对几个将要连接的表指定条件进行连接，属性匹配的时候，会保留左表所有属性，即便右表属性为NULL,但不会存在左表属性为NULL的情况。</p><p>代码示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A.n</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> B.n = A.n;</span><br></pre></td></tr></table></figure><h4 id="右连接–RIGHT-JOIN"><a href="#右连接–RIGHT-JOIN" class="headerlink" title="右连接–RIGHT JOIN"></a>右连接–RIGHT JOIN</h4><p>和左连接相反，用法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A.n</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    A</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> B.n = A.n;</span><br></pre></td></tr></table></figure><h4 id="交叉连接–CROSS-JOIN"><a href="#交叉连接–CROSS-JOIN" class="headerlink" title="交叉连接–CROSS JOIN"></a>交叉连接–CROSS JOIN</h4><p>看图就知道。。。交叉连接结果的表格是 两表行数相乘。需要指出的一点就是两个表相连不需要指定cross join。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    column_list</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    A,</span><br><span class="line">    B;</span><br></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><blockquote><p>PostgreSQL provides several index types: B-tree, Hash, GiST and GIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the <code>CREATE INDEX</code> command creates B-tree indexes, which fit the most common situations.</p></blockquote><h4 id="创建b-tree索引"><a href="#创建b-tree索引" class="headerlink" title="创建b_tree索引"></a>创建b_tree索引</h4><p>语法： create index index_name ON table_name(column_name)</p><p>postgresql默认b树索引。官方描述如下：</p><blockquote><p>B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators:</p><table><thead><tr><th><code>&lt;</code></th></tr></thead><tbody><tr><td><code>&lt;=</code></td></tr><tr><td><code>=</code></td></tr><tr><td><code>&gt;=</code></td></tr><tr><td><code>&gt;</code></td></tr></tbody></table><p>Constructs equivalent to combinations of these operators, such as </p><p>BETWEEN</p><p> and </p><p>IN</p><p>, can also be implemented with a B-tree index search. Also, an </p><p>IS NULL</p><p> or </p><p>IS NOT NULL</p><p> condition on an index column can be used with a B-tree index.</p></blockquote><p>上述说明b_tree在范围查询中比较有效，也可以用于顺序检索数据。</p><p>当查询条件为范围查询时(运算符是 &gt; &lt; &lt;= &gt;= = is null, is not null, between and ,in)，b_tree索引可以体现较为良好的性能。</p><h4 id="创建hash索引"><a href="#创建hash索引" class="headerlink" title="创建hash索引"></a>创建hash索引</h4><p>语法： create index index_name on table_name using hash(column_name)</p><p>官方描述</p><blockquote><p>Hash indexes can only handle simple equality comparisons. The query planner will consider using a hash index whenever an indexed column is involved in a comparison using the <code>=</code> operator.</p></blockquote><p>上述说明，hash索引仅仅在处理简单的<strong>等值比较</strong>-(=) 中相对有效。</p><h4 id="使用GiST索引"><a href="#使用GiST索引" class="headerlink" title="使用GiST索引"></a>使用GiST索引</h4><p>(错误）语法： create index  index_name on table_name using GiST（column_name)</p><p>官方描述</p><blockquote><p>GiST indexes are not a single kind of index, but rather an infrastructure within which many different indexing strategies can be implemented. Accordingly, the particular operators with which a GiST index can be used vary depending on the indexing strategy (the <em>operator class</em>). As an example, the standard distribution of PostgreSQL includes GiST operator classes for several two-dimensional geometric data types, which support indexed queries using these operators:</p><table><thead><tr><th><code>&lt;&lt;</code></th></tr></thead><tbody><tr><td><code>&amp;&lt;</code></td></tr><tr><td><code>&amp;&gt;</code></td></tr><tr><td><code>&gt;&gt;</code></td></tr><tr><td>`&lt;&lt;</td><td>`</td></tr><tr><td>`&amp;&lt;</td><td>`</td></tr><tr><td>`</td><td>&amp;&gt;`</td></tr><tr><td>`</td><td>&gt;&gt;`</td></tr><tr><td><code>@&gt;</code></td></tr><tr><td><code>&lt;@</code></td></tr><tr><td><code>~=</code></td></tr><tr><td><code>&amp;&amp;</code></td></tr></tbody></table></blockquote><p>上述描述可知，gist 不是单一类型的索引，实现了不同策略索引的基础结构。可以根据索引策略（运算符类）来采取不同的索引策略。</p><p>详见<a href="https://www.postgresql.org/docs/9.1/static/gist.html" target="_blank" rel="noopener">官方文档gist index</a></p><h4 id="使用GIN索引"><a href="#使用GIN索引" class="headerlink" title="使用GIN索引"></a>使用GIN索引</h4><p>gin索引能够用于优化级的最近邻查找。</p><blockquote><p>GIN indexes are inverted indexes which can handle values that contain more than one key, arrays for example. Like GiST, GIN can support many different user-defined indexing strategies and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQLincludes GIN operator classes for one-dimensional arrays, which support indexed queries using these operators:</p><table><thead><tr><th><code>&lt;@</code></th></tr></thead><tbody><tr><td><code>@&gt;</code></td></tr><tr><td><code>=</code></td></tr><tr><td><code>&amp;&amp;</code></td></tr></tbody></table></blockquote><p>用法查看官方描述<a href="https://www.postgresql.org/docs/9.1/static/gin.html" target="_blank" rel="noopener">gin index</a>.</p><h3 id="分析效率-explain"><a href="#分析效率-explain" class="headerlink" title="分析效率 explain"></a>分析效率 explain</h3><p>将explain(analyze)置于语句的开始，结果将返回语句执行效率有关的数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">explain</span> （<span class="keyword">analyze</span>） <span class="keyword">Select</span> s_name, s_address, s_nationkey </span><br><span class="line"><span class="keyword">From</span> table_a </span><br><span class="line"><span class="keyword">Where</span> s_suppkey = <span class="number">717</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> （<span class="keyword">analyze</span>） <span class="keyword">Select</span> s_name, s_address, s_nationkey </span><br><span class="line"><span class="keyword">From</span> b_tree_a </span><br><span class="line"><span class="keyword">Where</span> s_suppkey = <span class="number">717</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> （<span class="keyword">analyze</span>） <span class="keyword">Select</span> s_name, s_address, s_nationkey </span><br><span class="line"><span class="keyword">From</span> hash_a </span><br><span class="line"><span class="keyword">Where</span> s_suppkey = <span class="number">717</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">Click To Expand Code</span><br><span class="line">PostgreSQL</span><br><span class="line">The following script creates the HR sample database structure in PostgreSQL.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> regions (</span><br><span class="line">region_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">region_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> countries (</span><br><span class="line">country_id <span class="built_in">CHARACTER</span> (<span class="number">2</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">country_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">40</span>),</span><br><span class="line">region_id <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (region_id) <span class="keyword">REFERENCES</span> regions (region_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> locations (</span><br><span class="line">location_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">street_address <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">40</span>),</span><br><span class="line">postal_code <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">12</span>),</span><br><span class="line">city <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">state_province <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>),</span><br><span class="line">country_id <span class="built_in">CHARACTER</span> (<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (country_id) <span class="keyword">REFERENCES</span> countries (country_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments (</span><br><span class="line">department_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">department_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">location_id <span class="built_in">INTEGER</span>,</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (location_id) <span class="keyword">REFERENCES</span> locations (location_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> jobs (</span><br><span class="line">job_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">job_title <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">35</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">min_salary <span class="built_in">NUMERIC</span> (<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line">max_salary <span class="built_in">NUMERIC</span> (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">employee_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">first_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">20</span>),</span><br><span class="line">last_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">email <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">phone_number <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">20</span>),</span><br><span class="line">hire_date <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">job_id <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">salary <span class="built_in">NUMERIC</span> (<span class="number">8</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">manager_id <span class="built_in">INTEGER</span>,</span><br><span class="line">department_id <span class="built_in">INTEGER</span>,</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (job_id) <span class="keyword">REFERENCES</span> jobs (job_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (department_id) <span class="keyword">REFERENCES</span> departments (department_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (manager_id) <span class="keyword">REFERENCES</span> employees (employee_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dependents (</span><br><span class="line">dependent_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">first_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">last_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">relationship <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">employee_id <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (employee_id) <span class="keyword">REFERENCES</span> employees (employee_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> regions (</span><br><span class="line">    region_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    region_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> countries (</span><br><span class="line">    country_id <span class="built_in">CHARACTER</span> (<span class="number">2</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    country_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">40</span>),</span><br><span class="line">    region_id <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (region_id) <span class="keyword">REFERENCES</span> regions (region_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> locations (</span><br><span class="line">    location_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    street_address <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">40</span>),</span><br><span class="line">    postal_code <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">12</span>),</span><br><span class="line">    city <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    state_province <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>),</span><br><span class="line">    country_id <span class="built_in">CHARACTER</span> (<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (country_id) <span class="keyword">REFERENCES</span> countries (country_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments (</span><br><span class="line">    department_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    department_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    location_id <span class="built_in">INTEGER</span>,</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (location_id) <span class="keyword">REFERENCES</span> locations (location_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> jobs (</span><br><span class="line">    job_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    job_title <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">35</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    min_salary <span class="built_in">NUMERIC</span> (<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line">    max_salary <span class="built_in">NUMERIC</span> (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    first_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">20</span>),</span><br><span class="line">    last_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    email <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone_number <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">20</span>),</span><br><span class="line">    hire_date <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    job_id <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    salary <span class="built_in">NUMERIC</span> (<span class="number">8</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    manager_id <span class="built_in">INTEGER</span>,</span><br><span class="line">    department_id <span class="built_in">INTEGER</span>,</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (job_id) <span class="keyword">REFERENCES</span> jobs (job_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (department_id) <span class="keyword">REFERENCES</span> departments (department_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (manager_id) <span class="keyword">REFERENCES</span> employees (employee_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dependents (</span><br><span class="line">    dependent_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    first_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_name <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    relationship <span class="built_in">CHARACTER</span> <span class="built_in">VARYING</span> (<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    employee_id <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (employee_id) <span class="keyword">REFERENCES</span> employees (employee_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL-用法–postgresql&quot;&gt;&lt;a href=&quot;#SQL-用法–postgresql&quot; class=&quot;headerlink&quot; title=&quot;SQL 用法–postgresql&quot;&gt;&lt;/a&gt;SQL 用法–postgresql&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="SQL" scheme="https://joshuaqyh.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>cocos2d学习丨坑和解决办法</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/Q&amp;A_cocos2d/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/Q&amp;A_cocos2d/</id>
    <published>2018-07-27T15:28:32.642Z</published>
    <updated>2019-02-18T14:18:20.553Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cocos2d-使用遇到的问题和解决办法"><a href="#cocos2d-使用遇到的问题和解决办法" class="headerlink" title="cocos2d 使用遇到的问题和解决办法"></a>cocos2d 使用遇到的问题和解决办法</h3><p>[TOC]</p><h4 id="Q-1：-如何解决中文乱码？"><a href="#Q-1：-如何解决中文乱码？" class="headerlink" title="Q 1： 如何解决中文乱码？"></a>Q 1： 如何解决中文乱码？</h4><p>A1: 直接看正确的示例代码，杂七杂八的代码太多，跟上版本的是下面这个</p><p>xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>HelloWorldStringkey&gt;  </span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>你好，世界string&gt;  </span><br><span class="line">dict&gt;</span><br></pre></td></tr></table></figure><p>解析xml文件的代码。需要注意按键值获取中文内容保存为char*指针后，用于创建的label类是CCLabelTTF，而不是Label.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用CCDictionary来读取xml    </span></span><br><span class="line">   CCDictionary *strings = CCDictionary::createWithContentsOfFile(<span class="string">"strings.xml"</span>);<span class="comment">//载入资源文件夹的strings.xml  </span></span><br><span class="line">   <span class="comment">//读取HelloWorld键中的值objectForKey根据key，获取对应的string    </span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *HelloWorld = ((CCString*)strings-&gt;objectForKey(<span class="string">"HelloWorldString"</span>))-&gt;m_sString.c_str();   </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//获取屏幕的尺寸、位置信息等        </span></span><br><span class="line">   CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize();   </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//乱码文字  </span></span><br><span class="line">   CCLabelTTF *label0 = CCLabelTTF::create(<span class="string">"你好，世界"</span>,<span class="string">"arial"</span>,<span class="number">72</span>);  </span><br><span class="line">   label0-&gt;setPosition(ccp(visibleSize.width/<span class="number">2</span>,<span class="number">2</span>*visibleSize.height/<span class="number">3</span>));  </span><br><span class="line">   <span class="keyword">this</span>-&gt;addChild(label0);  </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//正常中文  </span></span><br><span class="line">   CCLabelTTF *label1 = CCLabelTTF::create(HelloWorld,<span class="string">"arial"</span>,<span class="number">72</span>);  </span><br><span class="line">   label1-&gt;setPosition(ccp(visibleSize.width/<span class="number">2</span>,visibleSize.height/<span class="number">3</span>));  </span><br><span class="line">   <span class="keyword">this</span>-&gt;addChild(label1);</span><br></pre></td></tr></table></figure><h4 id="Q2：xml文件资源（字体-图片等等）的放置的正确位置？"><a href="#Q2：xml文件资源（字体-图片等等）的放置的正确位置？" class="headerlink" title="Q2：xml文件资源（字体,图片等等）的放置的正确位置？"></a>Q2：xml文件资源（字体,图片等等）的放置的正确位置？</h4><p>A2：xml文件需要放在整个顶级项目文件里头的resources文件夹，而不是放在win32项目的resource…..坑。。具体可以看初始代码引用字体文件的路径。</p><h4 id="Q3：-一开始打开项目文件发现文件不可用或者项目文件被卸载？"><a href="#Q3：-一开始打开项目文件发现文件不可用或者项目文件被卸载？" class="headerlink" title="Q3： 一开始打开项目文件发现文件不可用或者项目文件被卸载？"></a>Q3： 一开始打开项目文件发现文件不可用或者项目文件被卸载？</h4><p>A3：文件路径被改变，重新解压cocos安装包，重新安装。并且存放路径不能出现中文。</p><h4 id="Q4-编译时出现-libbox-lib不是有效的win32程序？"><a href="#Q4-编译时出现-libbox-lib不是有效的win32程序？" class="headerlink" title="Q4:  编译时出现 libbox.lib不是有效的win32程序？"></a>Q4:  编译时出现 libbox.lib不是有效的win32程序？</h4><p>A4：需要将hellococos项目设置为启动项。</p><h4 id="Q5：当出现许多-h-文件不可用的时候？"><a href="#Q5：当出现许多-h-文件不可用的时候？" class="headerlink" title="Q5：当出现许多.h 文件不可用的时候？"></a>Q5：当出现许多.h 文件不可用的时候？</h4><p>A5：重定解决方案目标</p><h4 id="Q6-本地坐标系和世界坐标系如何互换计算"><a href="#Q6-本地坐标系和世界坐标系如何互换计算" class="headerlink" title="Q6:本地坐标系和世界坐标系如何互换计算"></a>Q6:本地坐标系和世界坐标系如何互换计算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CCPoint p1 = sprite2-&gt;convertToNodeSpace(sprite1-&gt;getPosition());</span><br><span class="line">CCPoint p2 = sprite2-&gt;convertToWorldSpace(sprite1-&gt;getPosition());</span><br><span class="line">CCPoint p3 = sprite2-&gt;convertToNodeSpaceAR(sprite1-&gt;getPosition());</span><br><span class="line">CCPoint p4 = sprite2-&gt;convertToWorldSpaceAR(sprite1-&gt;getPosition());</span><br></pre></td></tr></table></figure><p>计算方法都是用sprite1的坐标去加减sprite2的坐标，针对本地坐标系就用减法，针对世界坐标系就用加法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;cocos2d-使用遇到的问题和解决办法&quot;&gt;&lt;a href=&quot;#cocos2d-使用遇到的问题和解决办法&quot; class=&quot;headerlink&quot; title=&quot;cocos2d 使用遇到的问题和解决办法&quot;&gt;&lt;/a&gt;cocos2d 使用遇到的问题和解决办法&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="cocos2d" scheme="https://joshuaqyh.github.io/tags/cocos2d/"/>
    
  </entry>
  
  <entry>
    <title>ant,junit,vim,java</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/Leanring_report-ant-junit-vim-java/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/Leanring_report-ant-junit-vim-java/</id>
    <published>2018-07-27T15:28:32.625Z</published>
    <updated>2019-05-16T14:01:14.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vim简介"><a href="#Vim简介" class="headerlink" title="Vim简介"></a>Vim简介</h2><p>Vim是一款上古编辑器，被广大程序员成为编辑器之神，这与之强大的编辑功能和编辑效率是分不开的。和Emace一样都在代码行业享有盛誉。vim最为重要的一点就是一切操作几乎可以舍弃鼠标，熟悉了vim命令的话，光靠键盘指令可以使开发效率迅速提高。</p><h2 id="Vim的安装"><a href="#Vim的安装" class="headerlink" title="Vim的安装"></a>Vim的安装</h2><h3 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下"></a>Linux下</h3><p>在Ubuntu平台下控制台敲入下列指令即可自动安装。</p><blockquote><p>sudo apt-get install vim</p></blockquote><h3 id="Windows下"><a href="#Windows下" class="headerlink" title="Windows下"></a>Windows下</h3><p>去<a href="http://www.vim.org/" target="_blank" rel="noopener">官网</a> 直接下载使用。</p><h2 id="Vim常用指令和教程"><a href="#Vim常用指令和教程" class="headerlink" title="Vim常用指令和教程"></a>Vim常用指令和教程</h2><p>首先值得注意的一点就是其实vim是自带教程的Vimtutor,s使用方法是linux下输入命令<strong>vimtutor</strong>,即可开启教程，这属于官方教程，  最为详细，没有之一。</p><p>在这里介绍一些常用的vim命令，有利于快速上手vim。</p><h4 id="1-创建或打开文件-vim-filename"><a href="#1-创建或打开文件-vim-filename" class="headerlink" title="1. 创建或打开文件 vim filename"></a>1. 创建或打开文件 <code>vim filename</code></h4><blockquote><p>vim helloworld.java</p></blockquote><h4 id="2-添加内容"><a href="#2-添加内容" class="headerlink" title="2.添加内容"></a>2.添加内容</h4><p>一开始进入处于<strong>正常模式</strong>在编辑窗口直接输入<code>i,a,o</code>等字符可以进入<strong>输入模式</strong>，可以在屏幕下方看到<em>insert</em>单词。按左上角<code>Esc</code>键可以回到正常模式，使用各种方便的指令。以下指令均在<strong>正常模式</strong>下进行。</p><h4 id="3-删除内容"><a href="#3-删除内容" class="headerlink" title="3.删除内容"></a>3.删除内容</h4><p><code>dd</code>可以删除光标所在的一整行。</p><p><code>ndd</code>可以删除光标以下的n行</p><h4 id="4-复制内容"><a href="#4-复制内容" class="headerlink" title="4. 复制内容"></a>4. 复制内容</h4><p><code>yy</code>可以复制光标所在行的字符<br><code>nyy</code>可以复制光标以下的n行字符</p><h4 id="5-粘贴内容"><a href="#5-粘贴内容" class="headerlink" title="5.粘贴内容"></a>5.粘贴内容</h4><p><code>p/P</code>作用时粘贴字符，小写p将已复制的字符粘贴到光标以下，大写P将字符粘贴到光标以上。</p><h4 id="6-撤销内容"><a href="#6-撤销内容" class="headerlink" title="6. 撤销内容"></a>6. 撤销内容</h4><p>撤销指令使用<code>u</code>,类似于windows上的<code>ctrl z`</code>。</p><h4 id="7-保存文件"><a href="#7-保存文件" class="headerlink" title="7. 保存文件"></a>7. 保存文件</h4><p>先进入正常模式<code>Esc</code>，然后输入<code>:</code>。然后输入：</p><ul><li><code>q</code> 离开vim</li><li><code>w</code> 保存内容</li><li><code>wq</code> 保存内容并离开vim,回到命令行</li></ul><p>其他还有许多可以提高效率的指令在这里就不多赘述啦。</p><hr><p>​            </p><h1 id="Java知识入门"><a href="#Java知识入门" class="headerlink" title="Java知识入门"></a>Java知识入门</h1><p>###初探java</p><p>从hello world入门, 初步体会java这一门面向对象编程语言。在HelloWorld.java文件中键入以下代码。（注意文件名称必须和<strong>类名</strong>一致）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到的编译指令是</p><blockquote><p>javac HelloWorld.java</p></blockquote><p>命令行没有弹出其他消息，即为编译成功。</p><p>执行指令是</p><blockquote><p>java HelloWorld</p></blockquote><p>这里用到两个重要指令<code>javac</code> <code>java</code> ，分别是编译和执行指令。</p><p>###基础知识</p><p>由于已经学习过C++，java语言在一定程度上和C++是类似的，所以在Java入门学习上可以直接跳过基础语法，对象和类，基本数据类型，运算符，循环结构，分支结构。</p><h3 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h3><h3 id="java继承"><a href="#java继承" class="headerlink" title="java继承"></a>java继承</h3><p>java继承的概念和C++类似，同样是定义一个父类，然后定义一个子类，来继承父类的属性，和C++不同的是，java用关键字<code>extends</code> 来表示继承关系。继承格式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类  </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####继承的特性</p><ul><li><p>子类拥有父类非private的属性，方法。</p></li><li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。</p></li><li><p>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。</p></li><li><p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。</p><p>​</p></li></ul><p>####继承的关键字</p><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">extends</td><td style="text-align:center">单一继承</td></tr><tr><td style="text-align:center">implements</td><td style="text-align:center">继承多个父类</td></tr><tr><td style="text-align:center">super</td><td style="text-align:center">实现对父类父类成员的访问，引用父类</td></tr><tr><td style="text-align:center">this</td><td style="text-align:center">指向自己的引用</td></tr><tr><td style="text-align:center">final</td><td style="text-align:center">将自身定义为不可继承的类</td></tr></tbody></table><h3 id="java重写和重载"><a href="#java重写和重载" class="headerlink" title="java重写和重载"></a>java重写和重载</h3><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>#####重写含义</p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, <strong>返回值和形参</strong>都不能改变。<strong>即外壳不变，核心重写！</strong>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。。</p><h5 id="重写方法的原则"><a href="#重写方法的原则" class="headerlink" title="重写方法的原则"></a>重写方法的原则</h5><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li></ul><h5 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.move(); <span class="comment">// 应用super类的方法</span></span><br><span class="line">      System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象</span></span><br><span class="line">      b.move(); <span class="comment">//执行 Dog类的方法</span></span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是</p><blockquote><p>狗可以跑和走</p></blockquote><p>可以看到在Dog类中重写了move()方法，传入的参数和返回类型和原来父类的方法一致，但内部代码可以修改。</p><p>####重载</p><p>#####重载含义</p><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><h5 id="重载的规则"><a href="#重载的规则" class="headerlink" title="重载的规则"></a>重载的规则</h5><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h5 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下两个参数类型顺序不同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"returntest3"</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"returntest4"</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Overloading o = <span class="keyword">new</span> Overloading();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>,<span class="string">"test3"</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">"test4"</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是</p><blockquote><p>test1</p><p>test2</p><p>test3</p><p>test4</p></blockquote><p>从运行结果看，调用的传参不同的函数顺序执行。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态就是对象多种表现形式的体现。</p><p>#####多态存在的三个必要条件</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><p>这里提供一份代码以便理解。大意就是一个抽象父类声明但不定义一个方法，在其他子类中可以重写这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃鱼"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"抓老鼠"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"看家"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###java组件部分设计</p><h3 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h3><p>在本次实训实验中利用了Swing这个java的<strong>GUI工具包</strong>，以实现一个简单的计算器。其中的主要用途是引用这些包的相关控件，控件的相关接口，同时给这些控件注册事件，建立事件处理逻辑。</p><p>介绍控件，首先应提到<strong>JComponet</strong> 。</p><p><strong>JComponent</strong></p><p>Swing 的整个可视组件库的基础构造块是 JComponent。它是所有组件的父类。它是一个<strong>抽象类</strong>，所以不能创建 JComponent，但是作为类层次结构的结果，从字面意义来说它包含了数百个函数，Swing 中的每个组件都可以使用这些函数。</p><p>注意： 每一个控件都是一个类，具有许多接口函数，在eclipes这个IDE上可以轻松获取。使用方法：鼠标移动到某一个控件类名，按ctrl键点击类名，即可弹出这个控件类里头详细的函数定义。</p><h4 id="常用的控件集合"><a href="#常用的控件集合" class="headerlink" title="常用的控件集合"></a>常用的控件集合</h4><table><thead><tr><th>控件</th><th>用途</th></tr></thead><tbody><tr><td>JLabel</td><td>用作文本描述</td></tr><tr><td>JButton</td><td>按钮</td></tr><tr><td>JFrame</td><td>窗口</td></tr><tr><td>JPanel</td><td>控件容器</td></tr><tr><td>JTextField</td><td>文本输入框</td></tr><tr><td>JCheckBox</td><td>确认框</td></tr><tr><td>GridLayout</td><td>生成网格状的布局</td></tr></tbody></table><p><em>Tips: 任何一个控件都有Add()的方法，意味着每一个控件都可以添加到另外一个控件里。</em></p><h4 id="注册事件的方法"><a href="#注册事件的方法" class="headerlink" title="注册事件的方法"></a>注册事件的方法</h4><p>以下以button为例，进行两种常用方式的注册。</p><h5 id="方法1-匿名内部类实现"><a href="#方法1-匿名内部类实现" class="headerlink" title="方法1 匿名内部类实现"></a>方法1 匿名内部类实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(  </span><br><span class="line">        <span class="keyword">new</span> ActionListener()&#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;  </span><br><span class="line">                 System.out.println(<span class="string">"你按了按钮一"</span>);  </span><br><span class="line">             &#125;  </span><br><span class="line"> &#125;);   <span class="comment">//调用监听函数并定义监听事件</span></span><br></pre></td></tr></table></figure><h5 id="方法2-利用一般内部类实现"><a href="#方法2-利用一般内部类实现" class="headerlink" title="方法2 利用一般内部类实现"></a>方法2 利用一般内部类实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(<span class="keyword">new</span> Button2ActionListener()); </span><br><span class="line">     </span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Button1ActionListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;  </span><br><span class="line">           System.out.println(<span class="string">"你按了按钮一"</span>);     </span><br><span class="line">     &#125;     </span><br><span class="line"> &#125;  <span class="comment">//将事件处理为一个类事件</span></span><br></pre></td></tr></table></figure><p>用了以上的基础知识就可以解决一个简单计算器的实现啦。</p><h1 id="Junit-学习和使用"><a href="#Junit-学习和使用" class="headerlink" title="Junit 学习和使用"></a>Junit 学习和使用</h1><p>###Junit是什么</p><p>JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。</p><p><strong>JUnit提供：</strong></p><ul><li>断言测试预期结果。</li><li>测试功能共享通用的测试数据。</li><li>测试套件轻松地组织和运行测试。</li><li>图形和文本测试运行。</li></ul><p><strong>JUnit用于测试：</strong></p><ul><li><p>整个对象</p></li><li><p>对象的一部分 - 交互的方法或一些方法</p></li><li><p>几个对象之间的互动(交互)</p><p>​</p></li></ul><p>###JUnit的特点</p><ul><li>JUnit是用于编写和运行测试的开源框架。</li><li>提供了注释，以确定测试方法。</li><li>提供断言测试预期结果。</li><li>提供了测试运行的运行测试。</li><li>JUnit测试让您可以更快地编写代码，提高质量</li><li>JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。</li><li>JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。</li><li>JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。</li><li>Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。</li></ul><table><thead><tr><th><strong>注解</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>@Test</strong>public void method()</td><td>测试注释指示该公共无效方法它所附着可以作为一个测试用例。</td></tr><tr><td><strong>@Before</strong>public void method()</td><td>Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。</td></tr><tr><td><strong>@BeforeClass</strong>public static void method()</td><td>BeforeClass注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。</td></tr><tr><td><strong>@After</strong>public void method()</td><td>After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等)</td></tr><tr><td><strong>@AfterClass</strong>public static void method()</td><td>当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于BeforeClass)的方法必须定义为静态。</td></tr><tr><td><strong>@Ignore</strong>public static void method()</td><td>当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为@Ignore的方法将不被执行。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vim简介&quot;&gt;&lt;a href=&quot;#Vim简介&quot; class=&quot;headerlink&quot; title=&quot;Vim简介&quot;&gt;&lt;/a&gt;Vim简介&lt;/h2&gt;&lt;p&gt;Vim是一款上古编辑器，被广大程序员成为编辑器之神，这与之强大的编辑功能和编辑效率是分不开的。和Emace一样都在代
      
    
    </summary>
    
    
      <category term="Java" scheme="https://joshuaqyh.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/git学习/</id>
    <published>2018-07-27T15:28:32.596Z</published>
    <updated>2018-07-27T15:29:24.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从本地添加项目到github仓库"><a href="#从本地添加项目到github仓库" class="headerlink" title="从本地添加项目到github仓库"></a>从本地添加项目到github仓库</h3><p>在git bash 命令行下进行：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir project    <span class="comment">//本地新建一个仓库，项目文件夹</span></span><br><span class="line">$ cd project       <span class="comment">// 进入文件夹</span></span><br><span class="line">$ git init         <span class="comment">// 初始化</span></span><br><span class="line">$ git remote add origin git<span class="meta">@github</span>.<span class="string">com:</span>username<span class="regexp">/RepoName.git /</span>/ 添加远程地址,换用户名和仓库名</span><br><span class="line">$ cat .git<span class="regexp">/config    /</span>/查看配置文件是否添加远程地址成功</span><br><span class="line">$ git add -A         <span class="comment">// 上传本地项目</span></span><br><span class="line">$ git commit -m  <span class="string">"first commit"</span>    <span class="comment">//项目注释</span></span><br><span class="line">$ git push origin master    <span class="comment">// 上传仓库初始代码</span></span><br><span class="line">$ git status    <span class="comment">//查看提交情况，这一行出现在commit之前</span></span><br></pre></td></tr></table></figure><h3 id="git基础命令"><a href="#git基础命令" class="headerlink" title="git基础命令"></a>git基础命令</h3><ul><li>git staus  ————————————————————————- 进入仓库，查看仓库文件状态</li><li>git diff  + filename ———————————————————— 查看文件与上一次提交时的不同</li><li>git add + filename    ||  git commit -m “注释”   ———————提交到库   —此处相当于代码存档</li><li>git log ——————————————————————————查看存档历史</li><li>git reset –hard HEAD^   ———————————————— —-一个^ 表示回退几次; HEA~100 回退一百次</li><li>git reset –hard  版本id   —————————————————–回溯版本id</li><li>git reflog         ——————————————————————– 查看历史指令，可以看到之前的版本id </li><li>git checkout – filename —————————————————— 舍弃上一次更改</li><li>git pull  —————————————————————————— 更新内容</li></ul><h4 id="暂存区概念"><a href="#暂存区概念" class="headerlink" title="暂存区概念"></a>暂存区概念</h4><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><hr><p><strong>多次修改的版本 可以多次add 保留到暂存区之后，一次性commit提交到版本库。</strong></p><h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>提交分支： <code>git push origin branchname</code>    // orgin 相当于仓库， 意思为提交到仓库的某一分支</p><h3 id="git-协同"><a href="#git-协同" class="headerlink" title="git 协同"></a>git 协同</h3><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><ul><li><p>查看远程库信息，使用<code>git remote -v</code>；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li><li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。  </p><p>​</p><p>​</p></li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><h3 id="一些git学习链接"><a href="#一些git学习链接" class="headerlink" title="一些git学习链接"></a>一些git学习链接</h3><p><a href="https://gist.github.com/" target="_blank" rel="noopener">git 代码分享</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰git教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;从本地添加项目到github仓库&quot;&gt;&lt;a href=&quot;#从本地添加项目到github仓库&quot; class=&quot;headerlink&quot; title=&quot;从本地添加项目到github仓库&quot;&gt;&lt;/a&gt;从本地添加项目到github仓库&lt;/h3&gt;&lt;p&gt;在git bash 命令行下
      
    
    </summary>
    
    
      <category term="git" scheme="https://joshuaqyh.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 | CPU调度算法（重点）</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/CPU%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/CPU调度算法/</id>
    <published>2018-07-27T15:28:32.558Z</published>
    <updated>2019-03-27T13:53:27.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU调度算法"><a href="#CPU调度算法" class="headerlink" title="CPU调度算法"></a>CPU调度算法</h2><ul><li><p>先到先服务 fcfs    – CPU请求次序</p><ul><li>缺点：FCFS 算法对于分时系统(每个用户需要定<br>时地得到一定的CPU 时间)是特别麻烦的。允许一个进程保持CPU 时间过长将是个严重<br>错误。</li></ul></li><li><p>最短作业优先sjf  – 平均等待时间最短 | 最优</p></li><li><ul><li><p>存在抢占和非抢占</p></li><li><p>抢占（最短剩余时间优先）：由于CPU到达时间和CPU区间大小的差异，长作业可以优先处理，但出现短作业请求的时候，优先处理短作业</p><p>​</p></li></ul></li></ul><ul><li>优先级调度    – fcfs sjf都是特殊的优先级调度</li></ul><blockquote><p>每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU 。具有相同优先级<br>的进程按FCFS 顺序调度。</p></blockquote><ul><li><ul><li><p>同样存在抢占调度的情况</p></li><li><p>问题：存在阻塞或饥饿– 存在进程一直处于等待状态</p></li><li><p>解决方法：老化– 等待时间越长，优先级提高</p><blockquote><p>优先级可通过内部或外部方式来定义。内部定义优先级使用一些测量数据以计算进程<br>优先级。例如，时间极限、内存要求、打开文件的数量和平均I/O 区间与平均CPU 区间之<br>比都可以用于计算优先级。外部优先级是通过操作系统之外的准则来定义的，如进程重要<br>性、用于支付使用计算机的费用类型和数量、赞助工作的单位、其他(通常为政治)因素。</p></blockquote></li><li><p>​</p></li></ul></li><li><p>轮转法调度 – rr ( round robin</p></li><li><ul><li><p>为分时系统而设置的</p></li><li><p>平均等待时间较长，响应时间较长</p></li><li><p>定义较小的时间处理单元，时间片。时间片和周转时间有关，要考虑和上下文切换的时间比例</p></li><li><p>进程存储在一个fifo循环队列中</p><p>​</p></li></ul></li><li><p>多级队列调度</p><blockquote><p>多级队列 调度算法(multilevel queue      scheduling algorithm) 将就绪队列分成多个独立队列(见图5.6) 。根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被<strong>永久</strong>地分配到一个队列。</p></blockquote></li><li><ul><li>根据进程的性质和属性对进程进行分组的方法，给不同的队列设立优先级。比如前台交互进程和后台批处理过程。前台交互进程较高。</li><li>每个队列可以采用不同的调度算法，前台交互需要等待时间较短的调度算法，通常选用rr调度，后台批处理可以选择fcfs,优先级调度算法。</li><li>缺点同样会产生阻塞的情况</li></ul></li><li><blockquote><p>队列之间必须有调度，通常采用固定优先级抢占调度。例如，前台队列可以比<br>后台队列具有绝对的优先级。<br>现在来研究一下具有5 个队列的多级队列调度算法的例子，按优先级来排列:<br>①系统进程。<br>②交互进程。<br>③交互编辑进程。<br>④批处理进程。<br>⑤学生进程。</p></blockquote></li></ul><ul><li>多级反馈队列调度</li></ul><blockquote><p>多级反馈队列调度算法(multilevel feedback queue scheduling algorithm) 允<br>许进程在队列之间移动。主要思想是根据<strong>不同CPU 区间</strong>的特点以区分进程。如果进程使用<br>过多CPU 时间，那么它会被转移到更低优先级队列。这种方案将νo 约束和交互进程留在<br>更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级<br>队列。这种形式的老化阻止饥饿的发生。</p></blockquote><blockquote><p>通常，多级反馈队列调度程序可由下列参数来定义:<br>.队列数量。<br>· 每个队列的调度算法。<br>· 用以确定何时升级到更高优先级队列的方法。<br>. 用以确定何时降级到更低优先级队列的方法。<br>· 用以确定进程在需要服务时应进入哪个队列的方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CPU调度算法&quot;&gt;&lt;a href=&quot;#CPU调度算法&quot; class=&quot;headerlink&quot; title=&quot;CPU调度算法&quot;&gt;&lt;/a&gt;CPU调度算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先到先服务 fcfs    – CPU请求次序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点：F
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://joshuaqyh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>知乎问答——如何用互联网思维卖馒头</title>
    <link href="https://joshuaqyh.github.io/2018/07/27/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94_%E5%A6%82%E4%BD%95%E7%94%A8%E4%BA%92%E8%81%94%E7%BD%91%E6%80%9D%E7%BB%B4%E4%B9%B0%E9%A6%92%E5%A4%B4/"/>
    <id>https://joshuaqyh.github.io/2018/07/27/知乎问答_如何用互联网思维买馒头/</id>
    <published>2018-07-27T15:28:32.545Z</published>
    <updated>2019-02-18T14:18:20.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回答一"><a href="#回答一" class="headerlink" title="回答一"></a>回答一</h3><p><strong>一、规划</strong></p><p>slogan：做中国好馒头、做好中国馒头</p><p>使命：让全中国人重新吃上安心馒头</p><p>愿景：成为世界顶级的馒头品牌</p><p>广告语：这一口，谁不爱</p><p>目标人群：新中产阶级</p><p>新中产消费观的最大特征：相较于价格，他们在意质量，对于高质量的商品和服务，他们愿意为之付出更高的代价。较高的收入与体面的工作给中产带来片刻的欣慰，但不安与焦虑才是中产光鲜外表下最戳心的痛点，消费升级正是他们面对这种焦虑选择的解决方案。</p><p><strong>二、设计</strong></p><p>1.品牌</p><p>品牌要能让人产生联想，要好记，比如：”真馒头”</p><p>2.设计</p><p>包装要讲究，但重点是一定要去德国买一个红点奖。</p><p>每个包装上，还必须有扎心的文案，比如:</p><p>我们拼尽全力，不是为了活成别人想要的模样</p><p>你只来了一下子，却改变了我一辈子</p><p>我有馒头，你有故事吗?</p><p>3.产品</p><p>要秉承匠心精神，只做单一产品–真•葱花馒头，将一款产品做到极致。</p><p>但是可以根据用户人群推出专属款，比如</p><p>有助记忆力的儿童款</p><p>提高睡眠质量的老人款</p><p>4.门店</p><p>不同类型的门店来满足用户多元化的场景需求，包括满足用户线下社交需求的旗舰店，满足亲子活动的DIY体验店，以及快速自提、服务商务人群的快取店，满足客户外送需求的外卖厨房店。通过差异化的门店布局，实现对消费者日常生活全方位覆盖。</p><p>5.定价</p><p>统一价19.9元！！没有足够的利润空间，618、双11、双12你拿什么打折？</p><p><strong>三、营销</strong></p><p>1.讲故事</p><p>馒头的面全部来自北纬36°黄金优麦区种植的8848号小麦，纯手工脱粒。</p><p>蒸馒头的水，选自长白山矿物质水，再经过36道工艺人工萃取。</p><p>创新思维碰撞传统手工技艺，再造中国馒头新未来。</p><p>2.讲情怀</p><p>创始人211名校毕业后，放弃BTA百万年薪自主创业；尝遍了全国各地大街小巷所有的馒头，拜访数十位隐居的大师，经历了同事朋友的嘲讽、女朋友的离等非常人所能经历的磨难后，终于发明了拥有独特、唯一口味的”真馒头”。</p><p>3.软文推广</p><p>《震惊！男人吃了沉默，女人吃了流泪》</p><p>《感动！一个馒头如果没有情怀，那它和面粉有什么区别》</p><p>《刚刚！人人都在疯抢这款馒头》</p><p>…</p><p>4.造气氛</p><p>找很多人来回排队，不用多讲，这是网红店的标配。但是排队的人员组成还是要有讲究的，需要有学生、青年、白领、中年人，而且不能一起到，要分批到。</p><p>5.制造热点事件</p><p>哭诉鹅厂抄袭商业模式</p><p>喊话某互联网大佬，打赌3年后比营业额</p><p>6.社会化传播</p><p>赞助绝地求生，新增能量馒头，吃一个血条全满！</p><p>雇人拿着馒头去starbuck、costa，让咖啡、苹果笔记本、馒头成为新一代的装B三件套。</p><p>抢在韩国人前为馒头申遗！</p><p>7.微微一抖</p><p>微博：每天去抢杜蕾斯、回忆专用小马甲的沙发，设置转发有奖活动；</p><p>微信公众号：每天深夜10点，推送一条荷尔蒙满满的语音鸡汤，一定要煽情！</p><p>抖音：做一个卡通吉祥物，天天耍贱，卖萌，用户爱看什么拍什么。</p><p>8.饥饿营销</p><p>每家门店每天限量8888个，卖完即止。第二天的馒头需要提前预约。</p><p>9.裂变营销</p><p>给好友免费送馒头，他吃你也吃。</p><p>10.社群运营</p><p>建立真馒头的粉丝群，收集种子用户的建议反馈，经常与粉丝互动。邀请5个人进群可免费领取一个馒头，群成员可享受新品内测试吃福利。</p><p>11.APP运营</p><p>开启步数兑换优惠券功能，倡导绿色出行；</p><p>消费有积分，积分可以浇水种小麦，小麦长成后可以直接磨成面，寄给用户。</p><p>增加交友功能，注册必须上传吃馒头的自拍照，可以查看5公里内异性用户的照片，但是必须相互点赞，才能加好友聊天。</p><p>12.会员体系</p><p>充值5000黄金会员，享8折优惠；充值10000白金会员，全部5折，生日赠送定制版馒头。</p><p>13.配送模式</p><p>可以在APP或公众号上自助完成下单，下单时可以选择温度、辣度等，制作好了系统会发提示，凭二维码领取，节约排队时间；如果选择外送，在已经开通的外送区域15分钟左右送到，超过30分钟免费。</p><p><strong>四、实现盈利</strong></p><p>炒作互联网新零售+馒头的成功之道，然后花钱发一堆新闻通稿，进行大量商业路演，约见各类ＶＰ，重点来了：</p><p>想要快速套现的可以选择阿里的投资，2年内一定会被全资收购；</p><p>想要上市的优选搜狐的投资，直接搭建境外架构，3年后妥妥纳斯达克敲钟。</p><p>最后你们一定会问，你谁啊，靠不靠谱啊？</p><p>“<strong>我，秦始皇，打钱！</strong>”</p><h3 id="回答二"><a href="#回答二" class="headerlink" title="回答二"></a>回答二</h3><p><strong>一、规划</strong></p><p>slogan：做中国好馒头、做好中国馒头</p><p>使命：让全中国人重新吃上安心馒头</p><p>愿景：成为世界顶级的馒头品牌</p><p>广告语：这一口，谁不爱</p><p>目标人群：新中产阶级</p><p>新中产消费观的最大特征：相较于价格，他们在意质量，对于高质量的商品和服务，他们愿意为之付出更高的代价。较高的收入与体面的工作给中产带来片刻的欣慰，但不安与焦虑才是中产光鲜外表下最戳心的痛点，消费升级正是他们面对这种焦虑选择的解决方案。</p><p><strong>二、设计</strong></p><p>1.品牌</p><p>品牌要能让人产生联想，要好记，比如：”真馒头”</p><p>2.设计</p><p>包装要讲究，但重点是一定要去德国买一个红点奖。</p><p>每个包装上，还必须有扎心的文案，比如:</p><p>我们拼尽全力，不是为了活成别人想要的模样</p><p>你只来了一下子，却改变了我一辈子</p><p>我有馒头，你有故事吗?</p><p>3.产品</p><p>要秉承匠心精神，只做单一产品–真•葱花馒头，将一款产品做到极致。</p><p>但是可以根据用户人群推出专属款，比如</p><p>有助记忆力的儿童款</p><p>提高睡眠质量的老人款</p><p>4.门店</p><p>不同类型的门店来满足用户多元化的场景需求，包括满足用户线下社交需求的旗舰店，满足亲子活动的DIY体验店，以及快速自提、服务商务人群的快取店，满足客户外送需求的外卖厨房店。通过差异化的门店布局，实现对消费者日常生活全方位覆盖。</p><p>5.定价</p><p>统一价19.9元！！没有足够的利润空间，618、双11、双12你拿什么打折？</p><p><strong>三、营销</strong></p><p>1.讲故事</p><p>馒头的面全部来自北纬36°黄金优麦区种植的8848号小麦，纯手工脱粒。</p><p>蒸馒头的水，选自长白山矿物质水，再经过36道工艺人工萃取。</p><p>创新思维碰撞传统手工技艺，再造中国馒头新未来。</p><p>2.讲情怀</p><p>创始人211名校毕业后，放弃BTA百万年薪自主创业；尝遍了全国各地大街小巷所有的馒头，拜访数十位隐居的大师，经历了同事朋友的嘲讽、女朋友的离等非常人所能经历的磨难后，终于发明了拥有独特、唯一口味的”真馒头”。</p><p>3.软文推广</p><p>《震惊！男人吃了沉默，女人吃了流泪》</p><p>《感动！一个馒头如果没有情怀，那它和面粉有什么区别》</p><p>《刚刚！人人都在疯抢这款馒头》</p><p>…</p><p>4.造气氛</p><p>找很多人来回排队，不用多讲，这是网红店的标配。但是排队的人员组成还是要有讲究的，需要有学生、青年、白领、中年人，而且不能一起到，要分批到。</p><p>5.制造热点事件</p><p>哭诉鹅厂抄袭商业模式</p><p>喊话某互联网大佬，打赌3年后比营业额</p><p>6.社会化传播</p><p>赞助绝地求生，新增能量馒头，吃一个血条全满！</p><p>雇人拿着馒头去starbuck、costa，让咖啡、苹果笔记本、馒头成为新一代的装B三件套。</p><p>抢在韩国人前为馒头申遗！</p><p>7.微微一抖</p><p>微博：每天去抢杜蕾斯、回忆专用小马甲的沙发，设置转发有奖活动；</p><p>微信公众号：每天深夜10点，推送一条荷尔蒙满满的语音鸡汤，一定要煽情！</p><p>抖音：做一个卡通吉祥物，天天耍贱，卖萌，用户爱看什么拍什么。</p><p>8.饥饿营销</p><p>每家门店每天限量8888个，卖完即止。第二天的馒头需要提前预约。</p><p>9.裂变营销</p><p>给好友免费送馒头，他吃你也吃。</p><p>10.社群运营</p><p>建立真馒头的粉丝群，收集种子用户的建议反馈，经常与粉丝互动。邀请5个人进群可免费领取一个馒头，群成员可享受新品内测试吃福利。</p><p>11.APP运营</p><p>开启步数兑换优惠券功能，倡导绿色出行；</p><p>消费有积分，积分可以浇水种小麦，小麦长成后可以直接磨成面，寄给用户。</p><p>增加交友功能，注册必须上传吃馒头的自拍照，可以查看5公里内异性用户的照片，但是必须相互点赞，才能加好友聊天。</p><p>12.会员体系</p><p>充值5000黄金会员，享8折优惠；充值10000白金会员，全部5折，生日赠送定制版馒头。</p><p>13.配送模式</p><p>可以在APP或公众号上自助完成下单，下单时可以选择温度、辣度等，制作好了系统会发提示，凭二维码领取，节约排队时间；如果选择外送，在已经开通的外送区域15分钟左右送到，超过30分钟免费。</p><p><strong>四、实现盈利</strong></p><p>炒作互联网新零售+馒头的成功之道，然后花钱发一堆新闻通稿，进行大量商业路演，约见各类ＶＰ，重点来了：</p><p>想要快速套现的可以选择阿里的投资，2年内一定会被全资收购；</p><p>想要上市的优选搜狐的投资，直接搭建境外架构，3年后妥妥纳斯达克敲钟。</p><p>最后你们一定会问，你谁啊，靠不靠谱啊？</p><p>“<strong>我，秦始皇，打钱！</strong>”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;回答一&quot;&gt;&lt;a href=&quot;#回答一&quot; class=&quot;headerlink&quot; title=&quot;回答一&quot;&gt;&lt;/a&gt;回答一&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一、规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;slogan：做中国好馒头、做好中国馒头&lt;/p&gt;
&lt;p&gt;使命：让全中国人重
      
    
    </summary>
    
    
      <category term="互联网思维" scheme="https://joshuaqyh.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
</feed>
