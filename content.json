{"meta":{"title":"KnowMyself","subtitle":null,"description":null,"author":"Qiuyihao","url":"http://yoursite.com"},"pages":[{"title":"search","date":"2018-04-30T11:50:09.000Z","updated":"2018-04-30T11:50:09.063Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"404","date":"2018-04-30T11:50:23.000Z","updated":"2018-04-30T11:50:23.290Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""}],"posts":[{"title":"git学习","slug":"git学习","date":"2018-05-17T03:10:08.837Z","updated":"2018-05-18T01:12:08.569Z","comments":true,"path":"2018/05/17/git学习/","link":"","permalink":"http://yoursite.com/2018/05/17/git学习/","excerpt":"","text":"[TOC] 从本地添加项目到github仓库在git bash 命令行下进行： 123456789$ mkdir project //本地新建一个仓库，项目文件夹$ cd project // 进入文件夹$ git init // 初始化$ git remote add origin git@github.com:username/RepoName.git // 添加远程地址,换用户名和仓库名$ cat .git/config //查看配置文件是否添加远程地址成功$ git add -A // 上传本地项目$ git commit -m \"first commit\" //项目注释$ git push origin master // 上传仓库初始代码$ git status //查看提交情况，这一行出现在commit之前 git命令 git staus ————————————————————————- 进入仓库，查看仓库文件状态 git diff + filename ———————————————————— 查看文件与上一次提交时的不同 git add + filename || git commit -m “注释” ———————提交到库 —此处相当于代码存档 git log ——————————————————————————查看存档历史 git reset –hard HEAD^ ———————————————— —-一个^ 表示回退几次; HEA~100 回退一百次 git reset –hard 版本id —————————————————–回溯版本id git reflog ——————————————————————– 查看历史指令，可以看到之前的版本id git checkout – filename —————————————————— 舍弃上一次更改 暂存区概念前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 多次修改的版本 可以多次add 保留到暂存区之后，一次性commit提交到版本库。 一些git学习链接git 代码分享 廖雪峰git教程","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"回调函数","slug":"回调函数","date":"2018-05-16T17:24:06.838Z","updated":"2018-05-19T03:20:22.434Z","comments":true,"path":"2018/05/17/回调函数/","link":"","permalink":"http://yoursite.com/2018/05/17/回调函数/","excerpt":"","text":"什么是回调函数In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time［引自 维基百科 callback］ 回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。 在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。 回调函数 12345678910function add(num1, num2, callback)&#123; var sum = num1 + num2; callback(sum);&#125;function print(num)&#123; console.log(num);&#125;add(1, 2, print); //=&gt;3 匿名回调函数 12345678function add(num1, num2, callback)&#123; var sum = num1 + num2; callback(sum);&#125;add(1, 2, function(sum)&#123; console.log(sum); //=&gt;3&#125;); jQuery中大量的使用了回调函数 123$(&quot;#btn&quot;).click(function() &#123; alert(&quot;button clicked&quot;);&#125;); 回调函数有哪些特点不会立刻执行 回调函数作为参数传递给一个函数的时候，传递的只是函数的定义并不会立即执行。和普通的函数一样，回调函数在函调用函数数中也要通过()运算符调用才会执行。 是个闭包 回调函数是一个闭包，也就是说它能访问到其外层定义的变量。 你再github的用户名和刚才新建的仓库","categories":[],"tags":[{"name":"js, cocos2d.x","slug":"js-cocos2d-x","permalink":"http://yoursite.com/tags/js-cocos2d-x/"}]},{"title":"","slug":"经济学原理","date":"2018-05-16T10:10:46.261Z","updated":"2018-05-16T10:10:46.447Z","comments":true,"path":"2018/05/16/经济学原理/","link":"","permalink":"http://yoursite.com/2018/05/16/经济学原理/","excerpt":"","text":"消费与可支配收入相关 公司投资，公司战略与财力，销量，利率低。 生产需求均衡曲线 财政扩张/收缩政策 加/减税 经济周期的波动—-产出和利率的负相关 整体思维和局部思维","categories":[],"tags":[]},{"title":"认识经济学原理","slug":"认识经济学原理","date":"2018-05-15T01:21:22.895Z","updated":"2018-05-19T03:54:02.258Z","comments":true,"path":"2018/05/15/认识经济学原理/","link":"","permalink":"http://yoursite.com/2018/05/15/认识经济学原理/","excerpt":"","text":"经济学学习##十大曼昆经济学原理 ###原理一：人们面临交替关系 典型的交替关系就是 “大炮和黄油”的交替，花更多钱在大炮研发上就注定了减少黄油生产的投入。 这其中 涉及到一个资源配置做出决策的问题。 认识到人们面临交替关系本身并没有告诉我们，人们将会或应该作出什么决策。一个学生不应该仅仅由于要增加用于学习经济学的时间而放弃心理学的学习。社会不应该仅仅由于环境控制降低了我们的物质生活水平而不再保护环境。也不应该仅仅由于帮助穷人扭曲了工作激励而忽视了他们。然而，认识到生活中的交替关系是重要的，因为人们只有了解他们可以得到的选择，才能作出良好的决策。 原理二：某种东西的成本是为了得到它而放弃的东西许多行为选择的成本有时不是那么明显，收益也分为长期和短期，时间成本 ，金钱成本，人力成本都是需要考量的。 原理三： 理性人考虑边际量做决策考虑行为所花的额外成本和额外收益，通过比较这种边际收益和边际成本来，评价比较合理。 原理四：人们会对激励做出反应激励在决定行为中的中心作用是重要的。激励在贸易中可能体现为商品的成本或者收益。 列出并简要解释个人作出决策的四个原理 原理五： 贸易能使每个人状况更好贸易竞争能使国家和个人在相互交易的过程中收益。国与国之间的贸易未必就是像体育比赛一样一方赢，一方输，事实恰好相反，两国之间贸易可以使每个国家状况更好。 原理六：市场通常是组织经济活动的一种好方法经济学家亚当·斯密（Adam Smith）在他 1776 年的著作《国富论》中提出了全部经济学中最有名的观察结果：家庭和企业在市场上相互交易，他们仿佛被一只“看不见的手”所指引，引起了合意的市场结果。本书的目的之一就是要解释这只看不见的手如何施展它的魔力。当你学习经济学时，你将会知道，价格就是看不见的手用来指引经济活动的工具。价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本 关于看不见的手在指引经济活动中的技巧有一个重要推论：当政府阻止价格根据供求自发地调整时，它就限制了看不见的手协调组成经济的千百万家庭和企业的能力。这个推论解释了为什么税收对资源配置有不利的影响：税收扭曲了价格，从而扭曲了家庭和企业的决策。这个推论还解释了租金控制这类直接控制价格的政策所引起的更大伤害。而且，这个推论也解释了共产主义的失败。在共产主义国家中，价格不是在市场上决定的，而是由中央计划者指定。这些计划者缺乏那种在价格对市场力量自由地作出反应时反映在价格中的信息。中央计划者之所以失败，是因为它们在管理经济时把市场上那只看不见的手缚起来了。 ###原理七：政府有时可以改善市场结果 政府干预经济的原因：促进效率和促进平等。政策的目标不是做大经济蛋糕二十改变蛋糕的分割。 ​ 看不见的手通常会使市场有效地配置资源。但是，由于各种原因，有时看不见的手不起作用。经济学家用市场失灵这个词来指市场本身不能有效配置资源的情况。市场失灵的一个可能原因是外部性。外部性是一个人的行动对旁观者福利的影响。污染是一个典型的例子。如果一家化工厂并不承担它排放烟尘的全部成本，它就会大量排放。在这种情况下，政府就可以通过环境保护来增加经济福利。 市场失灵的另一个可能原因是市场势力。市场势力是指一个人（或一小群人）不适当地影响市场价格的能力。例如，假设镇里的每个人都需要水，但只有一口井。这口井的所有者对水的销售就有市场势力——在这种情况下，它是一个垄断者。这口井的所有者并不受残酷竞争的限制，而正常情况下看不见的手正是以这种竞争来制约个人的私利。你将会知道，在这种情况下，规定垄断者收取的价格有可能提高经济效率。 列出并简要解释关于经济相互交易的三个原理 原理八： 一国的生活水平取决于它生产物品与劳务的能力​ 用什么来解释各国和不同时期中生活水平的巨大差别呢？答案之简单出人意料之外。几乎所有生活水平的变动都可以归因于各国生产率的差别——这就是一个工人一小时所生产的物品与劳务量的差别。在那些每单位时间工人能生产大量物品与劳务的国家，大多数人享有高生活水平；在那些工人生产率低的国家，大多数人必须忍受贫困的生活。同样，一国的生产率增长率决定了平均收入增长率。 ​ 生产率和生活水平之间的基本关系是简单的，但它的意义是深远的。如果生产率是生活水平的首要决定因素，那么，其他解释的重要性就应该是次要的。例如，有人想把上个世纪美国工人生活水平的提高归功于工会或最低工资法。但美国工人的真正英雄行为是他们提高了生产率。另一个例子是，一些评论家声称，美国近年来收入增长放慢是由于日本和其他国家日益激烈的竞争。但真正的敌人不是来自国外的竞争，而是美国生产率增长的放慢。 ​ 生产率与生活水平之间的关系对公共政策也有深远的含义。在考虑任何一项政策如何影响生活水平时，关键问题是政策如何影响我们生产物品与劳务的能力。为了提高生活水平，决策者需要通过让工人受到良好的教育，拥有生产物品与劳务需要的工具，以及得到获取最好技术的机会。 原理九： 当政府发行了过多的货币之后，物价上涨货币发行量超量，会导致通货膨胀 原理十：社会面临通货膨胀与失业之间的短期交替关系交替关系称为菲利普斯曲线。 由于价格是粘性的，各种政府政策都具有不同于长期效应的短期效应。例如，当政府减少货币量时，它就减少了人们支出的数量。较低的支出与居高不下的价格结合在一起就减少了企业销售的物品与劳务量。销售量减少又引起企业解雇工人。因此，对价格的变动作出完全的调整之前，货币量减少就暂时增加了失业。 列出并简要解释描述整体经济如何运行的三个原理。 币值稳定–交换的媒介 币值不稳定–投机的工具","categories":[],"tags":[{"name":"经济学，毛概","slug":"经济学，毛概","permalink":"http://yoursite.com/tags/经济学，毛概/"}]},{"title":"单周期CPU设计笔记和总结","slug":"单周期CPU设计笔记和总结","date":"2018-05-11T01:19:49.811Z","updated":"2018-05-15T03:40:27.772Z","comments":true,"path":"2018/05/11/单周期CPU设计笔记和总结/","link":"","permalink":"http://yoursite.com/2018/05/11/单周期CPU设计笔记和总结/","excerpt":"","text":"单周期CPU设计与实现（实验)每一个指令都在一个时钟周期内完成，称为单周期CPU。 单周期CPU数据通路图该图描述的是CPU中数据，如何在 PC时钟，指令存储器，寄存器组，控制单元，ALU，数据存储器和控制器中如何传送的过程。 MIPS指令的三种格式 R类型 I类型 J类型 算术运算指令 逻辑运算指令 移位指令 比较指令 存储器读写指令 分支指令 跳转指令 停机指令 CPU学习笔记 - 5/15 ###逻辑设计 组合单元— 操作单元 如门 ALU 状态单元— 存储单元，如存储器，寄存器 注： 状态单元需要两个输入（时钟信号值和输入数据值） 一个输出（输出数据值）。 建立数据通路部件认识： PC程序计数器：存储当前指令的地址，每执行完一条指令，PC+4。（一个指令4个字节） 指令存储器： 数据存储器： 寄存器堆： ALU: 加法器： MIPS指令特点","categories":[],"tags":[{"name":"计组实验 CPU","slug":"计组实验-CPU","permalink":"http://yoursite.com/tags/计组实验-CPU/"}]},{"title":"知乎问答——如何用互联网思维卖馒头","slug":"知乎问答_如何用互联网思维买馒头","date":"2018-05-10T15:54:46.670Z","updated":"2018-05-11T01:14:52.303Z","comments":true,"path":"2018/05/10/知乎问答_如何用互联网思维买馒头/","link":"","permalink":"http://yoursite.com/2018/05/10/知乎问答_如何用互联网思维买馒头/","excerpt":"","text":"回答一一、规划 slogan：做中国好馒头、做好中国馒头 使命：让全中国人重新吃上安心馒头 愿景：成为世界顶级的馒头品牌 广告语：这一口，谁不爱 目标人群：新中产阶级 新中产消费观的最大特征：相较于价格，他们在意质量，对于高质量的商品和服务，他们愿意为之付出更高的代价。较高的收入与体面的工作给中产带来片刻的欣慰，但不安与焦虑才是中产光鲜外表下最戳心的痛点，消费升级正是他们面对这种焦虑选择的解决方案。 二、设计 1.品牌 品牌要能让人产生联想，要好记，比如：”真馒头” 2.设计 包装要讲究，但重点是一定要去德国买一个红点奖。 每个包装上，还必须有扎心的文案，比如: 我们拼尽全力，不是为了活成别人想要的模样 你只来了一下子，却改变了我一辈子 我有馒头，你有故事吗? 3.产品 要秉承匠心精神，只做单一产品–真•葱花馒头，将一款产品做到极致。 但是可以根据用户人群推出专属款，比如 有助记忆力的儿童款 提高睡眠质量的老人款 4.门店 不同类型的门店来满足用户多元化的场景需求，包括满足用户线下社交需求的旗舰店，满足亲子活动的DIY体验店，以及快速自提、服务商务人群的快取店，满足客户外送需求的外卖厨房店。通过差异化的门店布局，实现对消费者日常生活全方位覆盖。 5.定价 统一价19.9元！！没有足够的利润空间，618、双11、双12你拿什么打折？ 三、营销 1.讲故事 馒头的面全部来自北纬36°黄金优麦区种植的8848号小麦，纯手工脱粒。 蒸馒头的水，选自长白山矿物质水，再经过36道工艺人工萃取。 创新思维碰撞传统手工技艺，再造中国馒头新未来。 2.讲情怀 创始人211名校毕业后，放弃BTA百万年薪自主创业；尝遍了全国各地大街小巷所有的馒头，拜访数十位隐居的大师，经历了同事朋友的嘲讽、女朋友的离等非常人所能经历的磨难后，终于发明了拥有独特、唯一口味的”真馒头”。 3.软文推广 《震惊！男人吃了沉默，女人吃了流泪》 《感动！一个馒头如果没有情怀，那它和面粉有什么区别》 《刚刚！人人都在疯抢这款馒头》 … 4.造气氛 找很多人来回排队，不用多讲，这是网红店的标配。但是排队的人员组成还是要有讲究的，需要有学生、青年、白领、中年人，而且不能一起到，要分批到。 5.制造热点事件 哭诉鹅厂抄袭商业模式 喊话某互联网大佬，打赌3年后比营业额 6.社会化传播 赞助绝地求生，新增能量馒头，吃一个血条全满！ 雇人拿着馒头去starbuck、costa，让咖啡、苹果笔记本、馒头成为新一代的装B三件套。 抢在韩国人前为馒头申遗！ 7.微微一抖 微博：每天去抢杜蕾斯、回忆专用小马甲的沙发，设置转发有奖活动； 微信公众号：每天深夜10点，推送一条荷尔蒙满满的语音鸡汤，一定要煽情！ 抖音：做一个卡通吉祥物，天天耍贱，卖萌，用户爱看什么拍什么。 8.饥饿营销 每家门店每天限量8888个，卖完即止。第二天的馒头需要提前预约。 9.裂变营销 给好友免费送馒头，他吃你也吃。 10.社群运营 建立真馒头的粉丝群，收集种子用户的建议反馈，经常与粉丝互动。邀请5个人进群可免费领取一个馒头，群成员可享受新品内测试吃福利。 11.APP运营 开启步数兑换优惠券功能，倡导绿色出行； 消费有积分，积分可以浇水种小麦，小麦长成后可以直接磨成面，寄给用户。 增加交友功能，注册必须上传吃馒头的自拍照，可以查看5公里内异性用户的照片，但是必须相互点赞，才能加好友聊天。 12.会员体系 充值5000黄金会员，享8折优惠；充值10000白金会员，全部5折，生日赠送定制版馒头。 13.配送模式 可以在APP或公众号上自助完成下单，下单时可以选择温度、辣度等，制作好了系统会发提示，凭二维码领取，节约排队时间；如果选择外送，在已经开通的外送区域15分钟左右送到，超过30分钟免费。 四、实现盈利 炒作互联网新零售+馒头的成功之道，然后花钱发一堆新闻通稿，进行大量商业路演，约见各类ＶＰ，重点来了： 想要快速套现的可以选择阿里的投资，2年内一定会被全资收购； 想要上市的优选搜狐的投资，直接搭建境外架构，3年后妥妥纳斯达克敲钟。 最后你们一定会问，你谁啊，靠不靠谱啊？ “我，秦始皇，打钱！” 回答二一、规划 slogan：做中国好馒头、做好中国馒头 使命：让全中国人重新吃上安心馒头 愿景：成为世界顶级的馒头品牌 广告语：这一口，谁不爱 目标人群：新中产阶级 新中产消费观的最大特征：相较于价格，他们在意质量，对于高质量的商品和服务，他们愿意为之付出更高的代价。较高的收入与体面的工作给中产带来片刻的欣慰，但不安与焦虑才是中产光鲜外表下最戳心的痛点，消费升级正是他们面对这种焦虑选择的解决方案。 二、设计 1.品牌 品牌要能让人产生联想，要好记，比如：”真馒头” 2.设计 包装要讲究，但重点是一定要去德国买一个红点奖。 每个包装上，还必须有扎心的文案，比如: 我们拼尽全力，不是为了活成别人想要的模样 你只来了一下子，却改变了我一辈子 我有馒头，你有故事吗? 3.产品 要秉承匠心精神，只做单一产品–真•葱花馒头，将一款产品做到极致。 但是可以根据用户人群推出专属款，比如 有助记忆力的儿童款 提高睡眠质量的老人款 4.门店 不同类型的门店来满足用户多元化的场景需求，包括满足用户线下社交需求的旗舰店，满足亲子活动的DIY体验店，以及快速自提、服务商务人群的快取店，满足客户外送需求的外卖厨房店。通过差异化的门店布局，实现对消费者日常生活全方位覆盖。 5.定价 统一价19.9元！！没有足够的利润空间，618、双11、双12你拿什么打折？ 三、营销 1.讲故事 馒头的面全部来自北纬36°黄金优麦区种植的8848号小麦，纯手工脱粒。 蒸馒头的水，选自长白山矿物质水，再经过36道工艺人工萃取。 创新思维碰撞传统手工技艺，再造中国馒头新未来。 2.讲情怀 创始人211名校毕业后，放弃BTA百万年薪自主创业；尝遍了全国各地大街小巷所有的馒头，拜访数十位隐居的大师，经历了同事朋友的嘲讽、女朋友的离等非常人所能经历的磨难后，终于发明了拥有独特、唯一口味的”真馒头”。 3.软文推广 《震惊！男人吃了沉默，女人吃了流泪》 《感动！一个馒头如果没有情怀，那它和面粉有什么区别》 《刚刚！人人都在疯抢这款馒头》 … 4.造气氛 找很多人来回排队，不用多讲，这是网红店的标配。但是排队的人员组成还是要有讲究的，需要有学生、青年、白领、中年人，而且不能一起到，要分批到。 5.制造热点事件 哭诉鹅厂抄袭商业模式 喊话某互联网大佬，打赌3年后比营业额 6.社会化传播 赞助绝地求生，新增能量馒头，吃一个血条全满！ 雇人拿着馒头去starbuck、costa，让咖啡、苹果笔记本、馒头成为新一代的装B三件套。 抢在韩国人前为馒头申遗！ 7.微微一抖 微博：每天去抢杜蕾斯、回忆专用小马甲的沙发，设置转发有奖活动； 微信公众号：每天深夜10点，推送一条荷尔蒙满满的语音鸡汤，一定要煽情！ 抖音：做一个卡通吉祥物，天天耍贱，卖萌，用户爱看什么拍什么。 8.饥饿营销 每家门店每天限量8888个，卖完即止。第二天的馒头需要提前预约。 9.裂变营销 给好友免费送馒头，他吃你也吃。 10.社群运营 建立真馒头的粉丝群，收集种子用户的建议反馈，经常与粉丝互动。邀请5个人进群可免费领取一个馒头，群成员可享受新品内测试吃福利。 11.APP运营 开启步数兑换优惠券功能，倡导绿色出行； 消费有积分，积分可以浇水种小麦，小麦长成后可以直接磨成面，寄给用户。 增加交友功能，注册必须上传吃馒头的自拍照，可以查看5公里内异性用户的照片，但是必须相互点赞，才能加好友聊天。 12.会员体系 充值5000黄金会员，享8折优惠；充值10000白金会员，全部5折，生日赠送定制版馒头。 13.配送模式 可以在APP或公众号上自助完成下单，下单时可以选择温度、辣度等，制作好了系统会发提示，凭二维码领取，节约排队时间；如果选择外送，在已经开通的外送区域15分钟左右送到，超过30分钟免费。 四、实现盈利 炒作互联网新零售+馒头的成功之道，然后花钱发一堆新闻通稿，进行大量商业路演，约见各类ＶＰ，重点来了： 想要快速套现的可以选择阿里的投资，2年内一定会被全资收购； 想要上市的优选搜狐的投资，直接搭建境外架构，3年后妥妥纳斯达克敲钟。 最后你们一定会问，你谁啊，靠不靠谱啊？ “我，秦始皇，打钱！”","categories":[],"tags":[{"name":"互联网思维","slug":"互联网思维","permalink":"http://yoursite.com/tags/互联网思维/"}]},{"title":"cocos2d学习丨坑和解决办法","slug":"Q&A_cocos2d","date":"2018-05-09T15:35:55.384Z","updated":"2018-05-19T03:20:33.114Z","comments":true,"path":"2018/05/09/Q&A_cocos2d/","link":"","permalink":"http://yoursite.com/2018/05/09/Q&A_cocos2d/","excerpt":"","text":"cocos2d 使用遇到的问题和解决办法[TOC] Q 1： 如何解决中文乱码？A1: 直接看正确的示例代码，杂七杂八的代码太多，跟上版本的是下面这个 xml文件 1234&lt;dict&gt; &lt;key&gt;HelloWorldStringkey&gt; &lt;string&gt;你好，世界string&gt; dict&gt; 解析xml文件的代码。需要注意按键值获取中文内容保存为char*指针后，用于创建的label类是CCLabelTTF，而不是Label. 1234567891011121314151617//利用CCDictionary来读取xml CCDictionary *strings = CCDictionary::createWithContentsOfFile(\"strings.xml\");//载入资源文件夹的strings.xml //读取HelloWorld键中的值objectForKey根据key，获取对应的string const char *HelloWorld = ((CCString*)strings-&gt;objectForKey(\"HelloWorldString\"))-&gt;m_sString.c_str(); //获取屏幕的尺寸、位置信息等 CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize(); //乱码文字 CCLabelTTF *label0 = CCLabelTTF::create(\"你好，世界\",\"arial\",72); label0-&gt;setPosition(ccp(visibleSize.width/2,2*visibleSize.height/3)); this-&gt;addChild(label0); //正常中文 CCLabelTTF *label1 = CCLabelTTF::create(HelloWorld,\"arial\",72); label1-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/3)); this-&gt;addChild(label1); Q2：xml文件资源（字体,图片等等）的放置的正确位置？A2：xml文件需要放在整个顶级项目文件里头的resources文件夹，而不是放在win32项目的resource…..坑。。具体可以看初始代码引用字体文件的路径。 Q3： 一开始打开项目文件发现文件不可用或者项目文件被卸载？A3：文件路径被改变，重新解压cocos安装包，重新安装。并且存放路径不能出现中文。 Q4: 编译时出现 libbox.lib不是有效的win32程序？A4：需要将hellococos项目设置为启动项。 Q5：当出现许多.h 文件不可用的时候？A5：重定解决方案目标 Q6:本地坐标系和世界坐标系如何互换计算1234CCPoint p1 = sprite2-&gt;convertToNodeSpace(sprite1-&gt;getPosition());CCPoint p2 = sprite2-&gt;convertToWorldSpace(sprite1-&gt;getPosition());CCPoint p3 = sprite2-&gt;convertToNodeSpaceAR(sprite1-&gt;getPosition());CCPoint p4 = sprite2-&gt;convertToWorldSpaceAR(sprite1-&gt;getPosition()); 计算方法都是用sprite1的坐标去加减sprite2的坐标，针对本地坐标系就用减法，针对世界坐标系就用加法。","categories":[],"tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"http://yoursite.com/tags/cocos2d/"}]},{"title":"流水线技术简介","slug":"流水线技术简介","date":"2018-05-08T03:16:47.859Z","updated":"2018-05-11T01:14:58.976Z","comments":true,"path":"2018/05/08/流水线技术简介/","link":"","permalink":"http://yoursite.com/2018/05/08/流水线技术简介/","excerpt":"","text":"[TOC] 流水线技术流水线基础概念​ • 指令的执行过程是，对每一条指令做取指令，分析指令，执行指令。 ​ • 取指–移码–执行–访存–写回 ​ • 流水执行是，取指令时间上一条指令的执行阶段，执行指令阶段可能是下一条指令的取指令阶段。 ​ • 抽象概念：把一个重复过程分为若干个子过程，每个子部件由专门的部件实现。多个处理过程在时间上错开错开，依次通过各个部件。 ​ • 流水的段：每个子过程。 ​ • 流水的深度：子过程的个数。例如： 入-取指令-指令译码-执行-存结果-出–》浮点加法：入-求阶差-对阶-尾数相加-规格化-出 ​ • 流水时间是每一个段时间的总和，需要注意的是通过一个段的时间最长的段为流水线设计的瓶颈。流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流。时间长的段将成为流水线的瓶颈 ​ • 时空图：从时间和空间两个方面来描述指令流水执行 ​ • 流水线的性能指标–吞吐率。即单位时间内完成任务的数量或者输出结果的数 量。 ​ ​ 相关​ • 数据相关 ​ • 名相关 ​ ○ 输出相关–写写操作 ​ ○ 反相关–先读后写，读的名和写的名一致 ​ • 控制相关 ​ ​ 每条指令访问读写的寄存器称为名 ​ 输出相关–写写操作，两条指令的 ​ 反相关—先读后写，读的名和写的名一致 ​ 换名技术 ​ 流水线冒险（冲突）​ 1. 结构冒险–硬件不支持多条指令在同一时间周期执行–重复，细分部件 ​ 2. 数据冒险–一条指令需要等待另外一条指令完成而造成流水线暂停。（所以设计的段的时候时间应尽量保持一致–前推旁路–写后读冲突–在写入i之前，j先读取，会造成读取错误。 ​ 为避免数据等待的问题，在每个段之间设计了一个缓冲寄存器（也叫锁存器） ​ 3.控制冒险 （分支冒险）–决策依赖于另外一条指令的结果，但其他指令正在执行当中。","categories":[],"tags":[{"name":"计组理论","slug":"计组理论","permalink":"http://yoursite.com/tags/计组理论/"}]},{"title":"SQL用法总结 -- postgresql（持续更新中）","slug":"SQL 用法--postgresql","date":"2018-05-08T01:39:10.009Z","updated":"2018-05-19T03:14:06.454Z","comments":true,"path":"2018/05/08/SQL 用法--postgresql/","link":"","permalink":"http://yoursite.com/2018/05/08/SQL 用法--postgresql/","excerpt":"","text":"##SQL 用法–postgresql [TOC] 运算符https://www.postgresql.org/docs/9.1/static/functions-geometry.html 官方链接最全。 表格操作建表12345678CREATE TABLE users ( user_id INT AUTO_INCREMENT PRIMARY KEY, //声明主键 username VARCHAR(255) NOT NULL UNIQUE, //声明非空，唯一 password VARCHAR(255) NOT NULL FOREIGN KEY (user_id) REFERENCES projects (user_id) //声明 user_id为外键引用自表格projects); 改表123456ALTER TABLE table_nameADD new_colum data_type column_constraint [AFTER existing_column]; // 加列DROP COLUMN max_limit, //删除列MODIFY fee NUMERIC (10, 2) NOT NULL; //修改列约束 删表TRUNCATE table_name; // 将行清空，但表头依旧保留 DROP table table_name; //删除整个表格 PRIMARY KEY constraint UNIQUE constraint The number of constraints One Many NULL values Do not allow Allow 表的连接内连接–INNER JOIN两个表使用内连接，通过指定一个属性来匹配，若两个表的同一属性具有相同值，则保留在连接表中，其余不相等的行则消去。 图解 使用示例（内连接也可以连接多张表格） 12345SELECT A.nFROM AINNER JOIN B ON B.n = A.n;INNER JOIN C ON C.n = A.n; 全连接–FUll OUTER JOIN指定连接条件，属性值相同的行保留，但不重复，属性值不同的值保留，但存在某些为Null的情况。 用法示例 123SELECT column_listFROM AFULL OUTER JOIN B ON B.n = A.n; 左连接–LEFT JOIN对几个将要连接的表指定条件进行连接，属性匹配的时候，会保留左表所有属性，即便右表属性为NULL,但不会存在左表属性为NULL的情况。 代码示例： 12345SELECT A.nFROM ALEFT JOIN B ON B.n = A.n; 右连接–RIGHT JOIN和左连接相反，用法如下： 12345SELECT A.nFROM ALEFT JOIN B ON B.n = A.n; 交叉连接–CROSS JOIN看图就知道。。。交叉连接结果的表格是 两表行数相乘。需要指出的一点就是两个表相连不需要指定cross join。 12345SELECT column_listFROM A, B; 创建索引 PostgreSQL provides several index types: B-tree, Hash, GiST and GIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the CREATE INDEX command creates B-tree indexes, which fit the most common situations. 创建b_tree索引语法： create index index_name ON table_name(column_name) postgresql默认b树索引。官方描述如下： B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators: &lt; &lt;= = &gt;= &gt; Constructs equivalent to combinations of these operators, such as BETWEEN and IN , can also be implemented with a B-tree index search. Also, an IS NULL or IS NOT NULL condition on an index column can be used with a B-tree index. 上述说明b_tree在范围查询中比较有效，也可以用于顺序检索数据。 当查询条件为范围查询时(运算符是 &gt; &lt; &lt;= &gt;= = is null, is not null, between and ,in)，b_tree索引可以体现较为良好的性能。 创建hash索引语法： create index index_name on table_name using hash(column_name) 官方描述 Hash indexes can only handle simple equality comparisons. The query planner will consider using a hash index whenever an indexed column is involved in a comparison using the = operator. 上述说明，hash索引仅仅在处理简单的等值比较-(=) 中相对有效。 使用GiST索引(错误）语法： create index index_name on table_name using GiST（column_name) 官方描述 GiST indexes are not a single kind of index, but rather an infrastructure within which many different indexing strategies can be implemented. Accordingly, the particular operators with which a GiST index can be used vary depending on the indexing strategy (the operator class). As an example, the standard distribution of PostgreSQL includes GiST operator classes for several two-dimensional geometric data types, which support indexed queries using these operators: &lt;&lt; &amp;&lt; &amp;&gt; &gt;&gt; `&lt;&lt; ` `&amp;&lt; ` ` &amp;&gt;` ` &gt;&gt;` @&gt; &lt;@ ~= &amp;&amp; 上述描述可知，gist 不是单一类型的索引，实现了不同策略索引的基础结构。可以根据索引策略（运算符类）来采取不同的索引策略。 详见官方文档gist index 使用GIN索引gin索引能够用于优化级的最近邻查找。 GIN indexes are inverted indexes which can handle values that contain more than one key, arrays for example. Like GiST, GIN can support many different user-defined indexing strategies and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQLincludes GIN operator classes for one-dimensional arrays, which support indexed queries using these operators: &lt;@ @&gt; = &amp;&amp; 用法查看官方描述gin index. 分析效率 explain将explain(analyze)置于语句的开始，结果将返回语句执行效率有关的数值。 123456789101112explain （analyze） Select s_name, s_address, s_nationkey From table_a Where s_suppkey = 717;explain （analyze） Select s_name, s_address, s_nationkey From b_tree_a Where s_suppkey = 717;explain （analyze） Select s_name, s_address, s_nationkey From hash_a Where s_suppkey = 717; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126Click To Expand CodePostgreSQLThe following script creates the HR sample database structure in PostgreSQL.CREATE TABLE regions ( region_id SERIAL PRIMARY KEY, region_name CHARACTER VARYING (25));CREATE TABLE countries ( country_id CHARACTER (2) PRIMARY KEY, country_name CHARACTER VARYING (40), region_id INTEGER NOT NULL, FOREIGN KEY (region_id) REFERENCES regions (region_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE locations ( location_id SERIAL PRIMARY KEY, street_address CHARACTER VARYING (40), postal_code CHARACTER VARYING (12), city CHARACTER VARYING (30) NOT NULL, state_province CHARACTER VARYING (25), country_id CHARACTER (2) NOT NULL, FOREIGN KEY (country_id) REFERENCES countries (country_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE departments ( department_id SERIAL PRIMARY KEY, department_name CHARACTER VARYING (30) NOT NULL, location_id INTEGER, FOREIGN KEY (location_id) REFERENCES locations (location_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE jobs ( job_id SERIAL PRIMARY KEY, job_title CHARACTER VARYING (35) NOT NULL, min_salary NUMERIC (8, 2), max_salary NUMERIC (8, 2));CREATE TABLE employees ( employee_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (20), last_name CHARACTER VARYING (25) NOT NULL, email CHARACTER VARYING (100) NOT NULL, phone_number CHARACTER VARYING (20), hire_date DATE NOT NULL, job_id INTEGER NOT NULL, salary NUMERIC (8, 2) NOT NULL, manager_id INTEGER, department_id INTEGER, FOREIGN KEY (job_id) REFERENCES jobs (job_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (department_id) REFERENCES departments (department_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (manager_id) REFERENCES employees (employee_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE dependents ( dependent_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (50) NOT NULL, last_name CHARACTER VARYING (50) NOT NULL, relationship CHARACTER VARYING (25) NOT NULL, employee_id INTEGER NOT NULL, FOREIGN KEY (employee_id) REFERENCES employees (employee_id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE TABLE regions ( region_id SERIAL PRIMARY KEY, region_name CHARACTER VARYING (25)); CREATE TABLE countries ( country_id CHARACTER (2) PRIMARY KEY, country_name CHARACTER VARYING (40), region_id INTEGER NOT NULL, FOREIGN KEY (region_id) REFERENCES regions (region_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE locations ( location_id SERIAL PRIMARY KEY, street_address CHARACTER VARYING (40), postal_code CHARACTER VARYING (12), city CHARACTER VARYING (30) NOT NULL, state_province CHARACTER VARYING (25), country_id CHARACTER (2) NOT NULL, FOREIGN KEY (country_id) REFERENCES countries (country_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE departments ( department_id SERIAL PRIMARY KEY, department_name CHARACTER VARYING (30) NOT NULL, location_id INTEGER, FOREIGN KEY (location_id) REFERENCES locations (location_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE jobs ( job_id SERIAL PRIMARY KEY, job_title CHARACTER VARYING (35) NOT NULL, min_salary NUMERIC (8, 2), max_salary NUMERIC (8, 2)); CREATE TABLE employees ( employee_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (20), last_name CHARACTER VARYING (25) NOT NULL, email CHARACTER VARYING (100) NOT NULL, phone_number CHARACTER VARYING (20), hire_date DATE NOT NULL, job_id INTEGER NOT NULL, salary NUMERIC (8, 2) NOT NULL, manager_id INTEGER, department_id INTEGER, FOREIGN KEY (job_id) REFERENCES jobs (job_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (department_id) REFERENCES departments (department_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (manager_id) REFERENCES employees (employee_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE dependents ( dependent_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (50) NOT NULL, last_name CHARACTER VARYING (50) NOT NULL, relationship CHARACTER VARYING (25) NOT NULL, employee_id INTEGER NOT NULL, FOREIGN KEY (employee_id) REFERENCES employees (employee_id) ON DELETE CASCADE ON UPDATE CASCADE);","categories":[],"tags":[{"name":"数据库系统，postgresql","slug":"数据库系统，postgresql","permalink":"http://yoursite.com/tags/数据库系统，postgresql/"}]},{"title":"操作系统第五章之CPU调度算法（重点）","slug":"CPU调度算法","date":"2018-05-07T01:36:30.223Z","updated":"2018-05-07T16:16:04.340Z","comments":true,"path":"2018/05/07/CPU调度算法/","link":"","permalink":"http://yoursite.com/2018/05/07/CPU调度算法/","excerpt":"","text":"CPU调度算法 先到先服务 fcfs – CPU请求次序 缺点：FCFS 算法对于分时系统(每个用户需要定时地得到一定的CPU 时间)是特别麻烦的。允许一个进程保持CPU 时间过长将是个严重错误。 最短作业优先sjf – 平均等待时间最短 | 最优 存在抢占和非抢占 抢占（最短剩余时间优先）：由于CPU到达时间和CPU区间大小的差异，长作业可以优先处理，但出现短作业请求的时候，优先处理短作业 ​ 优先级调度 – fcfs sjf都是特殊的优先级调度 每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU 。具有相同优先级的进程按FCFS 顺序调度。 同样存在抢占调度的情况 问题：存在阻塞或饥饿– 存在进程一直处于等待状态 解决方法：老化– 等待时间越长，优先级提高 优先级可通过内部或外部方式来定义。内部定义优先级使用一些测量数据以计算进程优先级。例如，时间极限、内存要求、打开文件的数量和平均I/O 区间与平均CPU 区间之比都可以用于计算优先级。外部优先级是通过操作系统之外的准则来定义的，如进程重要性、用于支付使用计算机的费用类型和数量、赞助工作的单位、其他(通常为政治)因素。 ​ 轮转法调度 – rr ( round robin 为分时系统而设置的 平均等待时间较长，响应时间较长 定义较小的时间处理单元，时间片。时间片和周转时间有关，要考虑和上下文切换的时间比例 进程存储在一个fifo循环队列中 ​ 多级队列调度 多级队列 调度算法(multilevel queue scheduling algorithm) 将就绪队列分成多个独立队列(见图5.6) 。根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被永久地分配到一个队列。 根据进程的性质和属性对进程进行分组的方法，给不同的队列设立优先级。比如前台交互进程和后台批处理过程。前台交互进程较高。 每个队列可以采用不同的调度算法，前台交互需要等待时间较短的调度算法，通常选用rr调度，后台批处理可以选择fcfs,优先级调度算法。 缺点同样会产生阻塞的情况 队列之间必须有调度，通常采用固定优先级抢占调度。例如，前台队列可以比后台队列具有绝对的优先级。现在来研究一下具有5 个队列的多级队列调度算法的例子，按优先级来排列:①系统进程。②交互进程。③交互编辑进程。④批处理进程。⑤学生进程。 多级反馈队列调度 多级反馈队列调度算法(multilevel feedback queue scheduling algorithm) 允许进程在队列之间移动。主要思想是根据不同CPU 区间的特点以区分进程。如果进程使用过多CPU 时间，那么它会被转移到更低优先级队列。这种方案将νo 约束和交互进程留在更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。 通常，多级反馈队列调度程序可由下列参数来定义:.队列数量。· 每个队列的调度算法。· 用以确定何时升级到更高优先级队列的方法。. 用以确定何时降级到更低优先级队列的方法。· 用以确定进程在需要服务时应进入哪个队列的方法。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"计算机组成原理课堂笔记","slug":"第四章CPU--计组课堂笔记-01","date":"2018-05-03T00:53:04.206Z","updated":"2018-05-19T03:27:44.291Z","comments":true,"path":"2018/05/03/第四章CPU--计组课堂笔记-01/","link":"","permalink":"http://yoursite.com/2018/05/03/第四章CPU--计组课堂笔记-01/","excerpt":"","text":"[TOC] CPU基础概念CPU功能： 指令控制，操作控制，时间控制，数据加工 CPU控制方式：同步控制，异步控制，联合控制 CPU指令周期：取值时间+执行时间 CPU周期：机器周期，总线周期。 CPU中断逻辑中断基础概念 暂停当前程序的执行，转而去执行其他程序，执行完毕之后，重新恢复中断程序的执行 中断源： 人为设置的中断，程序性事故, 硬件故障，外部事件（比如断电） 中断分类：可屏蔽中断和不可屏蔽中断；内部中断和外部中断；软中断和硬中断。 根据CPU是否可以采取响应判断来分类：可屏蔽中断，不可屏蔽中断。 电源断电，CPU不可禁止响应，另外可以根据中断源是否被屏蔽来确定是否给予响应。 ​ ####中断系统需要解决的7个问题： 中断如何向CPU提出诉求 多个中断同时发生请求，CPU如何优先处理？ 硬件排队 软件轮询 CPU响应中断的条件，时间，方式。 中断服务程序入口地址的查找：硬件向量法和软件查询法 中断响应的条件：中断允许触发器必须为1 中断响应时间：当前指令周期结束。（而不是指令执行结束） （2， 3 为中断响应的充分必要条件） CPU响应中断后如何保护现场 中断响应结束之后如何阻止源程序的执行转入中断服务程序的入口地址 中断处理结束后，CPU如何恢复现场 中断处理结束过程中出现了新的中断请求,CPU该如何处理 处理办法 ：中断处理系统中配置响应的软件和硬件 中断屏蔽技术 实现多重中断的条件： 提前设置开中断指令 优先级高的中断源有权屏蔽优先级别低的中断源 中断屏蔽的结果 屏蔽触发器与屏蔽字 改变中断优先登记以及运行轨迹的变化 中断屏蔽字的设置 ​ 多重中断的断点保护 中断响应轨迹图 设置中断屏蔽字改变中断响应优先级 发生多重中断时中断响应逻辑类似于CPU调度中的优先级调度。 引起cpu中断的各种因素（称为中断源） 人为设置的中断（访管指令） 程序性事故 硬件故障 I/O设备 外部事件","categories":[],"tags":[{"name":"计组理论 CPU","slug":"计组理论-CPU","permalink":"http://yoursite.com/tags/计组理论-CPU/"}]},{"title":"关系数据库设计理论简介","slug":"关系数据库设计理论","date":"2018-05-02T09:28:16.232Z","updated":"2018-05-14T08:28:31.577Z","comments":true,"path":"2018/05/02/关系数据库设计理论/","link":"","permalink":"http://yoursite.com/2018/05/02/关系数据库设计理论/","excerpt":"","text":"[TOC] 函数依赖 X→Y，表示Y依赖于X； X→Y，且Y→X不成立，Y→Z，则X→Z，表示Z传递依赖于X。 函数依赖性质 自反性 传递性 增广性 A → C 可以推出 AB → BC 函数依赖的种类（完全函数依赖：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y非函数依赖于X的子集，则称Y完全函数依赖于X。X f &gt;Y）—&gt; Y依赖于X,但未必都依赖X的子集。 （部分函数依赖：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y函数依赖于X的子集） （函数依赖：某个属性集决定另一个属性集时，例如学生学号属性集Sno决定学生姓名属性集Sname，称Sname函数依赖于Sname ） （平凡函数依赖：Y函数依赖于X,并且Y包含于X，例如（Sno）-&gt;(Sno)、（Sno、Sname）-&gt;（Sno）） （非平凡函数依赖：Y函数依赖于X,并且Y不包含于X,例如(Sno,Sname）-&gt;（Ssex）） 键候选键： 能够唯一表示一个元组，且不含多属性超键： 是指能够唯一表示一个元组的属性集主属性：表示候选键中的属性非主属性：不包含在主键中的属性 判断主键的方法 ：若属性集为{ A , B, C}，A+ = ABC。 则A为主键。（属性闭包判断法） 范式 Normal Forms（1）第一范式1NF：关系中的所以属性值都是不可分割的原子值；（2）第二范式2NF：如果关系是1NF，且每个非主属性都完全依赖于候选键；（3）第三范式3NF：如果关系是1NF，且每个非主属性都不传递依赖于候选键；（4）鲍依斯-科得(巴斯)范式BCNF范式：如果关系是1NF，且每个属性都不传递依赖于候选键。 BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。 属性闭包定义：闭包就是由一个属性直接或间接推导出的所有属性的集合。 表示：B的闭包用B+表示。 计算：关系R的属性集X的闭包的步骤如下： 设最终将成为闭包的属性集是Y，把Y初始化为X； . 检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将 其加入到Y中； 重复第二步，直到没有属性可以添加到属性集Y中为止。 最后得到的Y就是X＋ 举例： 例1： R = {A,B,C,D,E} ​ F = {B→CD， D→E, B→A, E→C， AD→B } ​ 则 B+ = B ; B+ = BCD; B+ = BCDA； B+ = BCDAE。（推导过程是属性依赖传递的过程。 ​ 所以最终B+ 包含了R中所有属性。 故B is a key for R。 例2： 有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)闭包。 (1) 令X={AE}，X(0)=AE (2)在F中寻找尚未使用过的左边是AE的子集的函数依赖，结果是: A→D， E→C；所以 X(1)=X(0)DC=ACDE， 显然 X(1)≠X(0). (3) 在F中寻找尚未使用过的左边是ACDE的子集的函数依赖， 结果是: CD→I；所以 X(2)=X(1)I=ACDEI。虽然X（2）≠X(1)，但F中寻找尚未使用过函数依赖的左边已经没有X（2）的子集，所以不必再计算下去，即(AE)+=ACDEI。 例3：f={a-&gt;b，b-&gt;c，a-&gt;d，e-&gt;f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d} 关系模式分解关系模式分解必须遵守两个准则 (1)无损联接性：信息不失真（不增减信息）。 (2)函数依赖保持性：不破坏属性间存在的依赖关系 无损连接分解R的无损分解为X Y，那么 x∩y →x 或者 x∩y → y. ####Dependency Preserving Decomposition 依赖保持分解 关系模式R&lt;U,F&gt;的分解是指R为它的一组子集 ρ={R1&lt;U1,F1&gt;, R2&lt;U2,F2&gt;,…, Rk&lt;Uk,Fk&gt;}所代替的过程。 其中U=U1∪U2∪…∪k ,并且没有Ui≤Uj(表Ui包含于Uj，1≤i,j≤k), Fi是F在Ui上的投影，即Fi={X→Y∈F+∧XY≤Ui}(表XY包含于Ui）。 描述：R被分解为 i个关系子集 Ri。Fi为每个子集的函数依赖投影。 计算函数依赖fi保持的方法就是：Fi∪Fj 推出 fi成立，其中Fi Fj的计算从自身属性和原来函数依赖推导得来。 模式分解是独立保持的条件就是，所有函数依赖Fi的投影的并集的闭包 = F的闭包 思考： 可否是Fi的闭包的并集 = F的闭包？ 回答：不可以，因为每个子集的函数依赖Fi，可能产生跨子集的函数依赖，先求Fi的闭包会产生不完整的闭包关系。 BCNF分解BCNF的要求：函数依赖要么平凡，函数依赖的左侧是超键 如果X→Y违反BCNF, 分解R 为R-Y 和XY。 第三范式第三范式的条件： 平凡依赖 x 属于超键 A属于候选键 部分依赖 传递依赖 补充知识点自然连接在连接运算当中，一种最常用的连接是自然连接。如果关系R与S具有相同的属性组B，且该属性组的值相等时的连接称为自然连接，结果关系的属性集合为R的属性并上S减去属性B的属性集合。 参考的文章 函数依赖集闭包、属性集闭包、超键、候选键和最小函数依赖集 四种范式的实例 函数依赖不懂看这里","categories":[],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"http://yoursite.com/tags/数据库理论/"}]},{"title":"ant,junit,vim,java","slug":"Leanring_report-ant-junit-vim-java","date":"2018-05-01T08:35:48.000Z","updated":"2018-05-03T00:55:37.923Z","comments":true,"path":"2018/05/01/Leanring_report-ant-junit-vim-java/","link":"","permalink":"http://yoursite.com/2018/05/01/Leanring_report-ant-junit-vim-java/","excerpt":"","text":"编辑器之神–VimVim简介Vim是一款上古编辑器，被广大程序员成为编辑器之神，这与之强大的编辑功能和编辑效率是分不开的。和Emace一样都在代码行业享有盛誉。vim最为重要的一点就是一切操作几乎可以舍弃鼠标，熟悉了vim命令的话，光靠键盘指令可以使开发效率迅速提高。 Vim的安装Linux下在Ubuntu平台下控制台敲入下列指令即可自动安装。 sudo apt-get install vim Windows下去官网 直接下载使用。 Vim常用指令和教程首先值得注意的一点就是其实vim是自带教程的Vimtutor,s使用方法是linux下输入命令vimtutor,即可开启教程，这属于官方教程， 最为详细，没有之一。 在这里介绍一些常用的vim命令，有利于快速上手vim。 1. 创建或打开文件 vim filename vim helloworld.java 2.添加内容一开始进入处于正常模式在编辑窗口直接输入i,a,o等字符可以进入输入模式，可以在屏幕下方看到insert单词。按左上角Esc键可以回到正常模式，使用各种方便的指令。以下指令均在正常模式下进行。 3.删除内容dd可以删除光标所在的一整行。 ndd可以删除光标以下的n行 4. 复制内容yy可以复制光标所在行的字符nyy可以复制光标以下的n行字符 5.粘贴内容p/P作用时粘贴字符，小写p将已复制的字符粘贴到光标以下，大写P将字符粘贴到光标以上。 6. 撤销内容撤销指令使用u,类似于windows上的ctrl z`。 7. 保存文件先进入正常模式Esc，然后输入:。然后输入： q 离开vim w 保存内容 wq 保存内容并离开vim,回到命令行 其他还有许多可以提高效率的指令在这里就不多赘述啦。 ​ Java知识入门###初探java 从hello world入门, 初步体会java这一门面向对象编程语言。在HelloWorld.java文件中键入以下代码。（注意文件名称必须和类名一致） 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 其中用到的编译指令是 javac HelloWorld.java 命令行没有弹出其他消息，即为编译成功。 执行指令是 java HelloWorld 这里用到两个重要指令javac java ，分别是编译和执行指令。 ###基础知识 由于已经学习过C++，java语言在一定程度上和C++是类似的，所以在Java入门学习上可以直接跳过基础语法，对象和类，基本数据类型，运算符，循环结构，分支结构。 Java面向对象java继承java继承的概念和C++类似，同样是定义一个父类，然后定义一个子类，来继承父类的属性，和C++不同的是，java用关键字extends 来表示继承关系。继承格式是 1234567class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; ####继承的特性 子类拥有父类非private的属性，方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。 ​ ####继承的关键字 关键字 作用 extends 单一继承 implements 继承多个父类 super 实现对父类父类成员的访问，引用父类 this 指向自己的引用 final 将自身定义为不可继承的类 java重写和重载重写#####重写含义 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。。 重写方法的原则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 代码实例1234567891011121314151617181920class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 运行的结果是 狗可以跑和走 可以看到在Dog类中重写了move()方法，传入的参数和返回类型和原来父类的方法一致，但内部代码可以修改。 ####重载 #####重载含义 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 重载的规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 代码实例1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println(\"test1\"); return 1; &#125; public void test(int a)&#123; System.out.println(\"test2\"); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println(\"test3\"); return \"returntest3\"; &#125; public String test(String s,int a)&#123; System.out.println(\"test4\"); return \"returntest4\"; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); &#125;&#125; 运行结果是 test1 test2 test3 test4 从运行结果看，调用的传参不同的函数顺序执行。 多态多态就是对象多种表现形式的体现。 #####多态存在的三个必要条件 继承 重写 父类引用指向子类对象 这里提供一份代码以便理解。大意就是一个抽象父类声明但不定义一个方法，在其他子类中可以重写这个方法。 123456789101112131415161718192021abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; public void work() &#123; System.out.println(\"抓老鼠\"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; public void work() &#123; System.out.println(\"看家\"); &#125; &#125; ###java组件部分设计 Swing在本次实训实验中利用了Swing这个java的GUI工具包，以实现一个简单的计算器。其中的主要用途是引用这些包的相关控件，控件的相关接口，同时给这些控件注册事件，建立事件处理逻辑。 介绍控件，首先应提到JComponet 。 JComponent Swing 的整个可视组件库的基础构造块是 JComponent。它是所有组件的父类。它是一个抽象类，所以不能创建 JComponent，但是作为类层次结构的结果，从字面意义来说它包含了数百个函数，Swing 中的每个组件都可以使用这些函数。 注意： 每一个控件都是一个类，具有许多接口函数，在eclipes这个IDE上可以轻松获取。使用方法：鼠标移动到某一个控件类名，按ctrl键点击类名，即可弹出这个控件类里头详细的函数定义。 常用的控件集合 控件 用途 JLabel 用作文本描述 JButton 按钮 JFrame 窗口 JPanel 控件容器 JTextField 文本输入框 JCheckBox 确认框 GridLayout 生成网格状的布局 Tips: 任何一个控件都有Add()的方法，意味着每一个控件都可以添加到另外一个控件里。 注册事件的方法以下以button为例，进行两种常用方式的注册。 方法1 匿名内部类实现123456button.addActionListener( new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"你按了按钮一\"); &#125; &#125;); //调用监听函数并定义监听事件 方法2 利用一般内部类实现1234567button.addActionListener(new Button2ActionListener()); private class Button1ActionListener implements ActionListener&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"你按了按钮一\"); &#125; &#125; //将事件处理为一个类事件 用了以上的基础知识就可以解决一个简单计算器的实现啦。 Junit 学习和使用###Junit是什么 JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。 JUnit提供： 断言测试预期结果。 测试功能共享通用的测试数据。 测试套件轻松地组织和运行测试。 图形和文本测试运行。 JUnit用于测试： 整个对象 对象的一部分 - 交互的方法或一些方法 几个对象之间的互动(交互) ​ ###JUnit的特点 JUnit是用于编写和运行测试的开源框架。 提供了注释，以确定测试方法。 提供断言测试预期结果。 提供了测试运行的运行测试。 JUnit测试让您可以更快地编写代码，提高质量 JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。 JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。 JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。 Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。 注解 描述 @Testpublic void method() 测试注释指示该公共无效方法它所附着可以作为一个测试用例。 @Beforepublic void method() Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。 @BeforeClasspublic static void method() BeforeClass注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。 @Afterpublic void method() After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等) @AfterClasspublic static void method() 当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于BeforeClass)的方法必须定义为静态。 @Ignorepublic static void method() 当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为@Ignore的方法将不被执行。","categories":[],"tags":[{"name":"编程软件 vim java","slug":"编程软件-vim-java","permalink":"http://yoursite.com/tags/编程软件-vim-java/"}]},{"title":"Verilog 设计初步","slug":"Verilog设计初步","date":"2018-04-29T16:37:36.125Z","updated":"2018-05-03T00:56:27.052Z","comments":true,"path":"2018/04/30/Verilog设计初步/","link":"","permalink":"http://yoursite.com/2018/04/30/Verilog设计初步/","excerpt":"","text":"Verilog设计初步##Verilog 代码模板 1234567891011121314151617181920212223242526//语句关键字字母都为小写字母，大小写敏感//硬件思维来写代码//命名不能以数字开头module &lt;顶层模块名&gt; (输入输出端口列表) //定义输入输出端口列表 output 输出端口列表； //输出端口生声明 input 输入端口列表； //输入输出端口生命 /*定义数据类型，功能定义，函数实现*/ reg 信号名； //逻辑功能定义 assign&lt;结果信号名&gt; = &lt;表达式&gt;; //用always块描述逻辑功能 always @(&lt;敏感信号&gt;) begin //过程赋值运算 //语句，if else while task end //调用其他模块 &lt;调用模块名module_name&gt;&lt;例化模块名&gt;(&lt;端口列表&gt;)； //门元件例化 门元件关键字&lt;例化门元件名&gt;(&lt;端口列表port_list&gt;);endmodule 四位选择器 123456789module mux4_1(out,in0, in1, in2,in4,sel); output out; input in0,in1,in2,in3; input[1:0] reg out; always @（in0 or in1 or in2 or in3 or sel) begin case(sel) 数据类型及运算符 整数类型 构成是：字符宽度+进制+数值。 例如：2’0xd5; 宽度为2的十六进制d5。 逻辑类型 高低电平 1 0，电路里体现为电压的区间 x：未知 z: 高阻 net类型 常用的是wire。用法是 wire[7:0] databus。 //databus宽度8 寄存器类型 reg integer time real realtime parameter参数 用来定义符号常量。 parameter sel = 8’ha3。 向量类型 逻辑运算符 位运算符 三目运算 位拼接运算符 下例采用数据流方式描述1位全加器。 在本例中，有两个连续赋值语句。这些赋值语句是并发的，与其书写的顺序无关。只要连续赋值语句右端表达式中操作数的值变化(即有事件发生), 连续赋值语句即被执行。如果A变化，则两个连续赋值都被计算，即同时对右端表达式求值，并将结果赋给左端目标。 语句 initial always @（敏感信号） @ (posedge clk) 上升沿 @ (negedge clk) 下降沿触发 赋值语句 连续赋值语句assign 只要连续赋值语句右端表达式中操作数的值变化, 连续赋值语句即被执行。 阻塞赋值 a = b; ————-非时序赋值（组合） 非阻塞赋值 a&lt;=b ————时序赋值中使用 时序和组合在电路上的表现是时序赋值过程中需要等待时钟沿来触发。 函数设计特点层次化模块化顶层模块和底层模块的设计方法，将模块细分为若干个子模块，在底层实现子模块功能，在顶层组合各个子模块。","categories":[],"tags":[{"name":"verilog 计组实验","slug":"verilog-计组实验","permalink":"http://yoursite.com/tags/verilog-计组实验/"}]}]}