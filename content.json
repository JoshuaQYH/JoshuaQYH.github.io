[{"title":"基于时间的概率推理","date":"2018-11-26T14:44:12.876Z","path":"2018/11/26/ch15 时间上的概率推理/","text":"马尔可夫过程当前状态依赖于前一个状态，单阶的马尔可夫链； 当前状态依赖于前n个状态，n阶的马尔可夫链； 传感器模型 传感器马尔可夫假设： $$P(E_t | X_{0:t}, E_{0:t-1}) = P(E_t | X_t)$$ 等式右边就是我们的传感器模型。 有$$X_t$$ 就可感应得到$$E_t$$。 物理含义就是当前的证据只与当前状态有关，即便给定了过去所有状态和证据。 状态转移模型 $$P(X_i | X_{i-1}) = P(X_t | X_{0:t-1})$$ 物理含义就是给定前一个状态，计算当前状态的概率相当于给定所有状态时计算当前状态的概率 。给定前一个状态和给定过去所有状态的结果是一样的。 有了上述两个模型之后，加上初始状态模型$$P(X_0)$$, 我们就可以确定所有变量上完整的联合概率分布，从而确定其他类型的概率分布。 公式如下： $$P(X_{0:t}, E_{1:t}) = P(X_0) \\prod_{i=1}^tP(X_i | X_{i-1})P(E_i | X_i)$$ 形式化基本推理任务 滤波。计算信念状态。给定当前所有证据，计算当前状态的后验概率分布。 预测。给定当前所有证据，计算未来状态的后验分布。 平滑。给定当前所有证据，计算过去某一状态的后验概率。 最可能的解释。给定观察序列，找到最可能生成这些观察结果的状态序列。 学习。从观察中学习，推理哪些确实会发生转移，估计。期望最大化算法。EM算法。 滤波过程根据当前时刻已知的所有证据变量，计算当前状态的后验概率分布。 假设存在函数f使得 $$P(X_{t+1} | e_{1:t+1}) = f(e_{t+1}, P(X_t | e_{1:t}))$$,其物理含义就是已知t时刻的滤波结果$$P(X_t | e_{1:t}) $$ 和t+1时刻的证据$$e_{t+1}$$ ，可以计算下一个时刻t+1的滤波结果$$P(X_t | e_{1:t}) $$。该过程称为递归估计。 公式计算过程为： $$P(X_{t+1} | e_{1: t+1}) = P(X_{t + 1} | e_{1: t}, e_{t+1})$$ // 分解证据 ​ $$= \\alpha P(e_{t+1} | X_{t+1}, e_{1:t})P(X_{t+1} | e_{1:t})$$ // 使用贝叶斯规则 ​ $$= \\alpha P(e_{t+1} | X_{t+1}) P(X_{t+1} | e_{1:t})$$ // 根据传感器马尔科夫假设 ​ $$=\\alpha P(e_{t+1} | X_{t+1}) \\sum_{x_t} P(X_{t+1}| x_t, e_{1:t})P(x_t | e_{1:t})$$ // 分解为求和式 ​ $$= \\alpha P(e_{t+1} | X_{t+1}) \\sum_{x_t} P(X_{t+1} | x_t)P(x_t | e_{1:t})$$ // 马尔可夫假设 上述的求和表达式中，第一个因子来自转移模型，第二个因子来自当前状态分布。由此得到了递归公式 。我们可以认为滤波估计$$P(e_t | X_t)$$ 是沿着序列从1到t的前向”消息”：$$f_{1:t}$$ ，在每一时刻发生转移时得到修正，并根据每一新的观察进行更新，该过程表达为 $$f_{1:t+1} = \\alpha Forward(f_{1:t}, e_{t+1})$$ $$Forward$$函数实现了马尔可夫假设中的递归过程。 平滑过程给定现在已知的证据，计算过去某一状态的后验分布。 $$ 对于 0 \\le k &lt; t\\, 计算P(X_k | e_{1:t})$$ ，计算过程是: $$P(X_k | e_{1:t}) = P (X_k | e_{1: k}, e_{k+1:t})$$ // 分解证据 ​ $$= \\alpha P(X_k | e_{1:k})P(e_{k+1:t}| X_k, e_{1:k}) $$ // 使用贝叶斯规则 ​ $$ = \\alpha P(X_k | e_{1:k}) P (e_{k+1:t} | X_k)$$ // 使用条件独立性 ​ $ = \\alpha f_{1:k} × b_{k+1:t}$ 结果代表 $$\\alpha *$$ 前向消息 点乘 后向消息。 前向消息计算方法是通过从1到k的前向滤波过程，而后向消息的计算需要从时刻t到k+1进行反向递归。 $$P(e_{k+1:t} | X_k) = \\sum_{x_{k+1}} P(e_{k+1:t} | X_k, x_{k+1})P(X_{k+1} | X_k)$$ ​ $$ = \\sum_{x_{k+1}} P (e_{k+1:t} | x_{k+1}) P (x_{k+1} | X_k)$$ ​ $$ = \\sum_{x_{k+1}}P(e_{k+1} | x_{k+1})P(e_{k+2:t} | x_{k+1})P(x_{k+1} | X_k)$$","tags":[{"name":"人工智能, 马尔可夫场","slug":"人工智能-马尔可夫场","permalink":"https://joshuaqyh.github.io/tags/人工智能-马尔可夫场/"}]},{"title":"贝叶斯网络基础知识","date":"2018-11-26T12:01:22.786Z","path":"2018/11/26/ch 13不确定性的量化/","text":"1. 概率分布 先验概率等于无条件概率 $P(A)$ 后验概率等于条件概率 $P(A|B)$ 联合概率分布是由$A ,B$不同取值得到的一个$P(A,B )$概率分布。 完全联合分布中的边缘概率，是指某一随机变量成立的无条件概率，根据联合分布概率表累加计算可以得到。求得边缘概率的过程称为边缘化或者是求和消元化。 $P(A) = \\sum_{z∈Z}P(A, z)$ 求和消元化的联合分布表示 $P(A) = \\sum_zP(A|z)P(z)$ 根据乘法法则$P(A,z) = P(A | z) P(z)$ 可以求得求和消元化的条件概率分布。该规则也称条件化。 归一化常数 $\\alpha$: $P(A |B) = \\alpha P(AB)$。将$\\alpha$替代$1 / P(B)$ 。 $P(X|e) = \\alpha P(X ,e) = \\alpha \\sum_yP(X,e,y)$ 。 2. 独立性存在独立性，可进行概率分解降低模型的复杂度。 ！条件独立的含义：事件A，B，C, 若在A概率未知的情况下，AB不独立，如果A概率已知，那么AB就存在条件独立的关系。 独立性的一个表现就是 $$P(A | B) = P (A)​$$ ，当B与A无互相独立互不影响的时候。 其他表示: $$ P(AB ) = P(A)P(B)$$ 3. 贝叶斯$P(Y|X)P(X) = P(X|Y)P(Y) = P(XY)$ 从概率来看到原因的概率分布。 $$ P(Y | X) = $$$\\frac{P(X | Y)P(Y)}{P(X)}$ 如果某人是好人(概率为$P(Y)$), 某人偷东西的事件概率为($X$) ，如果发生了A偷东西$P(Y|X)$，那么A是好人的概率$P(Y | X)$。 放在实例中来观察贝叶斯公式的简单应用。在医疗诊断中，如果医生知道某一疾病发生某些症状的概率，那么可以利用贝叶斯公式估计得知当病人发生某症状时，推测病人发生某病的概率。 贝叶斯公式其实是反映了原因和结果之间的概率关系。 $$ P(Cause | Effect) = $$$\\frac{P(Effect | Cause)P(Cause)}{P(Effect)}$ = $$\\alpha$$ $P(Effect | Cause)P(Cause)$ 其中的 $P(Cause) P (Effect)$ 二者都属于先验概率, $\\alpha$ 是让 $P(Effect | Cause)$归一化的常数。 朴素贝叶斯 $P(Cause, Effect_1, Effect_2, Effect_3….Effect_n) = P(Cause) \\prod_n P(Effect_i | Cause)$","tags":[{"name":"人工智能，贝叶斯网络","slug":"人工智能，贝叶斯网络","permalink":"https://joshuaqyh.github.io/tags/人工智能，贝叶斯网络/"}]},{"title":"markdown 数学公式表示大集合","date":"2018-10-22T05:47:02.506Z","path":"2018/10/22/markdown-数学公式表示大集合/","text":"MarkDown 插入数学公式实验大集合0. 前言 最近在学习一些机器学习相关的知识，想把自己学习的东西通过 MD 的形式在线记录下来，但是之前一直没有开始行动，因为里面的公式什么的感觉实在是麻烦。于是今天打算花点时间了解一下如何在 markdown 中插入数学公式，发现其实很简单，大概花一个小时左右就能知道如何编写了。 1. 基础认识 笔者认为所谓插入数学公式其实就是引入一种规则，然后通过模板？渲染成公式，不知道这个理解对不对，不对望指正。其实你以前可能就看到过有的博客本该出现公式的时候不显示，点击后会链接到一个 new tab 然后显示一张公式的图片，有时却出现一大堆的代码。这里就是通过这段代码解析成公式然后显示的。 这里我们选取 MathJax 引擎。 引入脚本，把下面代码插入 MD 文件里面，如果你怕这份在线文件源别人访问不到的话，可以把这个下下来自己做一个源，这样比较稳定缺点是要自己手动更新源。 12&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;复制代码 好了到这里就可以插入公式了，如果你懂 LaTeX 的话那看一两个例子就知道了，不懂也没关系，自己写一写代码就知道了，可以找一个可以预览 MD 的工具一直尝试。 1.1 插入方式 这里分两种，一种是行间插入，另一种是另取一行 1.1.1 行间插入12\\\\(a + b\\\\)复制代码 这里是行间插入公式 a + b : (a + b)，特点就是通过( 和 ) 包含公式，然后为了模板引擎能够区分该 ( 不是普通文本的 ( 而是公式的 (，通过 \\\\ 转义一下。这样应该就很好理解这个语法构成了。注意这里方式不唯一，这是笔者喜欢的方式，其他的使用方式自行搜索。下面的介绍同样是这样。 PS: 这里掘金使用的是 $a + b$ : a + b ，如果对您的阅读产生印象，请看最后说明，这里就不做一一更改了。谢谢。 1.1.2 另取一行12$$a + b$$复制代码 这里是另取一行 a + b 特点就是通过$$包含公式。 笔者认为第二种方式更好，以下没看 JS 源码纯属猜测：行间的需要考虑到当前行的行高并对公式进行处理，而另取一行就更简单一些，可能解析起来更快。最最最最最最主要是看起来漂亮 ^_^ 不太要考虑空间不够换行。 1.2 基本类型的插入 这里对 @houkai ：LATEX数学公式基本语法 的思路稍加修改，然后进行介绍。 1.2.1 上、下标先看结果再总结语法吧。 123456789101112$$x_1$$$$x_1^2$$$$x^2_1$$$$x_&#123;22&#125;^&#123;(n)&#125;$$$$&#123;&#125;^*x^*$$$$x_&#123;balabala&#125;^&#123;bala&#125;$$复制代码 x_1 x_1^2 x^2_1 x_{22}^{(n)} {}^*x^* x_{balabala}^{bala} 可以看到 x 元素的上标通过 ^ 符号后接的内容体现，下表通过 _ 符号后接的内容体现，多于一位是要加 {} 包裹的。 笔者习惯先下标后上标的写法，和我的书写习惯一致：x_{balabala}^{bala}，不管你使用哪一种风格，最好自己注意统一，不要混用。 1.2.2 分式1234$$\\frac&#123;x+y&#125;&#123;2&#125;$$$$\\frac&#123;1&#125;&#123;1+\\frac&#123;1&#125;&#123;2&#125;&#125;$$复制代码 frac{x+y}{2} frac{1}{1+frac{1}{2}} 这里就出现了一个 frac{}{} 函数的东西，同样，为了区分这是函数不是几个字母，通过 \\frac转义，于是 frac 被解析成函数，然后第一个 {} 里面的被解析成分子，第二个 {} 被解析成分母。这里可以试试分数的行间解析 frac{1}{1+frac{1}{2}} 。我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果。 1.2.3 根式123456$$\\sqrt&#123;2&#125;&lt;\\sqrt[3]&#123;3&#125;$$$$\\sqrt&#123;1+\\sqrt[p]&#123;1+a^2&#125;&#125;$$$$\\sqrt&#123;1+\\sqrt[^p\\!]&#123;1+a^2&#125;&#125;$$复制代码 sqrt{2} y=begin{cases}-x,quad xleq 0 \\\\x,quad x>0end{cases} 里面用到了 (\\leq) 符号，下一章会介绍常用数学符号。 2.2 数组的其他使用2.2.1 划线12345678$$\\left(\\begin&#123;array&#125;&#123;|c|c|&#125;1 &amp; 2 \\\\\\\\\\\\hline3 &amp; 4\\end&#123;array&#125;\\right)$$复制代码 left( begin{array}{|c|c|}1 & ldots \\\\hlinevdots & ddots end{array} ight) 2.2.2 制表12345678910$$\\begin&#123;array&#125;&#123;|c|c|&#125;\\hline&#123;1111111111&#125; &amp; 2 \\\\\\\\\\hline3 &amp; 4 \\\\\\\\\\hline\\end&#123;array&#125;$$复制代码 begin{array}{|c|c|}hline{1111111111} & 2 \\\\hline{balabala} & 你好啊 \\\\hlineend{array} 可以看到，其实其他很多东西都可以很灵活的表达出来。碰到其他有趣的我会继续写出来的。 3. 常用数学符号 这里提供一个文档下载，如果上面的链接失效，也可以到我的 GitHub 下载 pdf 版。下面举几个例子。 3.1 希腊字母12345678910111213141516171819202122232425262728$$\\begin&#123;array&#125;&#123;|c|c|c|c|c|c|c|c|&#125;\\hline&#123;\\alpha&#125; &amp; &#123;\\backslash alpha&#125; &amp; &#123;\\theta&#125; &amp; &#123;\\backslash theta&#125; &amp; &#123;o&#125; &amp; &#123;o&#125; &amp; &#123;\\upsilon&#125; &amp; &#123;\\backslash upsilon&#125; \\\\\\\\\\hline&#123;\\beta&#125; &amp; &#123;\\backslash beta&#125; &amp; &#123;\\vartheta&#125; &amp; &#123;\\backslash vartheta&#125; &amp; &#123;\\pi&#125; &amp; &#123;\\backslash pi&#125; &amp; &#123;\\phi&#125; &amp; &#123;\\backslash phi&#125; \\\\\\\\\\hline&#123;\\gamma&#125; &amp; &#123;\\backslash gamma&#125; &amp; &#123;\\iota&#125; &amp; &#123;\\backslash iota&#125; &amp; &#123;\\varpi&#125; &amp; &#123;\\backslash varpi&#125; &amp; &#123;\\varphi&#125; &amp; &#123;\\backslash varphi&#125; \\\\\\\\\\hline&#123;\\delta&#125; &amp; &#123;\\backslash delta&#125; &amp; &#123;\\kappa&#125; &amp; &#123;\\backslash kappa&#125; &amp; &#123;\\rho&#125; &amp; &#123;\\backslash rho&#125; &amp; &#123;\\chi&#125; &amp; &#123;\\backslash chi&#125; \\\\\\\\\\hline&#123;\\epsilon&#125; &amp; &#123;\\backslash epsilon&#125; &amp; &#123;\\lambda&#125; &amp; &#123;\\backslash lambda&#125; &amp; &#123;\\varrho&#125; &amp; &#123;\\backslash varrho&#125; &amp; &#123;\\psi&#125; &amp; &#123;\\backslash psi&#125; \\\\\\\\\\hline&#123;\\varepsilon&#125; &amp; &#123;\\backslash varepsilon&#125; &amp; &#123;\\mu&#125; &amp; &#123;\\backslash mu&#125; &amp; &#123;\\sigma&#125; &amp; &#123;\\backslash sigma&#125; &amp; &#123;\\omega&#125; &amp; &#123;\\backslash omega&#125; \\\\\\\\\\hline&#123;\\zeta&#125; &amp; &#123;\\backslash zeta&#125; &amp; &#123;\\nu&#125; &amp; &#123;\\backslash nu&#125; &amp; &#123;\\varsigma&#125; &amp; &#123;\\backslash varsigma&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\\\\\\\hline&#123;\\eta&#125; &amp; &#123;\\backslash eta&#125; &amp; &#123;\\xi&#125; &amp; &#123;\\backslash xi&#125; &amp; &#123;\\tau&#125; &amp; &#123;\\backslash tau&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\\\\\\\hline&#123;\\Gamma&#125; &amp; &#123;\\backslash Gamma&#125; &amp; &#123;\\Lambda&#125; &amp; &#123;\\backslash Lambda&#125; &amp; &#123;\\Sigma&#125; &amp; &#123;\\backslash Sigma&#125; &amp; &#123;\\Psi&#125; &amp; &#123;\\backslash Psi&#125; \\\\\\\\\\hline&#123;\\Delta&#125; &amp; &#123;\\backslash Delta&#125; &amp; &#123;\\Xi&#125; &amp; &#123;\\backslash Xi&#125; &amp; &#123;\\Upsilon&#125; &amp; &#123;\\backslash Upsilon&#125; &amp; &#123;\\Omega&#125; &amp; &#123;\\backslash Omega&#125; \\\\\\\\\\hline&#123;\\Omega&#125; &amp; &#123;\\backslash Omega&#125; &amp; &#123;\\Pi&#125; &amp; &#123;\\backslash Pi&#125; &amp; &#123;\\Phi&#125; &amp; &#123;\\backslash Phi&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\\\\\\\hline\\end&#123;array&#125;$$复制代码 begin{array}{|c|c|c|c|c|c|c|c|}hline{alpha} & {backslash alpha} & { heta} & {backslash theta} & {o} & {o} & {upsilon} & {backslash upsilon} \\\\hline{beta} & {backslash beta} & {vartheta} & {backslash vartheta} & {pi} & {backslash pi} & {phi} & {backslash phi} \\\\hline{gamma} & {backslash gamma} & {iota} & {backslash iota} & {varpi} & {backslash varpi} & {varphi} & {backslash varphi} \\\\hline{delta} & {backslash delta} & {kappa} & {backslash kappa} & { ho} & {backslash rho} & {chi} & {backslash chi} \\\\hline{epsilon} & {backslash epsilon} & {lambda} & {backslash lambda} & {varrho} & {backslash varrho} & {psi} & {backslash psi} \\\\hline{varepsilon} & {backslash varepsilon} & {mu} & {backslash mu} & {sigma} & {backslash sigma} & {omega} & {backslash omega} \\\\hline{zeta} & {backslash zeta} & { u} & {backslash nu} & {varsigma} & {backslash varsigma} & {} & {} \\\\hline{eta} & {backslash eta} & {xi} & {backslash xi} & { au} & {backslash tau} & {} & {} \\\\hline{Gamma} & {backslash Gamma} & {Lambda} & {backslash Lambda} & {Sigma} & {backslash Sigma} & {Psi} & {backslash Psi} \\\\hline{Delta} & {backslash Delta} & {Xi} & {backslash Xi} & {Upsilon} & {backslash Upsilon} & {Omega} & {backslash Omega} \\\\hline{Omega} & {backslash Omega} & {Pi} & {backslash Pi} & {Phi} & {backslash Phi} & {} & {} \\\\hlineend{array} 写太累了😂😂😂。。。其他的详见 PDF。 4. 总结 通过这样梳理一下基本的公式都能插入了，而且也会如何查资料。对于自己日后学习 LaTeX 写论文有很大帮助。以下建议带有很强的主观性，仅供参考。 公式一律使用另取一行，并且上下都空一行 一个公式一个语句，不要写在一个 $$***$$ 里，保证独立性，一个公式错误不影响另一个公式。 风格统一，不要混用。比如上下标的写法：x_{balabala}^{bala} 行间字母可以使用 \\\\(a\\\\) 代替 a ，养成自己的写作风格。 最后：我的 Blog 和 GitHub，感谢阅读。 5. 参考资料 十分感谢以下作者的无私分享。 Markdown中插入数学公式的方法 LATEX数学公式基本语法 一份其实很短的 LaTeX 入门文档 说明：掘金好像有些转义不出来，如果想看效果可以参考这篇自己多试试。","tags":[{"name":"markdown","slug":"markdown","permalink":"https://joshuaqyh.github.io/tags/markdown/"}]},{"title":"区块链挑战，应用和发展","date":"2018-10-21T01:57:20.688Z","path":"2018/10/21/初探区块链的挑战，应用和发展/","text":"一、 引言​ 区块链技术被认为是继互联网、人工智能以后又一大颠覆式的技术创新，其内在的发展潜力被无数人所追求。以区块链技术为原理的比特币等加密数字货币的兴起，让区块链技术得以走向公众的视线。提及区块链，我们往往会联想到其特性，分布式，可溯源，去中心化，不可篡改，安全匿名，公开透明等等。区块链凭借这些前所未有的技术优势获得了政府，学术界，企业们的青睐和高度的重视。近年来，无论是科技巨头还是中小的初创公司，都在积极的布局着区块链，关于区块链的的技术创新和模式创新不断涌现。但对于区块链这一新型事物，各行各业都处在摸石头过河的阶段，探索着区块链有效的应用场景。 ​ 关于如何看待区块链，公众的看法不一。有人一直唱衰，称其为泡沫；有人坚持信念，在区块链的浪潮中砥砺前行，期待区块链价值的焕发，试图成为社会变革的先驱者。区块链发展的主流观点是：区块链将是一种实现信息互联网到价值互联网转变的跨越式技术，一定程度上能够节约生产成本，提高生产效率，并有望成为未来的核心基础设施，推动社会方方面面的变革和进步，包括金融，经济贸易，社会管理，公共服务等等。区块链创造性地去除了许多系统应用的约束，为很多想法的实现提供了新的可能。以比特币为代表的加密数字货币，改变了传统的金融业交易模式；火热的以太坊智能合约，结合日渐发达的物联网，让我们看到了智能合约型社会在未来的可能。 ​ 从技术的角度来看，区块链就是一个结合P2P协议和加密技术分布式的公共账本，网络上的每一个节点都有可能在账本上添加记录，但决定记账权的方法是通过多种的共识算法如PoW, PoS来实现的。记账就是把数据打包成一个区块添加到一条最长的区块链上，该区块上的数据可追溯可验证。区块链的分布式存储决定了其去中心化，公开透明，信息共享；基于安全的哈希算法和共识算法，使其具备了不可篡改的特性；非对称加密技术让参与主体安全匿名，隐私得到保护；而时间戳技术让区块链上的数据可追溯可审核。 ​ 从社会科学的角度来看，区块链就是一个通过算法来制造信任和定义信用的机器，在任何需要信任的领域，都有区块链的用武之地。我们知道，在中心化的结构体系中，各方参与者只需要服从中心确立好的共识即可，共识的达成将是十分高效的，而对于分布式，各自取其益的情况下，达成共识则非常难。共识机制的建立，使去中心化的区块链记账系统成为了现实。总的来说，区块链创造了一个数字化的，有效地传输价值的信用系统。 ​ 区块链技术将有助于实现软件定义的社会系统，是下一代云计算的雏形，有望像互联网一般彻底重塑人类活动形态，并实现从目前的信息互联网向价值互联网的转变。目前整体发展态势虽没有17年比特币大火时那样的激进，围绕币市的各种业务正感受着区块链“泡沫”破灭的寒冬，以往那种投机主义者的空气币，割韭菜的喧嚣正逐渐退去，区块链的真正发展和价值落地才刚刚开始，泡沫破灭的过程恰似一个适者生存，劣者淘汰的过程，只有经过时间和现实情况检验过的优秀项目才能存活下来。 ​ 依托成熟的云计算技术体系，业界也出现了“区块链即服务（BaaS）”的平台，主要提供了联盟链及公有链这2种服务，包括IBM的Bluemix，微软的Bletchley，腾讯的TBaaS；与此同时，我国在《“十三五”国家信息化规划》中把区块链作为一项重点前沿的技术，明确提出需加强区块链等新技术的创新，试验和应用，以实现抢占新一代信息技术主导权。目前，我国区块链技术持续创新，区块链产业初步形成，开始在供应链金融、征信、产品溯源、版权交易、数字身份、电子证据等领域快速应用，有望推动我国经济体系实现技术变革，组织变革和效率变革，为构建现代化经济体系作出重要贡献。 二、区块链面临的挑战​ 开放，共享，去中心化是互联网的重要精神，而区块链则高度契合了这一精神。从时间跨度上看，区块链的诞生时间比较晚，具有极大的发展潜力和空间，而相关的行业发展经验和学术研究仍是不足的，更是决定了区块链技术在今后的发展中仍然还会面临极大的挑战。本文主要总结了以下几个较为明显和迫切的挑战： 技术层面仍有不足之处1.1安全性问题 ​ 我们知道在比特币的共识过程中，如果汇聚了超过51%的算力时，就有可能达成篡改区块链的数据。我们通常所说的区块链的数据不可篡改其实是相对而言的，因为共识过程需要消耗大量的算力，当篡改成本远远大于实际成本时，可以近似看作不可篡改，但这一威胁的存在并不能忽视，更为安全有效的共识机制有待更深入的研究和设计。 ​ 随着量子计算等新型计算技术的发展，区块链的密码学保护可能会变得越来越脆弱，非对称的加密技术有可能在今后得到破解，所以对加密技术的研究的进程仍要跟上，不能止步于前。 ​ 而区块链中的隐私匿名保护特性其实也存在着被追踪的可能性，有学者也提供了一种根据比特币交易事务进行时追踪用户IP地址的情况。随着各类反匿名身份甄别技术的发展, 加上区块链上的数据公开透明，实现部分重点目标的定位和标识也存在可能。如何加强匿名保护的技术，也是当前区块链研究的热点方向。 1.2效率问题 ​ 区块链的效率问题一直为人诟病，甚至有人宣称区块链技术存在天然瓶颈。交易效率慢，如比特币区块链每秒仅能处理7笔交易，这极大限制了区块链在商业世界的应用。还有有一种说法就是区块链实际就是一个造价昂贵的缓慢数据库，与其花大价钱来打造分布式的区块链数据库不如精心去维护好集中式的数据库。而且当数据区块越来越大的时候，因为分布式存储的原因，区块链数据将会变的臃肿庞大。 ​ 不过短时间内效率低并不是阻碍区块链的重要原因，对于共识机制效率如何改善相信会有好的进展。从另一个角度来讲，效率低也是安全的一种保证。可能我们在安全和效率之间需要一个良好的折衷方案吧。 监管问题 ​ 提及到监管问题，首先想到区块链的去中心化，接着是匿名性。去中心化意味着不受中心的掌控，匿名性意味着难以追踪参与者。从负面效果来看，去中心化是不受控制，放任自由，为所欲为；匿名则意味着包庇，躲避正义的追踪。 ​ 举个例子，一开始比特币流通的环境是在暗网，交易双方信息保密，只关注交易事务本身不关注交易双方。比特币的匿名性跟暗网的隐匿性有天然的契合度，利用比特币在暗网交易，走私，贩毒，洗钱等等难以追查，成了犯罪分子的天堂。 ​ 利用区块链来进行洗钱的途径也是存在的，尤其不能忽视发行代币的风险，要时刻警惕空气币，ICO的陷阱，防止其破坏金融市场的稳定，减少无良资本家割韭菜的局面。在监管层面必须做到对虚拟货币的发行，控制，管理，甚至禁止。在区块链发展的同时，相应的法律法规和政策也要跟上脚步。国家在发展布局区块链的时候，干预力度和引导的力度要如何拿捏才能更好地发挥区块链的社会价值呢，这是个值得挖掘的问题。 趋中心化问题 ​ 区块链自从走入公众视野就以去中心化的特点引起无数人的兴趣和追捧，这得益于分布式的共识机制，所谓人人都有记账权，人人都享有一份公共一致的账本，人人都有对账本上写入的记录的监督权。但是现有的共识机制，依旧有中心化的趋势，真正的去中心化可能渐渐消失。 ​ 以比特币的PoW共识机制为例，挖矿的矿工如果集中到一起，形成一个足够大的矿池，获得记账权的概率就更大，去中心化可能会演变成中心化，记账权掌握在少数人手里。PoW就是比拼谁的算力大，谁的算力越大获得的比特币奖励就越多，这个过程跟买彩票一样，越有钱的人买的彩票越多，中奖几率越大，而事实是越有钱的人会购买算力更大性能更优的矿机，挖到比特币的可能性更多发生在这些挖矿专业户手中。比特币的奖励集中到某些一小部分人的手上，比特币价格居高不下，财富就越是汇聚到这些人的手上。相似地，基于PoS的共识机制也会出现相同的问题，那些持有币数量越大，币龄越高的人越有可能获得记账权。这近乎是一种马太效应！弱中心化和重回中心化的威胁不容小觑！ ​ 或许完全去中心化的共识机制只是一个乌托邦式的幻想，就像人们曾经热衷于追求永动机一般，但这并不意味着人们要停止对区块链的探索，更为安全有效的共识机制仍要很长的一段时间去检验其有效性和正确性，去中心化未必能完美准确地达成，但近似地有效地达成去中心化的特性，将无疑带给社会一次前所未有的变革。 三、 区块链的多元化应用​ 区块链行业的应用非常多元，但实际落地条件可能还需要多次实践和配套基础设施的建立和完善。各国政府对待区块链的态度和政策也从很大程度上左右着区块链的发展方向和未来，区块链未来会是在哪些行业发光发彩。而在当前，各类与行业特点相结合的区块链项目如雨后春笋般涌现，预示着整个区块链产业的潜力。与“互联网+”类似，本文主要讨论几个当前较为大众所热议以及具有较为清晰发展前景的应用，以供了解。 金融 ​ 金融领域是与科技界联系较为紧密的领域，许多技术的创新都能很快被金融领域所嗅探到，并且得到很好的应用，所以在金融业也出现了“金融科技（FinTech）”等理念。诚然，金融领域几乎是天然与区块链系统契合的，金融领域的许多痛点仿佛在区块链的技术支撑下找到了良好的解决方案。传统金融的中心化，交易繁琐复杂，安全性有限都是亟需解决的痛点，“区块链+” 1.1 数字货币 ​ 最具代表性的数字货币当属比特币，同时也是目前世界影响最为广泛的一个应用。比特币可以安全方便地将数字资产转移给另外一个人，得以于这些特性，比特币很快就在交易相关的行业发展。比特币是一个工具，系统无法限制人们使用它的方式，比如一个较为灰色的例子，暗网上的“丝绸之路”网站就通过比特币定价并且进行交易，随后被美国FBI查封并且收缴了26000比特币，虽然数字货币存在被不法分子不正当利用的情形，但我们依旧能看到数字货币在市场上流通实验的成功实践。 ​ 不过数字货币去中心化的特点依旧对许多国家的货币机制产生了威胁，常常被认为是金融不稳定的因素。如何看待ICO，如何加强数字货币的监督管控，是每个国家都要面对和思考的问题。目前数字货币还没有在全世界的国家之间达成共识，如何制定有效的法律法规来引导数字货币的发展，数字币作为一个新生儿，仍然不断接收着世人的拷问。 1.2 供应链金融 ​ 供应链金融是银行将核心企业和上下游企业联系在一起提供灵活运用的金融产品和服务的一种融资模式。供应链金融参与方主要包括：核心企业，中小企业，金融机构和第三方支持服务。核心企业通常对上下游的供应商、经销商在定价、账期等方面要求苛刻，供应链中的中小企业常出现资金紧张、周转困难等情况，导致供应链效率大幅降低甚至停止运转。因此，供应链金融产业面临的核心问题是中小企业融资难，融资贵，成本高，周转效率低。供应链金融平台、核心企业系统交易本身的真实性难以验证，导致资金端风控成本居高不下。 ​ 区块链分布式记账以及共识机制，恰好建立了一套可信的信用体系，在数据验证和追溯上提供了有力的技术支撑，贯穿了金融供应链上下游的各方的信用。运用区块链技术，可以将核心企业的信用数字化，写入智能合约，依托智能合约来防范金融风险，使信用在供应链上有效传导，降低合作成本，提高生产效率。还可以使用智能合约来实现对供应链资金的拆分和流转，提高资金的周转效率，为中小企业解决融资难，融资贵的问题。 1.3 贸易金融 ​ 区块链就是一个用共识算法建立起来的具备信用的公共账本，开放共享的特性在贸易金融领域也有一番用武之地。传统银行之间存在着信息不对称以及交流不畅，信用鉴定繁琐的痛点，银行之间的业务报文的传递还大多依靠着国际组织Swift，EDI等等。利用区块链来建立银行之间的业务报文收发联盟的问题，简化业务流程，着手打造自己基于区块链系统的贸易金融平台，也就是通常讲的联盟链，已经成为一种新的发展思路。 ​ 往更开阔的角度来思考其应用，区块链多方可参与的特点有利于连接一切利益相关者，如区块链相关企业，政府部门一起来构建一个更完善，更自动化，更具信用价值的贸易金融生态。 1.4财务管理 ​ 区块链可审查，可追溯，不可篡改的特性也在财务管理方面有着出色的表现。在交易清算方面，区块链让多方共享一套可信互相认可的公共账本体系，所有的交易清算可实时的记录在区块链账本上，不可篡改，可追溯，大大提高了对账的准确率和效率。搭载智能合约之后，还能实现自动化的交易清结算，减少对账人员的成本和差错率。在审计方面，区块链能提高对企业财务信息的监督水平，虚假交易和账目造假难度大大提升。另外，通过区块链网络的实时性以及可审核性，审计效率也能大大提升，节约人力成本。而且区块链还能显著降低审计数据被攻击的风险，分布式的存储让审计数据的保护变得稳定可靠。 除了上述四点，区块链和金融场景的结合还有诸多的可能，电子信用凭证，跨境汇款查询应用，风险管理，企业改革等等，在未来将会有炫目的表现。 物联网 ​ 如今的物联网实现物物通信的方式是经由中心化的云服务器，该模式存在的弊端是当接入设备大幅增加时，服务器面临的负载将会越重，而在未来，上亿级的设备互联是必然的。到了那时云服务将会带来巨额成本，这是物联网发展的一个绊脚石。而且传统物联网数据容易受到攻击，具有诸多信息安全风险问题。区块链+物联网则通过多个节点参与验证，将全网达成交易的数据记录在分布式账本之中，取代中央服务器的作用，同时也能依赖区块链的非对称加密技术，共识机制，分布式存储降低数据丢失的风险。 ​ 在物联网中的电子商务行业，通过智能合约的方式实现交易的自动化，提供可靠性。去中心化的机制也能去除第三方的接入，让交易更为直接，有效率。 ​ 此外，物联网时代中的个人隐私安全更需要高度重视，人机交互，物物互联极大提高了暴露个人隐私数据的危险。利用非对称加密技术来对用户信息进行加密是一种有效的办法。 ​ 物流方面，结合智能硬件，区块链的可追溯性，实时性安全性也能得到充分发挥。在未来进一步发展的物联网社会，区块链将能不一样的智能体验。 医疗健康 ​ 区块链+医疗也是一个热门的场景。电子医疗数据的处理是当今区块链研究的一大热点，人们致力于如何将医疗数据安全共享。区块链作为一种多方维护，分布式存储，安全加密的记账技术，在解决医疗行业患者敏感信息共享与保护方面将会是一个很好的创新。借助区块链，我们可以搭建一个医疗信息区块链平台，实现多方数据共享，满足获取患者电子病历等历史数据，并将共享数据用于AI建模，图像检索，健康咨询等等。 社会公共服务和基础设施 ​ 新一代的社会公共服务，以及新型的基础设施建设，将会是当前区块链行业极为重要的机会，但这一发展道路还很漫长，公共服务和基础设施都需要发展到一定规模才能提供良好的服务。当前区块链发展仍在早期阶段，价值互联网的时代虽然呼之欲出，但实际普及的时间点还很难说。而加大基础设施的建设，提供更多的社会公共服务将会加大这一进程的步伐。 ​ 例如在产权登记版权注册方面，利用区块链技术来保障个体或集体的权益不受侵犯。在教育行业，将区块链和学生征信管理，升学就业，学术，资质证明等方面相结合，对教育就业的健康发展具有重要价值。在节约能源方面，区块链也有独特的创新之处，现有专家学者也建议通过发行能源币的方式来鼓励可再生资源的使用。 总体来说，区块链在很多行业和领域都能有独特的创造性应用，只要是和价值挂钩的信息以及需要建立可靠信用流通性强的场景，都和区块链有天然的亲和性，可以结合在一起发展除新的方式来满足不同行业的需求。我们必须明确，在多元的场景下，多元的区块链实现是有必要的，价值互联网的构建离不开多元场景需求的驱动。 四、 区块链的未来发展方向和趋势​ 区块链领域已经成为行业创新创业的热土，技术的不断攻坚和创新，将在社会层面上带来一场变革。本文将从技术层面和社会应用层面来简述对区块链未来的理解和看法。技术和社会层面是相互作用的两条发展主线，技术的创新开拓了社会应用的场景和空间，社会应用遇到的痛点和发展需求又是技术创新的一大动力。 技术层面 1.1 自身技术的迭代更新 区块链自身的机制仍有不足之处，如共识机制，效率问题，加密技术等等，都等待着专家学者，各行各业的技术人员进行优化改进。结合未来多样化的场景，区块链自身也存在着变革和重构的可能。在未来，单一的公有链，或者联盟链，私有链可能不能满足价值更为多元的传递。为方面数字资产在不同区块链之间的转移，开发安全有效的侧链技术，也是一个研究的热点。而且在加大区块链系统的吞吐量，提高效率方面，高性能的系统方案如分片技术，多通道技术仍在不断探索中。此外，随着区块链技术的发展，谋求一个统一的技术标准对整体发展局面和速度有着极大的作用，如同互联网发展初期基于TCP/IP等传输协议带给互联网信息通信的影响一样。当拟定一个权威标准之后，区块链产业才能有条不紊地前进。 1.2 与其他技术的融合创新 跳开自身技术的”瓶颈“，区块链技术和其他高新技术仍存在这融合创新的可能。在大数据方面，可以结合区块链来提升大数据管理和大数据分析的可靠性，分布式存储非对称加密技术提供数据安全和保障，而时间戳技术和不可篡改可以帮助准确的大数据分析，实现精准营销。在人工智能方面，智能硬件搭配智能合约将重塑契约模式，让智能合约更智能，加速价值互联网的到来，实现虚拟价值和实体价值的进一步转化。 社会经济层面 2.1 经济上实现”弯道超车“，打造”可信数字化“实体经济 区块链作为价值互联网的基础，引领着世界新一轮的技术创新和产业变革。由区块链引发的技术创新和模式创新与实体经济紧密深度的融合在一起，推动社会实体经济的发展，改变产业运作方式，简化业务流程，减少人力物力的同时提高生产效率。从底层架构的区块链到细分场景的应用，从国家战略到企业实践，区块链的应用逐渐从金融领域辐射出去，带动着其他行业的发展和改革。区块链对生产关系的改造力，降低了传统过程中因为信息不对称，信用不可靠而早就的资源浪费。在实体经济中，基于算法搭建的无第三方介入的信用机制更是将数字化提升到一个新的层面，即”可信数字化“，极大地加速了实体经济中资金的流通，为经济上实现”弯道超车“提供了新的动力。 2.2 完善去中心化基础设施，奠定社会信任基石 去中心化的技术优势使得未来基于区块链理念的各类去中心化应用，去中心化自治组织，去中心化自治公司，甚至去中心化社会成为可能。不断完善的去中心化基础设施，逐步构建起来的社会信用体系，将为智能社会进一步赋能。就现状而言，智能合约会是未来一个重要的去中心化基础设施，预计之恶能合约会从自动化向智能化方向演变。而现阶段的智能合约本质逻辑是”IF-THEN“类型的条件响应规则，迈向更为智能的”WHAT-IF“推演过程。社会信任体系将从第三方中心的监督机制，转向由共识算法定义的信用体系。避开人性的贪婪，将数据资产交付给理性的机器合约，或许是行之有效的一种方向。 2.3 区块链驱动的平行社会 有关学者认为，区块链将引领世界从物理+网络的CPS实际世界走向精神层面的人工世界，形成物理+网络+人工的人-机-物一体化的三元耦合系统，称为社会物理信息系统CPSS。基于CPSS的平行社会已有了雏形，其核心本质特征是虚实互动与平行演化。而区块链就是实现CPSS平行社会的基础架构之一，为分布式社会系统和人工智能系统，物联网系统，提供了行之有效的去中心化数据结构，交互机制和计算范式，为实现平行社会奠定了坚实的数据基础和信用基础。智能合约的可编程性驱动着平行社会的进展，搭载物联网中的智能硬件，将虚拟空间和现实物理世界联通在一起，通过可靠有效的人物交互和智能识别，实现社会管理和社会模式的优化。 ​ 区块链的浪潮已经到来，由虚向实，更多区块链项目正在落地，进一步的数字化生活逐渐有了雏形。积极拥抱区块链，把握区块链发展态势，于个人，于企业，于国家，目前看，都是一个正确但要付出很大的努力去摸索的选择。 参考文献[1] 袁勇, 王飞跃. 区块链技术发展现状与展望. 自动化学报, 2016, 42(4): 481-494 [2] Zibin Zheng, Shaoan Xie, Hong-Ning Dai,Xiangping Chen,Huaimin Wang.Blockchain Challenges and Opportunities: A Survey. Int. J. Web and Grid Services [3]袁勇,周涛, 周傲英,段永朝, 王飞跃.区块链技术: 从数据智能到知识自动化.自动化学报,2017,43(9):1485-1490 [4] 2018 年中国区块链产业白皮书 [Online], available:http://www.miit.gov.cn/n1146290/n1146402/n1146445/c6180238/part/6180297.pdf, 2018-05-20. [5]黄俊飞,刘杰. 区块链技术研究综述. 北京邮电大学学报,2018,41(2):1-8","tags":[{"name":"区块链","slug":"区块链","permalink":"https://joshuaqyh.github.io/tags/区块链/"}]},{"title":"机器学习（一）--概念理解","date":"2018-08-14T16:07:06.722Z","path":"2018/08/15/机器学习（一）--概念理解/","text":"笔记基于《机器学习》周志华一书所作的整理。 机器学习是什么，如何理解机器学习？ 人在认知事物的时候，必须经过一定的经验积累和认识，然后做出相应合理的决策。也就是说人在某一领域上经验的积累会提高人对事物的处理和反应能力。类比到机器学习中，机器学习正是这样一门学科，致力于如何通过计算的手段，利用所谓的经验来让系统具有一定的功能或者改善自己的性能，比如计算机视觉让计算机有“看物体”的能力，并使视觉能力不断增强，自然语言处理让计算机有“翻译，对话”能力，大量的模拟和计算使机器更“懂人话”。 在计算机系统中，“经验” 通常以“数据”的方式存在。机器学习所要研究的主要内容就是，关于在计算机上从数据中产生一个模型的算法，即“学习算法”。基于提供的经验和数据我们对系统进行提炼和优化模型，当系统接收到相应输入时，根据已有的经验去进行响应，做出符合“智能”定义的行为。机器学习，主要是数据+算法。通常情况下，数据的采集和处理显得更为重要，一般来说数据集越大，学习能力越强，但也意味着更长的训练时间和修正优化时间。 机器学习需要的数据基础 要进行机器学习，先要有数据。比如判定西瓜的好坏，需要先给出许多西瓜的数据例子：（色泽=青绿，根蒂=硬挺 … )[]，（色泽=白色，根蒂=蜷缩）[ ]等等，这些数据记录的集合称为数据集，每一条记录都是样本或者示例，每一条记录里有对象的属性或特征。 属性张开的空间称为属性空间，样本张开的空间称为样本空间 。在数学上，我们使用线性代数中的向量来表示物体的空间，空间的维度由我们数据记录中的属性个数决定，比如西瓜有色泽，根蒂，响声三个属性，那么我们以这三个属性张开的空间就可以表示所有的西瓜，每一个西瓜都能在这个空间中找到自己的坐标位置。由于空间中的每一个点对应一个坐标向量，因此我们也把一个示例称为一个特征向量。 一般地，令D = {x1， x2..， Xm } 表示包含m 个示例的数据集，每个示例由d 个属性描述(例如上面的西瓜数据使用了3 个属性)，则每个示例Xi = (Xi1; Xi2; . . . ; Xid) 是d 维样本空间X 中的一个向量， Xi ε X ， 其中Xij 是xi在第j 个属性上的取值(例如上述第3 个西瓜在第2 个属性上的值是”硬挺” ), d 称为样本xi的”维数” (dimensionality)。 机器学习的过程 从数据中学的模型的过程称为“学习”或者“训练”。整个过程通过执行某些算法来完成（我们将了解到十大算法CNN，RNN），训练过程 中使用的数据称为“训练数据”， 每一个样本称为“训练样本”，训练样本的集合称为“训练集”。 学得模型对应了关于数据的某种潜在规律，亦称假设（后续会根据数据的训练做不断地修正）, 机器学习本身就是一个不断逼近事实真相的过程。 模型有时被称为“学习器”，可看作学习算法在给定数据和参数空间上的实例化 机器学习所能完成的事和划分 预测 要建立一个可预测的模型，我们需要获得训练样本的结果信息，通常称为标记。一个样本具有标记时可成为样例。 标记集合也成为标记空间或者输出空间。比如要判断西瓜的好坏时，我们除了给出西瓜色泽，敲声等属性时，还要给出在这些属性下瓜的好坏，即赋予每一个样本标记 。根据预测对象的不同时，我们定义了不同的学习任务。 分类：当预测的对象是离散值（例如好瓜，坏瓜），此类学习任务称为分类。 回归：当预测的对象是连续值（例如西瓜的成熟度），此类学习任务称为回归。 当预测的类别只有两个时，称为“二分类”任务，涉及多个时，称为“多分类”任务。 一般地，预测任务是希望通过对训练集{(X1’ Y1) , (X2 , Y2) ,…, (Xm, Ym)} 进行学习，建立一个从输入空间X 到输出空间y 的映射f: X 叶y. 对二分类任务，通常令Y = {-1 ，+1} 或{0 ， l}; 对多分类任务， IYI &gt;2; 对回归任务， Y= R，R为实数集. 学得模型之后，使用其进行预测的过程称为“测试”。被预测的样本称为测试样本“。也就是说学习的过程是建立一个准确率更高的关于输入到输入的映射关系。 训练数据处理：聚类clustering 将训练集中的西瓜分成若干组，每一组称为一个簇，这些自动形成的簇可以对应一些潜在的概念划分，比如西瓜中按照色泽划分为”深色瓜“和”浅色瓜“。 这样有助于我们了解数据内在的规律，更为深入地分析数据建立基础。但是在聚类学习中，我们事先并不知道西瓜是根据哪些属性特征来划分为簇的，在学习过程中使用的训练样本通常不拥有标记信息。 ​ 根据训练样本是否拥有标记信息，学习任务大致可以划分为两类：监督学习和无监督学习。没有标记的当然是无监督学习，这意味着在无监督学习中没有标准答案给机器，只能依靠机器分析内部的数据特征来做响应的判断，而有标记的学习，则可以理解为在得到标准答案后，机器的一次次自我修正，以期下次遇到相似的问题时，能得到和标准答案更为接近的答案。显然，分类和回归属于监督学习，聚类属于无监督学习。 泛化： 机器学习不仅在已有的训练样本上表现出高准确率，在新的未尝试过的样本上也能体现较高的准确率。显然强泛化的模型，更适用于整个样本空间，虽然样只是空间中一个很小的采样。 假设空间：由对象所可能存在的不同属性值所张成的空间 归纳： 从特殊到一般的“泛化”过程，而从“样例”中学习显然是一个归纳的过程，所以也称为“归纳学习”。 狭义归纳：要求从训练数据集中获得概念，所以也称概念学习或者概念形成。 概念学习中最简单的就是布尔概念学习，即让机器判断对或错，黑或白，类似预测中的二分类学习。 演绎：从一般到特殊的“特化”过程，从基础原理推演到具体的情况。在数学公理系统中，基于公理和推理推导出与之相恰的定理。 模拟搜索西瓜问题的假设空间有多种做法，例如从顶向下，从一般到特殊，从底向上，从特殊到一般。 搜索过程遇到和训练集的“正确答案”不一致时，需要删除或者调整参数使之逼近真相。 在现实问题中，存在着很大的假设空间。但学习过程是基于有限的样本训练集来进行的，可能有多个假设和训练集一致。即存在一个与训练集一致的假设集合，称为“版本空间”。不同训练集对应不同的版本空间，版本空间属于假设空间的一部分。 归纳偏好 版本空间的问题：如果有三个与训练集一致的假设，但在不同模型的情况下，面临新的样本，却会产生不同的输出判断。也就是说不同的模型具有不同的偏好，对某种类型的假设的偏好。 在训练集之外的样本误差的计算方法 P8~9 总误差和实际学习算法无关，任意两个学习算法的总误差相同。 也就是说学习算法所具有的不同训练集外误差的期望性相同。这就是“没有免费午餐定理” NFL。定理的前提：我们希望学习的真实目标函数f均匀分布，实际并非如此。该定理揭示的是，脱离具体问题，空泛谈“什么学习算法”更好是毫无意义的。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://joshuaqyh.github.io/tags/机器学习/"}]},{"title":"神经网络模型入门--前向和反向传播Python代码实现","date":"2018-07-30T05:58:03.051Z","path":"2018/07/30/神经网络-前向和方向传播/","text":"Just show the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164\"\"\" 神经网络模型简介： 单层神经元（感知机）： 1. 输入向量Wi： 多个同维向量，其中包括多个输入节点和标注为+1的偏置节点 2. 输入权值j1： 每个输入向量（除去偏置节点）在输入神经元时都需要乘上一个相应的权值 3. 输入值 ΣWiji + b： 为每个输入节点乘上相应的权值然后求和再加上偏置节点 4. 激活函数： 通常使用sigmoid函数，作为激活函数，有单极性和双极性之分 5. 输出值： 激活函数的返回值，为神经元网络的输出或者为下一个神经元的输入 多层神经元模型： 为单层神经元的级联，每一层的结构包括多个神经元，接受上一层神经元的输入 产生下一神经元的输出，不同层的神经元之间有相应的权值。 * 层次结构：输入层+隐藏层+输出层 1. 输入层：包含多个输入节点和一个标注为+1的偏置节点，偏置节点不接受输入。 2. 隐藏层：为多个神经元级联而成，每一层数目与输入层数目一致 3. 输出层：只有一个神经元结构，最后一层的隐藏层的作为输出层的输入，输出整个神经网络的结果 前向传播与后向（反向）传播 --- 前向传播对应预测（分类），后向传播对应训练 * 前向传播：就是给定模型参数即输入层的输入和偏置节点，逐一计算各层的输出值，直到最后输出神经网络的结果 * 后向传播： \"\"\"import math# 单极性激活函数，优点连续可导def sigmoid1(x): \"\"\" :sigmoid单极性函数 1/(1+e^-x) :param: x， 函数自变量 :return: sigmoid函数值 \"\"\" return 1.0/(1.0 + math.exp(-x))# 单极性激活函数的导数def dsigmoid1(y): \"\"\" :sigmoid 单极性函数的导数 :param y 函数自变量: :return 函数 运算结果 \"\"\" return y*(1-y)#双极性激活函数 def sigmoid2(x): \"\"\" ：sigmoid双极性函数 tanh （z） : param x,函数自变量 : return 函数因变量 \"\"\" return math.tanh(x)#双性极性激活函数的导数def dsigmoid2(y): \"\"\" : sigmoid双极性函数的导数 ：param x,函数自变量 ：return 函数因变量 \"\"\" return 1.0 - y ** 2# 神经网络前向传播实现方法\"\"\" 前向传播算法，神经网络的输出值即预测值可作为后向传播误差的计算\"\"\"def runNN(self, inputs): \"\"\" ：前向传播进行分类 ：param: inputs-输入参数 ：return: 所属类别 \"\"\" # 输入的数目必须为每一层规定节点数-1，除去偏置节点，不接受输入 if len(inputs) != self.ni - 1: print (\"incorrect number of inputs\") # 将输入向量映射到神经元的输入节点值 # ai - 输入层 for i in range(self.ni - 1): self.ai[i] = inputs[i] #输入层到隐藏层，隐藏层的运算 # ah - 隐藏层的输出值 for j in range(self.nh): sum = 0.0 for i in range(self.ni): sum += (self.ai[i] * self.wi[i][j]) # wi为输入层到隐藏层的权值 权值求和 self.ah[j] = sigmoid(sum) #输入激活函数，产生下一神经元的输入 #隐藏层到输出层，输出层运算 # ao - 最终输出结果 for k in range(self.no): sum = 0.0 for j in range(self.nh): sum += (self.ah[j] * self.wo[j][k]) # wo为隐藏层到输出层的权值 self.ao[k] = sigmoid(sum) return self.ao \"\"\" 后向传播 指的是在训练的时候，根据最终输出的误差（预测值-目标值的平方和/2） 来调整倒数第二层、倒数第三层……第一层的参数的过程。 主要有三种调整 1. 输出层权值的调整 2. 隐藏层权值的调整 3. 偏置节点的调整 算法步骤 1. 随机初始化参数（指权值和偏置节点），对输入利用前向传播计算输出 2. 对输出和隐藏节点进行调整，计算delta。公式比较难写。。 3. 计算梯度可定义学习率影响训练速度，并更新权值参数偏置参数。 \"\"\" def backPropagate(self, targets, N, M): \"\"\" 后向传播算法 :param targets: 实例的类别 :param N: 本次学习率 :param M: 上次学习率 :return: 最终的误差平方和的一半 \"\"\" # http://www.youtube.com/watch?v=aVId8KMsdUU&amp;feature=BFa&amp;list=LLldMCkmXl4j9_v0HeKdNcRA # 计算输出层 deltas # dE/dw[j][k] = (t[k] - ao[k]) * s'( SUM( w[j][k]*ah[j] ) ) * ah[j] output_deltas = [0.0] * self.no for k in range(self.no): error = targets[k] - self.ao[k] output_deltas[k] = error * dsigmoid(self.ao[k]) # 更新输出层权值 for j in range(self.nh): for k in range(self.no): # output_deltas[k] * self.ah[j] 才是 dError/dweight[j][k] change = output_deltas[k] * self.ah[j] self.wo[j][k] += N * change + M * self.co[j][k] self.co[j][k] = change # 计算隐藏层 deltas hidden_deltas = [0.0] * self.nh for j in range(self.nh): error = 0.0 for k in range(self.no): error += output_deltas[k] * self.wo[j][k] hidden_deltas[j] = error * dsigmoid(self.ah[j]) # 更新输入层权值 for i in range(self.ni): for j in range(self.nh): change = hidden_deltas[j] * self.ai[i] # print 'activation',self.ai[i],'synapse',i,j,'change',change self.wi[i][j] += N * change + M * self.ci[i][j] self.ci[i][j] = change # 计算误差平方和 # 1/2 是为了好看，**2 是平方 error = 0.0 for k in range(len(targets)): error = 0.5 * (targets[k] - self.ao[k]) ** 2 return error 来源来自大牛 http://www.hankcs.com/ml/back-propagation-neural-network.html thx！","tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://joshuaqyh.github.io/tags/神经网络/"}]},{"title":"认识经济学原理","date":"2018-07-27T15:28:32.813Z","path":"2018/07/27/认识经济学原理/","text":"经济学学习##十大曼昆经济学原理 ###原理一：人们面临交替关系 典型的交替关系就是 “大炮和黄油”的交替，花更多钱在大炮研发上就注定了减少黄油生产的投入。 这其中 涉及到一个资源配置做出决策的问题。 认识到人们面临交替关系本身并没有告诉我们，人们将会或应该作出什么决策。一个学生不应该仅仅由于要增加用于学习经济学的时间而放弃心理学的学习。社会不应该仅仅由于环境控制降低了我们的物质生活水平而不再保护环境。也不应该仅仅由于帮助穷人扭曲了工作激励而忽视了他们。然而，认识到生活中的交替关系是重要的，因为人们只有了解他们可以得到的选择，才能作出良好的决策。 原理二：某种东西的成本是为了得到它而放弃的东西许多行为选择的成本有时不是那么明显，收益也分为长期和短期，时间成本 ，金钱成本，人力成本都是需要考量的。 原理三： 理性人考虑边际量做决策考虑行为所花的额外成本和额外收益，通过比较这种边际收益和边际成本来，评价比较合理。 原理四：人们会对激励做出反应激励在决定行为中的中心作用是重要的。激励在贸易中可能体现为商品的成本或者收益。 列出并简要解释个人作出决策的四个原理 原理五： 贸易能使每个人状况更好贸易竞争能使国家和个人在相互交易的过程中收益。国与国之间的贸易未必就是像体育比赛一样一方赢，一方输，事实恰好相反，两国之间贸易可以使每个国家状况更好。 原理六：市场通常是组织经济活动的一种好方法经济学家亚当·斯密（Adam Smith）在他 1776 年的著作《国富论》中提出了全部经济学中最有名的观察结果：家庭和企业在市场上相互交易，他们仿佛被一只“看不见的手”所指引，引起了合意的市场结果。本书的目的之一就是要解释这只看不见的手如何施展它的魔力。当你学习经济学时，你将会知道，价格就是看不见的手用来指引经济活动的工具。价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本 关于看不见的手在指引经济活动中的技巧有一个重要推论：当政府阻止价格根据供求自发地调整时，它就限制了看不见的手协调组成经济的千百万家庭和企业的能力。这个推论解释了为什么税收对资源配置有不利的影响：税收扭曲了价格，从而扭曲了家庭和企业的决策。这个推论还解释了租金控制这类直接控制价格的政策所引起的更大伤害。而且，这个推论也解释了共产主义的失败。在共产主义国家中，价格不是在市场上决定的，而是由中央计划者指定。这些计划者缺乏那种在价格对市场力量自由地作出反应时反映在价格中的信息。中央计划者之所以失败，是因为它们在管理经济时把市场上那只看不见的手缚起来了。 ###原理七：政府有时可以改善市场结果 政府干预经济的原因：促进效率和促进平等。政策的目标不是做大经济蛋糕二十改变蛋糕的分割。 ​ 看不见的手通常会使市场有效地配置资源。但是，由于各种原因，有时看不见的手不起作用。经济学家用市场失灵这个词来指市场本身不能有效配置资源的情况。市场失灵的一个可能原因是外部性。外部性是一个人的行动对旁观者福利的影响。污染是一个典型的例子。如果一家化工厂并不承担它排放烟尘的全部成本，它就会大量排放。在这种情况下，政府就可以通过环境保护来增加经济福利。 市场失灵的另一个可能原因是市场势力。市场势力是指一个人（或一小群人）不适当地影响市场价格的能力。例如，假设镇里的每个人都需要水，但只有一口井。这口井的所有者对水的销售就有市场势力——在这种情况下，它是一个垄断者。这口井的所有者并不受残酷竞争的限制，而正常情况下看不见的手正是以这种竞争来制约个人的私利。你将会知道，在这种情况下，规定垄断者收取的价格有可能提高经济效率。 列出并简要解释关于经济相互交易的三个原理 原理八： 一国的生活水平取决于它生产物品与劳务的能力​ 用什么来解释各国和不同时期中生活水平的巨大差别呢？答案之简单出人意料之外。几乎所有生活水平的变动都可以归因于各国生产率的差别——这就是一个工人一小时所生产的物品与劳务量的差别。在那些每单位时间工人能生产大量物品与劳务的国家，大多数人享有高生活水平；在那些工人生产率低的国家，大多数人必须忍受贫困的生活。同样，一国的生产率增长率决定了平均收入增长率。 ​ 生产率和生活水平之间的基本关系是简单的，但它的意义是深远的。如果生产率是生活水平的首要决定因素，那么，其他解释的重要性就应该是次要的。例如，有人想把上个世纪美国工人生活水平的提高归功于工会或最低工资法。但美国工人的真正英雄行为是他们提高了生产率。另一个例子是，一些评论家声称，美国近年来收入增长放慢是由于日本和其他国家日益激烈的竞争。但真正的敌人不是来自国外的竞争，而是美国生产率增长的放慢。 ​ 生产率与生活水平之间的关系对公共政策也有深远的含义。在考虑任何一项政策如何影响生活水平时，关键问题是政策如何影响我们生产物品与劳务的能力。为了提高生活水平，决策者需要通过让工人受到良好的教育，拥有生产物品与劳务需要的工具，以及得到获取最好技术的机会。 原理九： 当政府发行了过多的货币之后，物价上涨货币发行量超量，会导致通货膨胀 原理十：社会面临通货膨胀与失业之间的短期交替关系交替关系称为菲利普斯曲线。 由于价格是粘性的，各种政府政策都具有不同于长期效应的短期效应。例如，当政府减少货币量时，它就减少了人们支出的数量。较低的支出与居高不下的价格结合在一起就减少了企业销售的物品与劳务量。销售量减少又引起企业解雇工人。因此，对价格的变动作出完全的调整之前，货币量减少就暂时增加了失业。 列出并简要解释描述整体经济如何运行的三个原理。 币值稳定–交换的媒介 币值不稳定–投机的工具","tags":[{"name":"经济学，毛概","slug":"经济学，毛概","permalink":"https://joshuaqyh.github.io/tags/经济学，毛概/"}]},{"title":"湫嘤记-壹","date":"2018-07-27T15:28:32.802Z","path":"2018/07/27/湫嘤记-壹/","text":"“我意识到在这个地球上，除了你，没有人能够远程控制我的感情。” ​ ——记生命中一段绵长的奇迹。 一开始并不是想要讲一个宏大而浪漫的故事。没得讲，也不敢想。那天的白衣和相机，那天的短暂相遇，成了我最意想不到的一场奇迹。 一、十二月份的广州已经有些寒意，凉风把天一点一点吹高，很高，高到目光都不知道多久才能到达流云之上。 匆匆忙忙出门的路人A，对这次任务并没有一丝的兴趣。高中母校的校庆将至，每个人都要拍一段对母校的祝福。跟摄影师师兄约好的时间，就是今天了。 要在陌生人面前，对着他手中的相机镜头，挤出商业性微笑，说出一串感性的祝福语吗？开什么玩笑啊……难为情。社交恐惧症，真的很难为情。 万一是个很猥琐的师兄怎么办？万一很不好说话怎么办？就算不差，也实在是太抗拒陌生人了。路人A无奈地想着。 啊，他来了。 “你是XX吗？我就是师兄XXX。” 什么？师兄……原来是这样子的吗？ 路人A不太记得接下来说了些什么。唯一记忆犹新的，是那个将所有的焦虑和压抑都扫到流云之上去的微笑。 是光，冬日里不被云朵遮蔽的阳光，照在瞌睡的猫咪身上，绒毛的轮廓是一圈柔光如万千新生命跃动。 是歌，舒缓得如细水轻盈环绕，又是一股上扬的力量把你托起，升到可以离开所有世俗冷漠的高度。 路人A一直在小小的世界里搜集的，那种不经意间撞击心灵的感动，不经意间绚烂开放的美，似乎又落脚了。 没有架子，没有距离感，一直都那么清爽地咧嘴笑着，弯着湖水般的明亮双眼看着A，给她看相机里的画面。 不值一提的个人片段拍摄结束，故事按理来说到这里也结束了。 某一天朋友B在吃饭时向路人A提起，“XXX师兄真的是个超级温柔的人啊，从来不发脾气，什么都乐意帮忙，又那么有能力，你不知道，我们这次的策划啊，师兄他……” 路人A不知道策划的事。她只知道，这大概就是那一类自己很向往但是从来不可能成为的人吧。一直站在中心，那么耀眼，给所有的人善意，到处奉献自己的温柔，向暖，造暖。 她是个人主义者，不喜集群，闭门造车，琴棋书画只为取悦自己，纷繁复杂能不理则一概不理，从来高傲，却又自卑，无心也无力维持巨大的社交网络，不够有趣便拒之门外，融入世界需要莫大努力，打开心门需要莫大缘分。 可能是孤独，也有人说是独特。一个人流浪久了，自己也不知道是什么了。但是路人A，也是向暖的，也是想要有变化的，也是想靠近光的。 二、路人A咬咬牙，主动在微信上找了师兄。字字斟酌，反反复复，写学术论文般修改底稿，删除，空格，删除，空格，终于回车。 “师兄真的很厉害呢。“ “我想我没办法成为集体喜欢的那种人，但是我真的很欣赏师兄。” 师兄并没有因为生分而怠于回复，而是真诚地聊了很久，像阔别的旧友。每字每句的温度，恰如哥哥轻拍肩的安心感，暖流注入了A的心房。 “被集体喜欢很难，而且也未必就是真的喜欢……个人或者集体主义都好，都是中性词。” 她并没有被冷漠对待，A的心里有小小的欢喜，受宠若惊。 转念一想，欢喜什么？也许，所谓地暖，就是这样的吧。他生性使然，我怎可自作多情。 12月份也就这么悠悠晃过去了。没有其他值得提的故事。 但师兄在A的心中不经意撒下了几叶茶叶，不知不觉已被如获至宝地泡了一壶普洱，愈发醇厚，愈发袭人，空水共氤氲，只是，不敢细细品。 但A想要把这份勇敢继续下去。从小到大，A的行动力一直不强，很多事情都在安排好了的轨道上，只要往前走，不出意外就能得到。但A知道，十八岁以后，这种安稳已经消失了，从今往后的路不再属于被动前进的人。情感，也是如此。 1月1日，心血来潮的A在跨年的零点送出了一张小小的明信片。 “师兄，隐约觉得在师兄身上看到了我缺失的东西——那种冬日阳光般的温柔和热情，愿意付出自己，从不吝啬自己的微笑。愿你继续用那份细腻和温柔治愈世界，时光也一定会眷顾可爱的你……” 他说，哇，好喜欢！谢谢你。你也要继续简单快乐下去呀。 他还说，XX，你短头发很温雅的呢。 被夸了！ 屏幕那边的A在捂嘴笑。温雅……是这样吗？就算是商业性夸奖，也是饮饱喝足的幸福了。 但是，这个时期的A清楚——或者说，在强迫自己用底线思维去说服自己搞清楚，她并不是真的喜欢上了师兄，她只是向暖，仅此而已，而也足够。应当知足，因为贪婪的悬崖一跃下即万劫不复。 也许跨年夜的小小感恩是某种契机吧，一月份的路人A和她阳光一样的师兄开始慢慢变熟，慢慢发现这样那样的共同点，慢慢酝酿这样那样的话题。 A依然很谨慎，她不会每天都去叨扰师兄，她小心翼翼地选择着合适的时间、合适的频率、合适的话题，像雏鸟的羽毛，时不时轻挠师兄某根神经。 三、有一天，A偶然听到了一首歌，如空谷幽兰，却又仿佛能最深入人心中的每个见不到阳光的缝隙和角落，如天鹅绒的触感紧紧包围，所有的不安都暂时消失在悠悠回荡的歌声中，天地和胸膛，融为一体。如果有翅膀，此时的蓝天，一定最适合飞翔…… A马上想到的，是分享给师兄。A突然想到那句话： “那天我在街上看到一棵形状奇怪的榕树，第一反应竟是拍下来给你看。那时候我就知道，我大事不好了……” 这一刻她似乎明白了这种感觉。 A写了一段小小的乐评，连同歌曲一起发给了师兄。 22点50分，没有反应。 23点，没有反应。 23点30分，没有反应。 0点， 没有反应。 1点， …… A控制不住自己每过几分钟就看一眼手机，但终究是失望。她把头埋在枕头里，一遍又一遍地提醒自己该冷静一点了。也许只是一阵风吧，吹过了便过，他的好，只是一种逢场的应变，一种高超的社交技巧，一种对任何人都适用的套路，他是一个善于交际的人，给每个人阳光，可是管不了你绚烂不绚烂。 其实A还是不愿意相信的。师兄不是这样的人。就在两种想法的打架中，她终于撑不住，睡着了。 第二天醒来第一件事仍是抓起手机打开微信。 她看到了师兄回复的消息！一条，两条，三条，四条……很多，很长，很用心。 “细听这首歌，仿似一个歌者在悬崖上低吟浅唱，下视平野，远眺海洋，天空和海洋汇聚成地平线，歌声悠悠的回荡在天地间，还有绕耳的回响……淡淡的孤独与忧伤，却给人从中站起来的力量……” 原来一直都熬夜的师兄，刚好在那天养生了一回，早早入睡。A的消息，师兄是凌晨醒来才看到的。事情就是这么巧合。 师兄的那段文字，跟A的感受完美契合，甚至，A想不到更好的语言去表达出来的部分，师兄表达出来了。能够去感知虚无缥缈的东西，并用文字去表达出来的人，是拥有一颗诗意的心的，是有情怀有温度的人，A始终这么相信着。她再次确信了，师兄的内心，有星辰大海，值得她去探索。 就这么一来二去，A朦胧地感觉到，她和师兄，站在某一座吊桥的两端，相望着对方，想跨出一步，却因为不清楚绳的承重而担忧，是否会因彼此走近而使桥断裂，跌入深渊。 可是A很快就明白，脚底下的并不是深谷。 四、某一天，朋友C说，你怎么好像变温柔了。 是的，她不再那么棱角分明，不再那么冷若冰山，偶尔微笑，偶尔体贴，会去想环路上的猫咪是否有个可以安稳睡觉的家，会去想雨夜执勤的保安身上会不会太单薄，家里是否牵挂……难道这种改变毫无理由？她才突然悟到，自己好像被感染了。 水愈发接近沸腾，躁动的气泡随心跳的频率不断上升，茶香再也无处可逃，飘进了彼此的心里。 然后，他说，你以后就不用再拿我当师兄了，就叫我的名字就好了。 然后，他说，能和你倾心交流真的很开心，我认识的人太多，但这样的人真的不多。 然后，他说，晚上走环路的时候如果一个人害怕，也可以叫上我的。 然后，他说，明天一起复习吗？ 那天晚上，A到凌晨三点半才入睡。翻来覆去的，都是一个月前师兄那模糊的身影。再次见面，他会不会对我印象减分？我长得足够好看吗？我的谈吐足够大方吗？我有很多话题跟他讲吗？不断地在心里一遍遍打草稿，想流程，仿佛迎接一场重要的面试。 令A怎么也没有想到的是，接下来的两天，她几乎都和师兄待在一起。 也许，如果第一次见面那天晚上，A没有跟师兄说：“今天真的很开心，谢谢你”，师兄也就不会说“明天还继续吗？”，故事可能也就没有接下来的进展了。 等到很后来才知道，必然，是心的互相吸引；偶然，是彼此一个小小的表示主动的动作，必然和偶然的叠加，便是难以置信的天时地利人和。 再然后，在人烟稀少的环路，在微风轻拂的中心湖，在碧绿的草地上，在有阳光的树林里，两个人天南地北地聊着，漫无目的，只顾相互接近。彼此的人设一次又一次地崩塌、修缮、重建，越来越真实，越来越完整。 他们见面越来越频繁。而路人A的心里已经发生了翻天覆地的变化。但A还是不敢多想，她怕自己的细腻和敏感会给自己招来祸事——自作多情，终归破灭。 你很耀眼 你很充实 像一阵风 似乎可以吹动所有的安分和不安分 但我不知道你会不会眷顾曾经经过的草地 你的世界像一副完整的拼图 那我应该从哪里进去 她强行关闭自己少女情窦初开的窗户，若无其事地继续相处。她仍坚守着她的底线思维，奢望太多是要吃亏的，即使感受到了某种电波，也不能得意忘形。 这样做朋友也非常幸福不是吗？ 果然，低潮来了。 考试周，整整四天彼此都没有联系。四天，四天里他也许一刻都没有想起过A的事吧。果然还是普通的朋友吧？想得起来了就联系，想不起来就淡如水。A很难过。 倒数第二天，考完试出来，疲累的A一个人听着歌在内环上慢悠悠地走着，看着轻云追着夕阳跑，看着粉色的云块被红色的云块吞噬，紫色的云块和黄色的云块缠绵。 好想跟他说话。好想好想。不怕丢脸了，不想矜持了，不怕造成困扰了。久旱何时逢甘霖。 A终于忍不住拿出手机。聊了那么一两句，A还在码着字，师兄突然说：“先这样吧，我同学催我去打游戏了……” A默默把字一个一个删掉，默默地继续走。那天，A不知道怎么的迷迷糊糊走上了外环，在太阳落山之后迷路了，长长的环路逐渐融化在漆黑夜色中，她无奈地打开导航，在狂风中骑车，骑了很久很久，慌乱之中总算赶回了学校。 晚上，A因为白天的事有点失落，而最后一天又是两门最艰难的专业课，万分疲劳的A扔掉厚重的课本，插上耳机，开始宣泄自己的情感。手指在键盘上飞舞，诗行像疾速前行的火车一样，呼啸着穿过自己的内心。她疯狂地把自己的感情全都宣泄在这密密麻麻的文字里，只怕手速赶不上思维的激流，只怕语言传达不了内心的狂热。 手机屏幕猝不及防地亮了。是那熟悉的头像。茫茫海雾中航行的船只看到了信号塔的灯光。 “在复习吗？要不要出来走走？”看一看时刻，十一点半。 A叫了一声，差点从床上掉下来。她飞快地冲出去，所有的烦乱在这短短的信息里烟消云散。 “深夜的环路，雾气朦胧的恍若仙境，好棒啊。” “呃，什么雾……这是丁达尔效应。” “哇，你能不能诗意一点？现在这个氛围，一定要这么理性嘛？诶，工科男的思维啊……”A已经可以放肆一点地打趣了。 然后文艺到骨子里的文科生A和理性至上的工科生在凌晨寒冷的环路上傻笑了起来。 回想这几天的事，A突然有点谴责自己。我是不是对师兄太不信任了？事到如今，似乎没有必要再因为一些小事而去怀疑师兄的真诚，没必要不断地去拷问这段朦胧的感情。 水深火热的考试周终于过去，A第一次主动约了师兄走环路。 A想杀一个措手不及。“我问你一个问题。你会不会烦我呀？” “为什么突然这么说啊？你突然这样，弄得我好不知所措。” “如果我频繁地找你会打扰到你，那你可以直接说的……我不想过分地影响你的生活。” “我，我不烦你啊……我这个人的性格，不会轻易觉得别人烦的。”这句话让A倒吸一口凉气，她觉得师兄的回答烂透了。A直接就说了，原来你不烦我，是因为你性格的原因，而不是因为我的某些特质或者吸引你的地方啊？ “不，不是这样的……哎呀，怎么说，我……我感觉我最近像个智障了。不知道怎么表达，可是，可是我真的没有烦你啊！” 看到师兄慌乱的样子，A窃喜。她相信的，她相信师兄没有觉得她困扰。但是，她就是想逗一逗师兄。 “你的回答让我伤心了。” “你的提问也让我伤心了。” “为什么？” “居然问我有没有烦你，我肯定伤心啊。” 哦？似乎师兄的情商，其实一点都不低。 五、次日，师兄约了A一起去看电影。 从学校到巨幕影院，有将近一个小时的遥远路程。可是A却觉得这简直是一种馈赠，与他一起走，即使是走在永无止境的潘洛斯阶梯，也没有问题。 晚风清凉，A突然说：“你唱歌给我听好不好？” 羞涩了一下之后，师兄唱了很多。唱了少女的祈祷，唱了童话镇，唱了怯。 “祈求天地放过一双恋人，怕发生的永远别发生。从来没顺利遇上好景降临，如何能重拾信心……” A若有所思。 每次过红绿灯的时候，其实A都在观察师兄的侧脸。这侧脸真的很好看，长长的睫毛，高挺的鼻梁，还有那如水的目光，融化了春天的雪，深藏了如烟的柳絮。 聊着聊着，他们聊到了有点沉重的话题。A在社团里一直有些自卑，不起眼又被孤立，如今走到退社的境地。A垂下了头，难为情地苦笑。 一直盯着地面的A，突然感受到一个温暖的手掌，轻轻地拍了拍自己的后脑勺，轻得像羽毛掉落，掉落在A的内心，然后，烟火盛放。 “不要自卑啦，你很好的，我只希望你好好的呀……” A假装镇定自若，心如止水，继续说着什么话，但大脑里早已不知道自己在说什么。 看电影的过程中，师兄一直把头侧向A的这一边。只要A扶一下眼镜或吸一下鼻子，师兄就警觉地看过来。A抽泣了，他都知道。他会温柔地拍一拍A的额头，用温柔得像哄婴儿的声音说“没事没事，没事哈……” 看的是印度电影《神秘巨星》。电影中尹希娅的小男友，可爱又浪漫、情商极高的钦腾，一举一动都触动情窦初开少女的心弦。对比了一下有些木讷、不解风情的师兄，A凑近他，悄声说了一句“你看人家，情商多高。学习一下？” “啊……怎么办……呜……”师兄一副慌忙又委屈的模样，让A忍俊不禁。 看完电影的A，感动得怎么也止不住眼泪。“现在不要看我，我妆都花了。”“花了也非常好看。” 她心里在想着，如果此刻如此脆弱的我，可以得到师兄一个拥抱，哪怕片刻永恒…… 回去的路上，A的腿很酸痛。她开玩笑般地说，师兄可以背我吗？ “可以啊！上来吧。” “不不不……不用了。”A还是没有勇气接受。 但是A也有自己的小心机。她有意无意地就提起自己走不动了，她多希望，师兄能够扶着她走路。她想要接触，想要接触师兄温暖的手，想要感受到那熟悉的温度，想要靠在他结实的肩膀上看着疏星点点。 结果并没有。也许师兄也在小心翼翼地着棋吧，生怕下错一步，便不复从前。 一路无言，只有脚步声和影子，在路灯下演着默剧，揉碎夜的寒冷。 “你，现在在想什么呀？”师兄打破沉默。 完了，被将一军了。向来善于表达、自诩情商高的A突然舌头打结，捉摸不透这句话的意味，也想不到很好的回答。 “那，那你在想什么？” “你猜。” “我不猜。” 就这样，两个人各怀心事地继续走着，走回了各自的宿舍。 A不想要再静默下去，她把考试周的时候写的诗送给了师兄，希望迟钝的他能够在字里行间领会到哪怕一丝期许。 “我习惯了沉默 习惯了自己的高傲 习惯了比孤独更深一层的独特 习惯了窝在自己的舒适地带 也习惯了冷漠和稀零 也许我很不起眼 但也希望有人能够注意到我 我其实也不甘只是这样 也想有改变 想跟着你一起成长 想要被你所带动 所感染 也想向你尽可能展示我的光怪陆离 想让你感到至少是不无聊的 在兵荒马乱的世界 唱一首有点奇怪的歌 至少是让人值得注意的 很难喜欢君子之交淡如水这句话 只是对淡去的感情无法挽回的一种无奈叹惜 改变不了的事情 万用的道理去解释 解脱自己或者自我麻痹 如果可以像浪花一样热烈 像喷泉一样灵动 为什么要选择淡如水 这样想的我很自私 我知道 每个人都有自己的生活 但是 如果可以用一点点的自私去换一点点的改变 用一点点的改变去一点点走进别人的生活 一点点地让自己变得美好 一点点地为别人变得美好而献出自己微弱的光 该如何感动得泪湿眼眶 我像橡皮糖很黏 因为无法自我消化 所以渴望别人帮忙咀嚼我的情怀 快乐和烦恼 我总是无法独立 千头万绪像蒲公英一样飞舞 去寻找值得落下的地方 去看看——别人的房前屋后 别人的花开花落 别人那些在凌晨降临的软肋和在清晨复苏的坚定 那些写在眼里的信念和藏在心里的叹息 别人那些孤独 冷了深夜铁青的窗沿 别人那些温柔 爬上老家瓦顶的月光 我喜欢仰望有趣的灵魂中深藏的星辰大海 拥抱春暖花开 而你碰巧就在这里 那就让相同的彼此懂得 不同的便互相成就 我希望的 能有心照不宣 像足迹融化在雪地里 也有口口声声 是光点斑驳了夏季 顺着一架很长很长的梯子 从今天爬到明天 后天 坐在未来的屋顶 一起看湛蓝的天空如何变成金色的夕阳 泼墨的流云如何变成厚涂的油画 编织一个很长很长的故事 也从今天写到明天 后天 写在未来的结尾 金色的夕阳又唤醒了金色的朝阳 一轮又一轮 但我们永远年轻” 但是师兄似乎并不解其中味，他说，诗意的灵魂不拘一格。 A想要的不是赞赏呀。 六、接下来就是寒假了。A独自坐车回家，师兄还要留在学校几天。 见不到面的第一天，A有点骚动。深夜，A还是不愿意道晚安。“去睡吧，醒来再聊呀。” 一个小小的约定，给了A对明天的十足期待。睡吧，一早醒来，说不定还会有思念已久的粿汁可以吃。 见不到面的第二天，一早醒来，没有早餐。也没有师兄的消息。中午，没有动静。下午，没有动静。晚上，没有动静。 23点，仍然没有动静。 A无精打采地趴在床上，发了一个“你不要我了”的表情。 他很快就回复了。“没有呀！”他说今天很忙。 那就原谅你吧。 “抗日神剧好雷啊。为什么有枪不用，用刀……还有好多病句，什么几十位烈士壮烈牺牲……” “哎，你看这个就该隐藏智商。它的市场瞄准的又不是我们。你呀，智商该上线的时候不上线，在这时候就上线……” A继续聊。突然间，一个巨大方块唐突地跳了出来，密密麻麻的文字霸占了屏幕。 “有好多话没有说呢，无法准确传达我自己，从何说起呢，试着说一下。 总觉得和你有了默契，你是明白我的，我的快乐与忧虑也很想翻译成言语与你分享，除去忧伤，带给你一束光。 我一开始答应和你走在一起不是因为我要和你在一起，而是你能明白我…… 我特别享受能与你走在夜道中，晚风拂过脸庞，你我倾谈。你伤心需要陪伴的时候，有时说不出来安慰的话，我心头总是一顿软绵绵的无力感，我描述不出那种具体的感觉，但我还是知道的——那叫做喜欢。” A的提醒，让师兄“智商终于上线了” 这就是传说中的……告白吗？ “有好多话没有说呢，无法准确传达我自己，从何说起呢，试着说一下。 总觉得和你有了默契，你是明白我的，我的快乐与忧虑也很想翻译成言语与你分享，除去忧伤，带给你一束光。 我一开始答应和你走在一起不是因为我要和你在一起，而是你能明白我…… 我特别享受能与你走在夜道中，晚风拂过脸庞，你我倾谈。你伤心需要陪伴的时候，有时说不出来安慰的话，我心头总是一顿软绵绵的无力感，我描述不出那种具体的感觉，但我还是知道的——那叫做喜欢。” A还没反应过来，还没意识到这意味着什么，眼泪就先下来了。 泪水一片一片模糊视线，一个一个的方块字却越来越清晰，仿佛复刻进心里，默念便能倒背如流。 她不知道，其实在她按捺不住去找师兄聊的这段时间里，师兄已经在开始准备，开始酝酿，开始勇敢地迈出一步。 “ 我想说，我在2017的尾巴突然变得很幸运……就像我给你的诗写的，你碰巧就在这里，我就那么幸运遇到了你。 我想要的，有人能跟我一起看夕阳和朝霞。我也愿意去仰望他的天空，他的孤独和快乐。 跟你一起的日子，我希望内环有八万里。” “怪我，在你走的前一天晚上没牵起你的手。让你一个人坐车回去，我很不自在。” “那这个锅，你可要好好背着。” “下次见面，我就要抱抱你……” 路人A终于可以卸掉她路人的外衣，就像尹希娅卸掉自己黑色的罩袍。她终于可以说，她不再是路人A，不再是他世界里微不足道的路人，不再是孤独地站在世界边缘的流浪诗人，她是嘤嘤，世界上独一无二的嘤嘤。 他也不再是触不可及的完美师兄，他也有脆弱的一面， 傻气的一面，浪漫的一面，可爱的一面，他是奕浩，世界上独一无二的奕浩。 七、某天晚上，嘤嘤和奕浩在打电话。 他说，“我就想这样子跟你浪费时光，什么也不做，跟你说话。” 她说，“浪费这个词不是很好，改一下。” 怎么改？ ……想了很久。 嘤嘤在奕浩的电脑上敲下了：孕育时光。 然后嘤嘤又想了想，继续敲下了：奕起变老。 然后奕浩移动光标，在最前面敲下了：颖你而在。 因你而在，孕育时光，一起变老。 颖你而在，孕育时光，奕起变老。 嘤嘤又想起了约会时的对话： 我们就这样到处走，没有目的地，哪里都是过程。终点就是你，终点就是我。 我们的故事才刚刚开始，并且永远不会结束。","tags":[{"name":"love","slug":"love","permalink":"https://joshuaqyh.github.io/tags/love/"}]},{"title":"内存管理--操作系统第七章","date":"2018-07-27T15:28:32.788Z","path":"2018/07/27/内存管理--操作系统第七章/","text":"指令和数据绑定到内存地址的条件 编译时— 若知道进程在内存里的驻留地址，直接生成 绝对代码 加载时— 若不知道进程的驻留地址，那么生成可重定位代码 执行时— 如果进程需要进行内存段之间的移动，那么需要延迟到执行时才进行 52703573268 逻辑地址空间和物理地址空间CPU 所生成的地址通常称为逻辑地址( logical address) ，而内存单元所看到的地址(I!IJ加载到内存地址寄存器(memory-address register) 中的地址)通常称为物理地址(physicaladdress) 。 编译和加载时的地址绑定方法生成相同的逻辑地址和物理地址。但是， 执行时的地址绑定方案导致不同的逻辑地址和物理地址。对于这种情况， 通常称逻辑地址为虚拟地址(virtual address)。在本书中， 对逻辑地址和虚拟地址不作区分。由程序所生成的所有逻辑地址的集合称为逻辑地址空间(logical address space), 与这些逻辑地址相对应的所有物理地址的集合称为物理地址空间(physical address space)。因此， 对千执行时地址绑定方案，逻辑地址空间与物理地址空间是不同的。运行时从虚拟地址到物理地址的映射是由被称为内存管理单元(memory-managementunit, MMU)的硬件设备来完成的。 52703635150 动态链接动态链接的概念与动态加载相似。只是这里不是将加载延迟到运行时，而是将链接延迟到运行时 动态加载迄今为止所讨论的是一个进程的整个程序和数据必须处于物理内存中，以便执行。因此进程的大小受物理内存大小的限制。为了获得更好的内存空间使用率，可以使用动态加载(dynamic loading) 。采用动态加载时，一个子程序只有在调用时才被加载。所有子程序都以可重定位的形式保存在磁盘上。主程序装入内存并执行。当一个子程序需要调用另一个子程序时，调用子程序首先检查另一个子程序是否己加载。如果没有，可重定位的链接程序将用来加载所需要的子程序，并更新程序的地址表以反映这→变化。接着，控制传递给新加载的子程序。动态加载的优点是不用的子程序决不会被加载。如果大多数代码需要用来处理异常情况，如错误处理，那么这种方法特别有用。对于这种情况，虽然总体上程序比较大，但是所使用的部分(即加载的部分)可能小很多。动态加载不需要操作系统提供特别的支持。利用这种方法来设计程序主要是用户的责任。不过，操作系统可以帮助程序员，如提供子程序库以实现动态加载。 交换进程需要在内存中以便执行。不过，进程可以暂时从内存中交换(swap) 到备份存储(backing store) 上，当需要再次执行时再调回到内存中。（例子：轮转法CPU调度） 如何进程换出roll out进程换入 roll in，操作系统较少采用。 连续内存分配内存通常分为两个区域:一个用于驻留操作系统，另一个用于用户进程。操作系统可以位于低内存，也可位于高内存。影响这一决定的主要因素是中断向量的位置。由于中断向量通常位于低内存，因此程序员通常将操作系统也放在低内存。在本书中，只讨论操作系统位于低内存的情况。真他情况的讨论类似。通常需要将多个进程同时放在内存中，因此需要考虑如何为输入队列中需要调入内存的进程分配内存空间。采用连续内存分配( contiguous memo可allocation) 时，每个进程位于一个连续的内存区域。 内存映射与保护问题通过采用重定位寄存器(已在8.1.3 小节讨论)和界限地址寄存器(己在8. 1.1小节讨论)，可以实现这种保护。重定位寄存器含有最小的物理地址值;界限地址寄存器含有逻辑地址的范围值(例如，重定位=100040 ，界限=74600) 。有了重定位寄存器和界限地址寄存器，每个逻辑地址必须小于界限地址寄存器。MMU 动’;ti:ltfp将逻辑地址加上重定位寄存器的值后映射成物理地址。映射后的物理地址再送交内存单元 内存分配方法最为简单的内存分配方法之一就是将内存分为多个固定大小的分区(partition) 。每个分区只能容纳一个进程。因此，多道程序的程度会受分区数所限制。如果使用这种多分区方法(multiple-partition method) ，当一个分区空闲时，可以从输入队列中选择一个进程，以调入到空闲分区。当进程终止时，其分区可以被其他进程所使用。这种方法最初为IBM 08/360 操作系统(称为MFT) 所使用，现在已不再使用。下面所描述的方法是固定分区方案的推广(称为MV凹，它主要用于批处理环境。这里所描述的许多思想也可用于采用纯分段内存管理的分时操作系统。 在可变分区(variable-partition) 方案里，操作系统有一个表，用于记录哪些内存可用和哪些内存已被占用。-开始，所有内存都可用于用户进程，因此可以作为一大块可用内存，称为孔(hole) 。当有新进程需要内存时，为该进程查找足够大的孔。如果找到，可以从该孔为该进程分配所需的内存，孔内未分配的内存可以下次再用。随着进程进入系统，它们将被加入到输入队列。操作系统根据所有进程的内存需要和现有可用内存情况来决定哪些进程可分配内存。当进程分配到空间时，它就装入内存，并开始竞争CPU 。当进程终It时，它将释放内存，该内存可以被操作系统分配给输入队列中的其他进程。在任意时候，再→组可用孔(块)大小列表和输入队列。操作系统根据调度算法来对输入队列进行排序。内存不断地分配给进程，直到下-个进程的内存需求不能满足为止，这时没有足够大的可用孔来装入进程。操作系统可以等到有足够大的空间，或者往下扫描输入队列以确定是否有其他内存需求较小的进程可以被满足。通常，→组不同大小的孔分散在内存中。当新进程需要内存时，系统为该进程查找足够大的孔。如果孔太大，那么就分为两块:一块分配给新进程，另一块还回到孔集合。当进程终止时，它将释放其内存，该内存将还给孔集合。如果新孔与其他孔相邻，那么将这些孔合并成大孔。这时，系统可以检查是否杳进程在等待内存~间，新合井的内存空间是否满足等待进程。这种方法是通用动态存储分配问题的二种情况(根据一组空闲孔来分配大小为n 的请求)。这个问题有许多解决方法。从-组可用孔中选择-个空闲孔的最为常用方法有首次适应( first岳1)、最佳适应(best-fiO 、最差适应(worst-fit) 。·首次适应:分配第一小足够大的孔。查找可以从头开始，也可以从上次首次适应结束时开始(避开碎片）。一旦找到足够大的空闲孔，就可以停止。·最佳适应:分配最小的足够大的孔。必须查找整个列表，除非列表按大小排序。这种方法可以产生最小剩余孔。·最差适应:分配最大孔。同样，必须查找整个列表，除非列表按大小排序。这种方法可以产生最大剩余孔，该孔可能比最佳适应方法产生的较小剩余孔更为有用。模拟结果显示首次适应和最佳适应方法在执行时间和利用空间方面都好于最差适应方法。首次适应和最佳适应方法在利用空间方面难分伯仲，但是首次适应方法要更快些。 碎片首次适应方法和最佳适应方法算法都有外部碎片问题(external 企agmentation) 0 随着进程装入和移出内存，空闲内存空间被分为小片段。当所有总的可用内存之和可以满足请求，但并不连续时，这就出现了外部碎片问题，该问题可能很严重。在最坏情况下，每两个进程之间就有空闲块(或浪费〉。如果这些内存是一整块，那么就可以再运行多个进程。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://joshuaqyh.github.io/tags/操作系统/"}]},{"title":"回调函数","date":"2018-07-27T15:28:32.756Z","path":"2018/07/27/回调函数/","text":"什么是回调函数In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time［引自 维基百科 callback］ 回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。 在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。 回调函数 12345678910function add(num1, num2, callback)&#123; var sum = num1 + num2; callback(sum);&#125;function print(num)&#123; console.log(num);&#125;add(1, 2, print); //=&gt;3 匿名回调函数 12345678function add(num1, num2, callback)&#123; var sum = num1 + num2; callback(sum);&#125;add(1, 2, function(sum)&#123; console.log(sum); //=&gt;3&#125;); jQuery中大量的使用了回调函数 123$(&quot;#btn&quot;).click(function() &#123; alert(&quot;button clicked&quot;);&#125;); 回调函数有哪些特点不会立刻执行 回调函数作为参数传递给一个函数的时候，传递的只是函数的定义并不会立即执行。和普通的函数一样，回调函数在函调用函数数中也要通过()运算符调用才会执行。 是个闭包 回调函数是一个闭包，也就是说它能访问到其外层定义的变量。 你再github的用户名和刚才新建的仓库","tags":[{"name":"js, cocos2d.x","slug":"js-cocos2d-x","permalink":"https://joshuaqyh.github.io/tags/js-cocos2d-x/"}]},{"title":"关系数据库设计理论简介","date":"2018-07-27T15:28:32.735Z","path":"2018/07/27/关系数据库设计理论/","text":"[TOC] 函数依赖 X→Y，表示Y依赖于X； X→Y，且Y→X不成立，Y→Z，则X→Z，表示Z传递依赖于X。 函数依赖性质 自反性 传递性 增广性 A → C 可以推出 AB → BC 52686998926 函数依赖的种类（完全函数依赖：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y非函数依赖于X的子集，则称Y完全函数依赖于X。X f &gt;Y）—&gt; Y依赖于X,但未必都依赖X的子集。 （部分函数依赖：在关系模式R（u）中，X,Y是U的子集，Y函数依赖于X 并且 Y函数依赖于X的子集） （函数依赖：某个属性集决定另一个属性集时，例如学生学号属性集Sno决定学生姓名属性集Sname，称Sname函数依赖于Sname ） （平凡函数依赖：Y函数依赖于X,并且Y包含于X，例如（Sno）-&gt;(Sno)、（Sno、Sname）-&gt;（Sno）） （非平凡函数依赖：Y函数依赖于X,并且Y不包含于X,例如(Sno,Sname）-&gt;（Ssex）） 键候选键： 能够唯一表示一个元组，且不含多属性超键： 是指能够唯一表示一个元组的属性集主属性：表示候选键中的属性非主属性：不包含在主键中的属性 判断主键的方法 ：若属性集为{ A , B, C}，A+ = ABC。 则A为主键。（属性闭包判断法） 范式 Normal Forms（1）第一范式1NF：关系中的所以属性值都是不可分割的原子值；（2）第二范式2NF：如果关系是1NF，且每个非主属性都完全依赖于候选键；（3）第三范式3NF：如果关系是1NF，且每个非主属性都不传递依赖于候选键；（4）鲍依斯-科得(巴斯)范式BCNF范式：如果关系是1NF，且每个属性都不传递依赖于候选键。 BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。 52687012974 属性闭包定义：闭包就是由一个属性直接或间接推导出的所有属性的集合。 表示：B的闭包用B+表示。 计算：关系R的属性集X的闭包的步骤如下： 设最终将成为闭包的属性集是Y，把Y初始化为X； . 检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将 其加入到Y中； 重复第二步，直到没有属性可以添加到属性集Y中为止。 最后得到的Y就是X＋ 举例： 例1： R = {A,B,C,D,E} ​ F = {B→CD， D→E, B→A, E→C， AD→B } ​ 则 B+ = B ; B+ = BCD; B+ = BCDA； B+ = BCDAE。（推导过程是属性依赖传递的过程。 ​ 所以最终B+ 包含了R中所有属性。 故B is a key for R。 例2： 有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)闭包。 (1) 令X={AE}，X(0)=AE (2)在F中寻找尚未使用过的左边是AE的子集的函数依赖，结果是: A→D， E→C；所以 X(1)=X(0)DC=ACDE， 显然 X(1)≠X(0). (3) 在F中寻找尚未使用过的左边是ACDE的子集的函数依赖， 结果是: CD→I；所以 X(2)=X(1)I=ACDEI。虽然X（2）≠X(1)，但F中寻找尚未使用过函数依赖的左边已经没有X（2）的子集，所以不必再计算下去，即(AE)+=ACDEI。 例3：f={a-&gt;b，b-&gt;c，a-&gt;d，e-&gt;f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d} 关系模式分解关系模式分解必须遵守两个准则 (1)无损联接性：信息不失真（不增减信息）。 (2)函数依赖保持性：不破坏属性间存在的依赖关系 无损连接分解R的无损分解为X Y，那么 x∩y →x 或者 x∩y → y. ####Dependency Preserving Decomposition 依赖保持分解 关系模式R&lt;U,F&gt;的分解是指R为它的一组子集 ρ={R1&lt;U1,F1&gt;, R2&lt;U2,F2&gt;,…, Rk&lt;Uk,Fk&gt;}所代替的过程。 其中U=U1∪U2∪…∪k ,并且没有Ui≤Uj(表Ui包含于Uj，1≤i,j≤k), Fi是F在Ui上的投影，即Fi={X→Y∈F+∧XY≤Ui}(表XY包含于Ui）。 描述：R被分解为 i个关系子集 Ri。Fi为每个子集的函数依赖投影。 计算函数依赖fi保持的方法就是：Fi∪Fj 推出 fi成立，其中Fi Fj的计算从自身属性和原来函数依赖推导得来。 模式分解是独立保持的条件就是，所有函数依赖Fi的投影的并集的闭包 = F的闭包 思考： 可否是Fi的闭包的并集 = F的闭包？ 回答：不可以，因为每个子集的函数依赖Fi，可能产生跨子集的函数依赖，先求Fi的闭包会产生不完整的闭包关系。 BCNF分解BCNF的要求：函数依赖要么平凡，函数依赖的左侧是超键 如果X→Y违反BCNF, 分解R 为R-Y 和XY。 第三范式分解第三范式的条件： 平凡依赖 x 属于超键 A属于候选键 部分依赖 传递依赖 最小覆盖模型— 简化函数依赖集 补充知识点自然连接在连接运算当中，一种最常用的连接是自然连接。如果关系R与S具有相同的属性组B，且该属性组的值相等时的连接称为自然连接，结果关系的属性集合为R的属性并上S减去属性B的属性集合。 参考的文章 函数依赖集闭包、属性集闭包、超键、候选键和最小函数依赖集 四种范式的实例 函数依赖不懂看这里","tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"https://joshuaqyh.github.io/tags/数据库理论/"}]},{"title":"计算机组成原理课堂笔记","date":"2018-07-27T15:28:32.706Z","path":"2018/07/27/第四章CPU--计组课堂笔记-01/","text":"[TOC] CPU基础概念CPU功能： 指令控制，操作控制，时间控制，数据加工 CPU控制方式：同步控制，异步控制，联合控制 CPU指令周期：取值时间+执行时间 CPU周期：机器周期，总线周期。 CPU中断逻辑中断基础概念 暂停当前程序的执行，转而去执行其他程序，执行完毕之后，重新恢复中断程序的执行 中断源： 人为设置的中断，程序性事故, 硬件故障，外部事件（比如断电） 中断分类：可屏蔽中断和不可屏蔽中断；内部中断和外部中断；软中断和硬中断。 根据CPU是否可以采取响应判断来分类：可屏蔽中断，不可屏蔽中断。 电源断电，CPU不可禁止响应，另外可以根据中断源是否被屏蔽来确定是否给予响应。 ​ ####中断系统需要解决的7个问题： 中断如何向CPU提出诉求 多个中断同时发生请求，CPU如何优先处理？ 硬件排队 软件轮询 CPU响应中断的条件，时间，方式。 中断服务程序入口地址的查找：硬件向量法和软件查询法 中断响应的条件：中断允许触发器必须为1 中断响应时间：当前指令周期结束。（而不是指令执行结束） （2， 3 为中断响应的充分必要条件） CPU响应中断后如何保护现场 中断响应结束之后如何阻止源程序的执行转入中断服务程序的入口地址 中断处理结束后，CPU如何恢复现场 中断处理结束过程中出现了新的中断请求,CPU该如何处理 处理办法 ：中断处理系统中配置响应的软件和硬件 中断屏蔽技术 实现多重中断的条件： 提前设置开中断指令 优先级高的中断源有权屏蔽优先级别低的中断源 中断屏蔽的结果 屏蔽触发器与屏蔽字 改变中断优先登记以及运行轨迹的变化 中断屏蔽字的设置 ​ 多重中断的断点保护 中断响应轨迹图 设置中断屏蔽字改变中断响应优先级 发生多重中断时中断响应逻辑类似于CPU调度中的优先级调度。 引起cpu中断的各种因素（称为中断源） 人为设置的中断（访管指令） 程序性事故 硬件故障 I/O设备 外部事件","tags":[{"name":"计组理论 CPU","slug":"计组理论-CPU","permalink":"https://joshuaqyh.github.io/tags/计组理论-CPU/"}]},{"title":"单周期CPU设计笔记和总结","date":"2018-07-27T15:28:32.694Z","path":"2018/07/27/单周期CPU设计笔记和总结/","text":"单周期CPU设计与实现（实验)每一个指令都在一个时钟周期内完成，称为单周期CPU。 单周期CPU数据通路图该图描述的是CPU中数据，如何在 PC时钟，指令存储器，寄存器组，控制单元，ALU，数据存储器和控制器中如何传送的过程。 MIPS指令的三种格式 R类型 I类型 J类型 算术运算指令 逻辑运算指令 移位指令 比较指令 存储器读写指令 分支指令 跳转指令 停机指令 CPU学习笔记 - 5/15 ###逻辑设计 组合单元— 操作单元 如门 ALU 状态单元— 存储单元，如存储器，寄存器 注： 状态单元需要两个输入（时钟信号值和输入数据值） 一个输出（输出数据值）。 建立数据通路部件认识： PC程序计数器：存储当前指令的地址，每执行完一条指令，PC+4。（一个指令4个字节） 指令存储器： 数据存储器： 寄存器堆： ALU: 加法器： MIPS指令特点","tags":[{"name":"计组实验 CPU","slug":"计组实验-CPU","permalink":"https://joshuaqyh.github.io/tags/计组实验-CPU/"}]},{"title":"Verilog 设计初步","date":"2018-07-27T15:28:32.680Z","path":"2018/07/27/Verilog设计初步/","text":"Verilog设计初步##Verilog 代码模板 1234567891011121314151617181920212223242526//语句关键字字母都为小写字母，大小写敏感//硬件思维来写代码//命名不能以数字开头module &lt;顶层模块名&gt; (输入输出端口列表) //定义输入输出端口列表 output 输出端口列表； //输出端口生声明 input 输入端口列表； //输入输出端口生命 /*定义数据类型，功能定义，函数实现*/ reg 信号名； //逻辑功能定义 assign&lt;结果信号名&gt; = &lt;表达式&gt;; //用always块描述逻辑功能 always @(&lt;敏感信号&gt;) begin //过程赋值运算 //语句，if else while task end //调用其他模块 &lt;调用模块名module_name&gt;&lt;例化模块名&gt;(&lt;端口列表&gt;)； //门元件例化 门元件关键字&lt;例化门元件名&gt;(&lt;端口列表port_list&gt;);endmodule 四位选择器 123456789module mux4_1(out,in0, in1, in2,in4,sel); output out; input in0,in1,in2,in3; input[1:0] reg out; always @（in0 or in1 or in2 or in3 or sel) begin case(sel) 数据类型及运算符 整数类型 构成是：字符宽度+进制+数值。 例如：2’0xd5; 宽度为2的十六进制d5。 逻辑类型 高低电平 1 0，电路里体现为电压的区间 x：未知 z: 高阻 net类型 常用的是wire。用法是 wire[7:0] databus。 //databus宽度8 寄存器类型 reg integer time real realtime parameter参数 用来定义符号常量。 parameter sel = 8’ha3。 向量类型 逻辑运算符 位运算符 三目运算 位拼接运算符 下例采用数据流方式描述1位全加器。 在本例中，有两个连续赋值语句。这些赋值语句是并发的，与其书写的顺序无关。只要连续赋值语句右端表达式中操作数的值变化(即有事件发生), 连续赋值语句即被执行。如果A变化，则两个连续赋值都被计算，即同时对右端表达式求值，并将结果赋给左端目标。 语句 initial always @（敏感信号） @ (posedge clk) 上升沿 @ (negedge clk) 下降沿触发 赋值语句 连续赋值语句assign 只要连续赋值语句右端表达式中操作数的值变化, 连续赋值语句即被执行。 阻塞赋值 a = b; ————-非时序赋值（组合） 非阻塞赋值 a&lt;=b ————时序赋值中使用 时序和组合在电路上的表现是时序赋值过程中需要等待时钟沿来触发。 函数设计特点层次化模块化顶层模块和底层模块的设计方法，将模块细分为若干个子模块，在底层实现子模块功能，在顶层组合各个子模块。","tags":[{"name":"verilog 计组实验","slug":"verilog-计组实验","permalink":"https://joshuaqyh.github.io/tags/verilog-计组实验/"}]},{"title":"SQL用法总结","date":"2018-07-27T15:28:32.663Z","path":"2018/07/27/SQL 用法--postgresql/","text":"##SQL 用法–postgresql [TOC] 运算符https://www.postgresql.org/docs/9.1/static/functions-geometry.html 官方链接最全。 表格操作建表12345678CREATE TABLE users ( user_id INT AUTO_INCREMENT PRIMARY KEY, //声明主键 username VARCHAR(255) NOT NULL UNIQUE, //声明非空，唯一 password VARCHAR(255) NOT NULL FOREIGN KEY (user_id) REFERENCES projects (user_id) //声明 user_id为外键引用自表格projects); 改表123456ALTER TABLE table_nameADD new_colum data_type column_constraint [AFTER existing_column]; // 加列DROP COLUMN max_limit, //删除列MODIFY fee NUMERIC (10, 2) NOT NULL; //修改列约束 删表TRUNCATE table_name; // 将行清空，但表头依旧保留 DROP table table_name; //删除整个表格 PRIMARY KEY constraint UNIQUE constraint The number of constraints One Many NULL values Do not allow Allow 表的连接内连接–INNER JOIN两个表使用内连接，通过指定一个属性来匹配，若两个表的同一属性具有相同值，则保留在连接表中，其余不相等的行则消去。 图解 使用示例（内连接也可以连接多张表格） 12345SELECT A.nFROM AINNER JOIN B ON B.n = A.n;INNER JOIN C ON C.n = A.n; 全连接–FUll OUTER JOIN指定连接条件，属性值相同的行保留，但不重复，属性值不同的值保留，但存在某些为Null的情况。 用法示例 123SELECT column_listFROM AFULL OUTER JOIN B ON B.n = A.n; 左连接–LEFT JOIN对几个将要连接的表指定条件进行连接，属性匹配的时候，会保留左表所有属性，即便右表属性为NULL,但不会存在左表属性为NULL的情况。 代码示例： 12345SELECT A.nFROM ALEFT JOIN B ON B.n = A.n; 右连接–RIGHT JOIN和左连接相反，用法如下： 12345SELECT A.nFROM ALEFT JOIN B ON B.n = A.n; 交叉连接–CROSS JOIN看图就知道。。。交叉连接结果的表格是 两表行数相乘。需要指出的一点就是两个表相连不需要指定cross join。 12345SELECT column_listFROM A, B; 创建索引 PostgreSQL provides several index types: B-tree, Hash, GiST and GIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the CREATE INDEX command creates B-tree indexes, which fit the most common situations. 创建b_tree索引语法： create index index_name ON table_name(column_name) postgresql默认b树索引。官方描述如下： B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators: &lt; &lt;= = &gt;= &gt; Constructs equivalent to combinations of these operators, such as BETWEEN and IN , can also be implemented with a B-tree index search. Also, an IS NULL or IS NOT NULL condition on an index column can be used with a B-tree index. 上述说明b_tree在范围查询中比较有效，也可以用于顺序检索数据。 当查询条件为范围查询时(运算符是 &gt; &lt; &lt;= &gt;= = is null, is not null, between and ,in)，b_tree索引可以体现较为良好的性能。 创建hash索引语法： create index index_name on table_name using hash(column_name) 官方描述 Hash indexes can only handle simple equality comparisons. The query planner will consider using a hash index whenever an indexed column is involved in a comparison using the = operator. 上述说明，hash索引仅仅在处理简单的等值比较-(=) 中相对有效。 使用GiST索引(错误）语法： create index index_name on table_name using GiST（column_name) 官方描述 GiST indexes are not a single kind of index, but rather an infrastructure within which many different indexing strategies can be implemented. Accordingly, the particular operators with which a GiST index can be used vary depending on the indexing strategy (the operator class). As an example, the standard distribution of PostgreSQL includes GiST operator classes for several two-dimensional geometric data types, which support indexed queries using these operators: &lt;&lt; &amp;&lt; &amp;&gt; &gt;&gt; `&lt;&lt; ` `&amp;&lt; ` ` &amp;&gt;` ` &gt;&gt;` @&gt; &lt;@ ~= &amp;&amp; 上述描述可知，gist 不是单一类型的索引，实现了不同策略索引的基础结构。可以根据索引策略（运算符类）来采取不同的索引策略。 详见官方文档gist index 使用GIN索引gin索引能够用于优化级的最近邻查找。 GIN indexes are inverted indexes which can handle values that contain more than one key, arrays for example. Like GiST, GIN can support many different user-defined indexing strategies and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQLincludes GIN operator classes for one-dimensional arrays, which support indexed queries using these operators: &lt;@ @&gt; = &amp;&amp; 用法查看官方描述gin index. 分析效率 explain将explain(analyze)置于语句的开始，结果将返回语句执行效率有关的数值。 123456789101112explain （analyze） Select s_name, s_address, s_nationkey From table_a Where s_suppkey = 717;explain （analyze） Select s_name, s_address, s_nationkey From b_tree_a Where s_suppkey = 717;explain （analyze） Select s_name, s_address, s_nationkey From hash_a Where s_suppkey = 717; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126Click To Expand CodePostgreSQLThe following script creates the HR sample database structure in PostgreSQL.CREATE TABLE regions ( region_id SERIAL PRIMARY KEY, region_name CHARACTER VARYING (25));CREATE TABLE countries ( country_id CHARACTER (2) PRIMARY KEY, country_name CHARACTER VARYING (40), region_id INTEGER NOT NULL, FOREIGN KEY (region_id) REFERENCES regions (region_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE locations ( location_id SERIAL PRIMARY KEY, street_address CHARACTER VARYING (40), postal_code CHARACTER VARYING (12), city CHARACTER VARYING (30) NOT NULL, state_province CHARACTER VARYING (25), country_id CHARACTER (2) NOT NULL, FOREIGN KEY (country_id) REFERENCES countries (country_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE departments ( department_id SERIAL PRIMARY KEY, department_name CHARACTER VARYING (30) NOT NULL, location_id INTEGER, FOREIGN KEY (location_id) REFERENCES locations (location_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE jobs ( job_id SERIAL PRIMARY KEY, job_title CHARACTER VARYING (35) NOT NULL, min_salary NUMERIC (8, 2), max_salary NUMERIC (8, 2));CREATE TABLE employees ( employee_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (20), last_name CHARACTER VARYING (25) NOT NULL, email CHARACTER VARYING (100) NOT NULL, phone_number CHARACTER VARYING (20), hire_date DATE NOT NULL, job_id INTEGER NOT NULL, salary NUMERIC (8, 2) NOT NULL, manager_id INTEGER, department_id INTEGER, FOREIGN KEY (job_id) REFERENCES jobs (job_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (department_id) REFERENCES departments (department_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (manager_id) REFERENCES employees (employee_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE dependents ( dependent_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (50) NOT NULL, last_name CHARACTER VARYING (50) NOT NULL, relationship CHARACTER VARYING (25) NOT NULL, employee_id INTEGER NOT NULL, FOREIGN KEY (employee_id) REFERENCES employees (employee_id) ON DELETE CASCADE ON UPDATE CASCADE);CREATE TABLE regions ( region_id SERIAL PRIMARY KEY, region_name CHARACTER VARYING (25)); CREATE TABLE countries ( country_id CHARACTER (2) PRIMARY KEY, country_name CHARACTER VARYING (40), region_id INTEGER NOT NULL, FOREIGN KEY (region_id) REFERENCES regions (region_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE locations ( location_id SERIAL PRIMARY KEY, street_address CHARACTER VARYING (40), postal_code CHARACTER VARYING (12), city CHARACTER VARYING (30) NOT NULL, state_province CHARACTER VARYING (25), country_id CHARACTER (2) NOT NULL, FOREIGN KEY (country_id) REFERENCES countries (country_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE departments ( department_id SERIAL PRIMARY KEY, department_name CHARACTER VARYING (30) NOT NULL, location_id INTEGER, FOREIGN KEY (location_id) REFERENCES locations (location_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE jobs ( job_id SERIAL PRIMARY KEY, job_title CHARACTER VARYING (35) NOT NULL, min_salary NUMERIC (8, 2), max_salary NUMERIC (8, 2)); CREATE TABLE employees ( employee_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (20), last_name CHARACTER VARYING (25) NOT NULL, email CHARACTER VARYING (100) NOT NULL, phone_number CHARACTER VARYING (20), hire_date DATE NOT NULL, job_id INTEGER NOT NULL, salary NUMERIC (8, 2) NOT NULL, manager_id INTEGER, department_id INTEGER, FOREIGN KEY (job_id) REFERENCES jobs (job_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (department_id) REFERENCES departments (department_id) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (manager_id) REFERENCES employees (employee_id) ON UPDATE CASCADE ON DELETE CASCADE); CREATE TABLE dependents ( dependent_id SERIAL PRIMARY KEY, first_name CHARACTER VARYING (50) NOT NULL, last_name CHARACTER VARYING (50) NOT NULL, relationship CHARACTER VARYING (25) NOT NULL, employee_id INTEGER NOT NULL, FOREIGN KEY (employee_id) REFERENCES employees (employee_id) ON DELETE CASCADE ON UPDATE CASCADE);","tags":[{"name":"postgresql","slug":"postgresql","permalink":"https://joshuaqyh.github.io/tags/postgresql/"}]},{"title":"cocos2d学习丨坑和解决办法","date":"2018-07-27T15:28:32.642Z","path":"2018/07/27/Q&A_cocos2d/","text":"cocos2d 使用遇到的问题和解决办法[TOC] Q 1： 如何解决中文乱码？A1: 直接看正确的示例代码，杂七杂八的代码太多，跟上版本的是下面这个 xml文件 1234&lt;dict&gt; &lt;key&gt;HelloWorldStringkey&gt; &lt;string&gt;你好，世界string&gt; dict&gt; 解析xml文件的代码。需要注意按键值获取中文内容保存为char*指针后，用于创建的label类是CCLabelTTF，而不是Label. 1234567891011121314151617//利用CCDictionary来读取xml CCDictionary *strings = CCDictionary::createWithContentsOfFile(\"strings.xml\");//载入资源文件夹的strings.xml //读取HelloWorld键中的值objectForKey根据key，获取对应的string const char *HelloWorld = ((CCString*)strings-&gt;objectForKey(\"HelloWorldString\"))-&gt;m_sString.c_str(); //获取屏幕的尺寸、位置信息等 CCSize visibleSize = CCDirector::sharedDirector()-&gt;getVisibleSize(); //乱码文字 CCLabelTTF *label0 = CCLabelTTF::create(\"你好，世界\",\"arial\",72); label0-&gt;setPosition(ccp(visibleSize.width/2,2*visibleSize.height/3)); this-&gt;addChild(label0); //正常中文 CCLabelTTF *label1 = CCLabelTTF::create(HelloWorld,\"arial\",72); label1-&gt;setPosition(ccp(visibleSize.width/2,visibleSize.height/3)); this-&gt;addChild(label1); Q2：xml文件资源（字体,图片等等）的放置的正确位置？A2：xml文件需要放在整个顶级项目文件里头的resources文件夹，而不是放在win32项目的resource…..坑。。具体可以看初始代码引用字体文件的路径。 Q3： 一开始打开项目文件发现文件不可用或者项目文件被卸载？A3：文件路径被改变，重新解压cocos安装包，重新安装。并且存放路径不能出现中文。 Q4: 编译时出现 libbox.lib不是有效的win32程序？A4：需要将hellococos项目设置为启动项。 Q5：当出现许多.h 文件不可用的时候？A5：重定解决方案目标 Q6:本地坐标系和世界坐标系如何互换计算1234CCPoint p1 = sprite2-&gt;convertToNodeSpace(sprite1-&gt;getPosition());CCPoint p2 = sprite2-&gt;convertToWorldSpace(sprite1-&gt;getPosition());CCPoint p3 = sprite2-&gt;convertToNodeSpaceAR(sprite1-&gt;getPosition());CCPoint p4 = sprite2-&gt;convertToWorldSpaceAR(sprite1-&gt;getPosition()); 计算方法都是用sprite1的坐标去加减sprite2的坐标，针对本地坐标系就用减法，针对世界坐标系就用加法。","tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"https://joshuaqyh.github.io/tags/cocos2d/"}]},{"title":"ant,junit,vim,java","date":"2018-07-27T15:28:32.625Z","path":"2018/07/27/Leanring_report-ant-junit-vim-java/","text":"Vim简介Vim是一款上古编辑器，被广大程序员成为编辑器之神，这与之强大的编辑功能和编辑效率是分不开的。和Emace一样都在代码行业享有盛誉。vim最为重要的一点就是一切操作几乎可以舍弃鼠标，熟悉了vim命令的话，光靠键盘指令可以使开发效率迅速提高。 Vim的安装Linux下在Ubuntu平台下控制台敲入下列指令即可自动安装。 sudo apt-get install vim Windows下去官网 直接下载使用。 Vim常用指令和教程首先值得注意的一点就是其实vim是自带教程的Vimtutor,s使用方法是linux下输入命令vimtutor,即可开启教程，这属于官方教程， 最为详细，没有之一。 在这里介绍一些常用的vim命令，有利于快速上手vim。 1. 创建或打开文件 vim filename vim helloworld.java 2.添加内容一开始进入处于正常模式在编辑窗口直接输入i,a,o等字符可以进入输入模式，可以在屏幕下方看到insert单词。按左上角Esc键可以回到正常模式，使用各种方便的指令。以下指令均在正常模式下进行。 3.删除内容dd可以删除光标所在的一整行。 ndd可以删除光标以下的n行 4. 复制内容yy可以复制光标所在行的字符nyy可以复制光标以下的n行字符 5.粘贴内容p/P作用时粘贴字符，小写p将已复制的字符粘贴到光标以下，大写P将字符粘贴到光标以上。 6. 撤销内容撤销指令使用u,类似于windows上的ctrl z`。 7. 保存文件先进入正常模式Esc，然后输入:。然后输入： q 离开vim w 保存内容 wq 保存内容并离开vim,回到命令行 其他还有许多可以提高效率的指令在这里就不多赘述啦。 ​ Java知识入门###初探java 从hello world入门, 初步体会java这一门面向对象编程语言。在HelloWorld.java文件中键入以下代码。（注意文件名称必须和类名一致） 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 其中用到的编译指令是 javac HelloWorld.java 命令行没有弹出其他消息，即为编译成功。 执行指令是 java HelloWorld 这里用到两个重要指令javac java ，分别是编译和执行指令。 ###基础知识 由于已经学习过C++，java语言在一定程度上和C++是类似的，所以在Java入门学习上可以直接跳过基础语法，对象和类，基本数据类型，运算符，循环结构，分支结构。 Java面向对象java继承java继承的概念和C++类似，同样是定义一个父类，然后定义一个子类，来继承父类的属性，和C++不同的是，java用关键字extends 来表示继承关系。继承格式是 1234567class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; ####继承的特性 子类拥有父类非private的属性，方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。 ​ ####继承的关键字 关键字 作用 extends 单一继承 implements 继承多个父类 super 实现对父类父类成员的访问，引用父类 this 指向自己的引用 final 将自身定义为不可继承的类 java重写和重载重写#####重写含义 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。。 重写方法的原则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 代码实例1234567891011121314151617181920class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 运行的结果是 狗可以跑和走 可以看到在Dog类中重写了move()方法，传入的参数和返回类型和原来父类的方法一致，但内部代码可以修改。 ####重载 #####重载含义 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 重载的规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 代码实例1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println(\"test1\"); return 1; &#125; public void test(int a)&#123; System.out.println(\"test2\"); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println(\"test3\"); return \"returntest3\"; &#125; public String test(String s,int a)&#123; System.out.println(\"test4\"); return \"returntest4\"; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); &#125;&#125; 运行结果是 test1 test2 test3 test4 从运行结果看，调用的传参不同的函数顺序执行。 多态多态就是对象多种表现形式的体现。 #####多态存在的三个必要条件 继承 重写 父类引用指向子类对象 这里提供一份代码以便理解。大意就是一个抽象父类声明但不定义一个方法，在其他子类中可以重写这个方法。 123456789101112131415161718192021abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; public void work() &#123; System.out.println(\"抓老鼠\"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; public void work() &#123; System.out.println(\"看家\"); &#125; &#125; ###java组件部分设计 Swing在本次实训实验中利用了Swing这个java的GUI工具包，以实现一个简单的计算器。其中的主要用途是引用这些包的相关控件，控件的相关接口，同时给这些控件注册事件，建立事件处理逻辑。 介绍控件，首先应提到JComponet 。 JComponent Swing 的整个可视组件库的基础构造块是 JComponent。它是所有组件的父类。它是一个抽象类，所以不能创建 JComponent，但是作为类层次结构的结果，从字面意义来说它包含了数百个函数，Swing 中的每个组件都可以使用这些函数。 注意： 每一个控件都是一个类，具有许多接口函数，在eclipes这个IDE上可以轻松获取。使用方法：鼠标移动到某一个控件类名，按ctrl键点击类名，即可弹出这个控件类里头详细的函数定义。 常用的控件集合 控件 用途 JLabel 用作文本描述 JButton 按钮 JFrame 窗口 JPanel 控件容器 JTextField 文本输入框 JCheckBox 确认框 GridLayout 生成网格状的布局 Tips: 任何一个控件都有Add()的方法，意味着每一个控件都可以添加到另外一个控件里。 注册事件的方法以下以button为例，进行两种常用方式的注册。 方法1 匿名内部类实现123456button.addActionListener( new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"你按了按钮一\"); &#125; &#125;); //调用监听函数并定义监听事件 方法2 利用一般内部类实现1234567button.addActionListener(new Button2ActionListener()); private class Button1ActionListener implements ActionListener&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"你按了按钮一\"); &#125; &#125; //将事件处理为一个类事件 用了以上的基础知识就可以解决一个简单计算器的实现啦。 Junit 学习和使用###Junit是什么 JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。 JUnit提供： 断言测试预期结果。 测试功能共享通用的测试数据。 测试套件轻松地组织和运行测试。 图形和文本测试运行。 JUnit用于测试： 整个对象 对象的一部分 - 交互的方法或一些方法 几个对象之间的互动(交互) ​ ###JUnit的特点 JUnit是用于编写和运行测试的开源框架。 提供了注释，以确定测试方法。 提供断言测试预期结果。 提供了测试运行的运行测试。 JUnit测试让您可以更快地编写代码，提高质量 JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。 JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。 JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。 Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。 注解 描述 @Testpublic void method() 测试注释指示该公共无效方法它所附着可以作为一个测试用例。 @Beforepublic void method() Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。 @BeforeClasspublic static void method() BeforeClass注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。 @Afterpublic void method() After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等) @AfterClasspublic static void method() 当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于BeforeClass)的方法必须定义为静态。 @Ignorepublic static void method() 当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为@Ignore的方法将不被执行。","tags":[{"name":"编程软件 vim java","slug":"编程软件-vim-java","permalink":"https://joshuaqyh.github.io/tags/编程软件-vim-java/"}]},{"title":"git学习","date":"2018-07-27T15:28:32.596Z","path":"2018/07/27/git学习/","text":"从本地添加项目到github仓库在git bash 命令行下进行： 123456789$ mkdir project //本地新建一个仓库，项目文件夹$ cd project // 进入文件夹$ git init // 初始化$ git remote add origin git@github.com:username/RepoName.git // 添加远程地址,换用户名和仓库名$ cat .git/config //查看配置文件是否添加远程地址成功$ git add -A // 上传本地项目$ git commit -m \"first commit\" //项目注释$ git push origin master // 上传仓库初始代码$ git status //查看提交情况，这一行出现在commit之前 git基础命令 git staus ————————————————————————- 进入仓库，查看仓库文件状态 git diff + filename ———————————————————— 查看文件与上一次提交时的不同 git add + filename || git commit -m “注释” ———————提交到库 —此处相当于代码存档 git log ——————————————————————————查看存档历史 git reset –hard HEAD^ ———————————————— —-一个^ 表示回退几次; HEA~100 回退一百次 git reset –hard 版本id —————————————————–回溯版本id git reflog ——————————————————————– 查看历史指令，可以看到之前的版本id git checkout – filename —————————————————— 舍弃上一次更改 git pull —————————————————————————— 更新内容 暂存区概念前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 多次修改的版本 可以多次add 保留到暂存区之后，一次性commit提交到版本库。 分支命令查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 提交分支： git push origin branchname // orgin 相当于仓库， 意思为提交到仓库的某一分支 git 协同多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 ​ ​ 标签敲命令git tag &lt;name&gt;就可以打一个新标签： 1$ git tag v1.0 可以用命令git tag查看所有标签： 12$ git tagv1.0 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1234$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： 123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted] v0.9 一些git学习链接git 代码分享 廖雪峰git教程","tags":[{"name":"git","slug":"git","permalink":"https://joshuaqyh.github.io/tags/git/"}]},{"title":"操作系统第五章之CPU调度算法（重点）","date":"2018-07-27T15:28:32.558Z","path":"2018/07/27/CPU调度算法/","text":"CPU调度算法 先到先服务 fcfs – CPU请求次序 缺点：FCFS 算法对于分时系统(每个用户需要定时地得到一定的CPU 时间)是特别麻烦的。允许一个进程保持CPU 时间过长将是个严重错误。 最短作业优先sjf – 平均等待时间最短 | 最优 存在抢占和非抢占 抢占（最短剩余时间优先）：由于CPU到达时间和CPU区间大小的差异，长作业可以优先处理，但出现短作业请求的时候，优先处理短作业 ​ 优先级调度 – fcfs sjf都是特殊的优先级调度 每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU 。具有相同优先级的进程按FCFS 顺序调度。 同样存在抢占调度的情况 问题：存在阻塞或饥饿– 存在进程一直处于等待状态 解决方法：老化– 等待时间越长，优先级提高 优先级可通过内部或外部方式来定义。内部定义优先级使用一些测量数据以计算进程优先级。例如，时间极限、内存要求、打开文件的数量和平均I/O 区间与平均CPU 区间之比都可以用于计算优先级。外部优先级是通过操作系统之外的准则来定义的，如进程重要性、用于支付使用计算机的费用类型和数量、赞助工作的单位、其他(通常为政治)因素。 ​ 轮转法调度 – rr ( round robin 为分时系统而设置的 平均等待时间较长，响应时间较长 定义较小的时间处理单元，时间片。时间片和周转时间有关，要考虑和上下文切换的时间比例 进程存储在一个fifo循环队列中 ​ 多级队列调度 多级队列 调度算法(multilevel queue scheduling algorithm) 将就绪队列分成多个独立队列(见图5.6) 。根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被永久地分配到一个队列。 根据进程的性质和属性对进程进行分组的方法，给不同的队列设立优先级。比如前台交互进程和后台批处理过程。前台交互进程较高。 每个队列可以采用不同的调度算法，前台交互需要等待时间较短的调度算法，通常选用rr调度，后台批处理可以选择fcfs,优先级调度算法。 缺点同样会产生阻塞的情况 队列之间必须有调度，通常采用固定优先级抢占调度。例如，前台队列可以比后台队列具有绝对的优先级。现在来研究一下具有5 个队列的多级队列调度算法的例子，按优先级来排列:①系统进程。②交互进程。③交互编辑进程。④批处理进程。⑤学生进程。 多级反馈队列调度 多级反馈队列调度算法(multilevel feedback queue scheduling algorithm) 允许进程在队列之间移动。主要思想是根据不同CPU 区间的特点以区分进程。如果进程使用过多CPU 时间，那么它会被转移到更低优先级队列。这种方案将νo 约束和交互进程留在更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。 通常，多级反馈队列调度程序可由下列参数来定义:.队列数量。· 每个队列的调度算法。· 用以确定何时升级到更高优先级队列的方法。. 用以确定何时降级到更低优先级队列的方法。· 用以确定进程在需要服务时应进入哪个队列的方法。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://joshuaqyh.github.io/tags/操作系统/"}]},{"title":"知乎问答——如何用互联网思维卖馒头","date":"2018-07-27T15:28:32.545Z","path":"2018/07/27/知乎问答_如何用互联网思维买馒头/","text":"回答一一、规划 slogan：做中国好馒头、做好中国馒头 使命：让全中国人重新吃上安心馒头 愿景：成为世界顶级的馒头品牌 广告语：这一口，谁不爱 目标人群：新中产阶级 新中产消费观的最大特征：相较于价格，他们在意质量，对于高质量的商品和服务，他们愿意为之付出更高的代价。较高的收入与体面的工作给中产带来片刻的欣慰，但不安与焦虑才是中产光鲜外表下最戳心的痛点，消费升级正是他们面对这种焦虑选择的解决方案。 二、设计 1.品牌 品牌要能让人产生联想，要好记，比如：”真馒头” 2.设计 包装要讲究，但重点是一定要去德国买一个红点奖。 每个包装上，还必须有扎心的文案，比如: 我们拼尽全力，不是为了活成别人想要的模样 你只来了一下子，却改变了我一辈子 我有馒头，你有故事吗? 3.产品 要秉承匠心精神，只做单一产品–真•葱花馒头，将一款产品做到极致。 但是可以根据用户人群推出专属款，比如 有助记忆力的儿童款 提高睡眠质量的老人款 4.门店 不同类型的门店来满足用户多元化的场景需求，包括满足用户线下社交需求的旗舰店，满足亲子活动的DIY体验店，以及快速自提、服务商务人群的快取店，满足客户外送需求的外卖厨房店。通过差异化的门店布局，实现对消费者日常生活全方位覆盖。 5.定价 统一价19.9元！！没有足够的利润空间，618、双11、双12你拿什么打折？ 三、营销 1.讲故事 馒头的面全部来自北纬36°黄金优麦区种植的8848号小麦，纯手工脱粒。 蒸馒头的水，选自长白山矿物质水，再经过36道工艺人工萃取。 创新思维碰撞传统手工技艺，再造中国馒头新未来。 2.讲情怀 创始人211名校毕业后，放弃BTA百万年薪自主创业；尝遍了全国各地大街小巷所有的馒头，拜访数十位隐居的大师，经历了同事朋友的嘲讽、女朋友的离等非常人所能经历的磨难后，终于发明了拥有独特、唯一口味的”真馒头”。 3.软文推广 《震惊！男人吃了沉默，女人吃了流泪》 《感动！一个馒头如果没有情怀，那它和面粉有什么区别》 《刚刚！人人都在疯抢这款馒头》 … 4.造气氛 找很多人来回排队，不用多讲，这是网红店的标配。但是排队的人员组成还是要有讲究的，需要有学生、青年、白领、中年人，而且不能一起到，要分批到。 5.制造热点事件 哭诉鹅厂抄袭商业模式 喊话某互联网大佬，打赌3年后比营业额 6.社会化传播 赞助绝地求生，新增能量馒头，吃一个血条全满！ 雇人拿着馒头去starbuck、costa，让咖啡、苹果笔记本、馒头成为新一代的装B三件套。 抢在韩国人前为馒头申遗！ 7.微微一抖 微博：每天去抢杜蕾斯、回忆专用小马甲的沙发，设置转发有奖活动； 微信公众号：每天深夜10点，推送一条荷尔蒙满满的语音鸡汤，一定要煽情！ 抖音：做一个卡通吉祥物，天天耍贱，卖萌，用户爱看什么拍什么。 8.饥饿营销 每家门店每天限量8888个，卖完即止。第二天的馒头需要提前预约。 9.裂变营销 给好友免费送馒头，他吃你也吃。 10.社群运营 建立真馒头的粉丝群，收集种子用户的建议反馈，经常与粉丝互动。邀请5个人进群可免费领取一个馒头，群成员可享受新品内测试吃福利。 11.APP运营 开启步数兑换优惠券功能，倡导绿色出行； 消费有积分，积分可以浇水种小麦，小麦长成后可以直接磨成面，寄给用户。 增加交友功能，注册必须上传吃馒头的自拍照，可以查看5公里内异性用户的照片，但是必须相互点赞，才能加好友聊天。 12.会员体系 充值5000黄金会员，享8折优惠；充值10000白金会员，全部5折，生日赠送定制版馒头。 13.配送模式 可以在APP或公众号上自助完成下单，下单时可以选择温度、辣度等，制作好了系统会发提示，凭二维码领取，节约排队时间；如果选择外送，在已经开通的外送区域15分钟左右送到，超过30分钟免费。 四、实现盈利 炒作互联网新零售+馒头的成功之道，然后花钱发一堆新闻通稿，进行大量商业路演，约见各类ＶＰ，重点来了： 想要快速套现的可以选择阿里的投资，2年内一定会被全资收购； 想要上市的优选搜狐的投资，直接搭建境外架构，3年后妥妥纳斯达克敲钟。 最后你们一定会问，你谁啊，靠不靠谱啊？ “我，秦始皇，打钱！” 回答二一、规划 slogan：做中国好馒头、做好中国馒头 使命：让全中国人重新吃上安心馒头 愿景：成为世界顶级的馒头品牌 广告语：这一口，谁不爱 目标人群：新中产阶级 新中产消费观的最大特征：相较于价格，他们在意质量，对于高质量的商品和服务，他们愿意为之付出更高的代价。较高的收入与体面的工作给中产带来片刻的欣慰，但不安与焦虑才是中产光鲜外表下最戳心的痛点，消费升级正是他们面对这种焦虑选择的解决方案。 二、设计 1.品牌 品牌要能让人产生联想，要好记，比如：”真馒头” 2.设计 包装要讲究，但重点是一定要去德国买一个红点奖。 每个包装上，还必须有扎心的文案，比如: 我们拼尽全力，不是为了活成别人想要的模样 你只来了一下子，却改变了我一辈子 我有馒头，你有故事吗? 3.产品 要秉承匠心精神，只做单一产品–真•葱花馒头，将一款产品做到极致。 但是可以根据用户人群推出专属款，比如 有助记忆力的儿童款 提高睡眠质量的老人款 4.门店 不同类型的门店来满足用户多元化的场景需求，包括满足用户线下社交需求的旗舰店，满足亲子活动的DIY体验店，以及快速自提、服务商务人群的快取店，满足客户外送需求的外卖厨房店。通过差异化的门店布局，实现对消费者日常生活全方位覆盖。 5.定价 统一价19.9元！！没有足够的利润空间，618、双11、双12你拿什么打折？ 三、营销 1.讲故事 馒头的面全部来自北纬36°黄金优麦区种植的8848号小麦，纯手工脱粒。 蒸馒头的水，选自长白山矿物质水，再经过36道工艺人工萃取。 创新思维碰撞传统手工技艺，再造中国馒头新未来。 2.讲情怀 创始人211名校毕业后，放弃BTA百万年薪自主创业；尝遍了全国各地大街小巷所有的馒头，拜访数十位隐居的大师，经历了同事朋友的嘲讽、女朋友的离等非常人所能经历的磨难后，终于发明了拥有独特、唯一口味的”真馒头”。 3.软文推广 《震惊！男人吃了沉默，女人吃了流泪》 《感动！一个馒头如果没有情怀，那它和面粉有什么区别》 《刚刚！人人都在疯抢这款馒头》 … 4.造气氛 找很多人来回排队，不用多讲，这是网红店的标配。但是排队的人员组成还是要有讲究的，需要有学生、青年、白领、中年人，而且不能一起到，要分批到。 5.制造热点事件 哭诉鹅厂抄袭商业模式 喊话某互联网大佬，打赌3年后比营业额 6.社会化传播 赞助绝地求生，新增能量馒头，吃一个血条全满！ 雇人拿着馒头去starbuck、costa，让咖啡、苹果笔记本、馒头成为新一代的装B三件套。 抢在韩国人前为馒头申遗！ 7.微微一抖 微博：每天去抢杜蕾斯、回忆专用小马甲的沙发，设置转发有奖活动； 微信公众号：每天深夜10点，推送一条荷尔蒙满满的语音鸡汤，一定要煽情！ 抖音：做一个卡通吉祥物，天天耍贱，卖萌，用户爱看什么拍什么。 8.饥饿营销 每家门店每天限量8888个，卖完即止。第二天的馒头需要提前预约。 9.裂变营销 给好友免费送馒头，他吃你也吃。 10.社群运营 建立真馒头的粉丝群，收集种子用户的建议反馈，经常与粉丝互动。邀请5个人进群可免费领取一个馒头，群成员可享受新品内测试吃福利。 11.APP运营 开启步数兑换优惠券功能，倡导绿色出行； 消费有积分，积分可以浇水种小麦，小麦长成后可以直接磨成面，寄给用户。 增加交友功能，注册必须上传吃馒头的自拍照，可以查看5公里内异性用户的照片，但是必须相互点赞，才能加好友聊天。 12.会员体系 充值5000黄金会员，享8折优惠；充值10000白金会员，全部5折，生日赠送定制版馒头。 13.配送模式 可以在APP或公众号上自助完成下单，下单时可以选择温度、辣度等，制作好了系统会发提示，凭二维码领取，节约排队时间；如果选择外送，在已经开通的外送区域15分钟左右送到，超过30分钟免费。 四、实现盈利 炒作互联网新零售+馒头的成功之道，然后花钱发一堆新闻通稿，进行大量商业路演，约见各类ＶＰ，重点来了： 想要快速套现的可以选择阿里的投资，2年内一定会被全资收购； 想要上市的优选搜狐的投资，直接搭建境外架构，3年后妥妥纳斯达克敲钟。 最后你们一定会问，你谁啊，靠不靠谱啊？ “我，秦始皇，打钱！”","tags":[{"name":"互联网思维","slug":"互联网思维","permalink":"https://joshuaqyh.github.io/tags/互联网思维/"}]},{"title":"Hello World","date":"2018-07-22T00:46:28.391Z","path":"2018/07/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]