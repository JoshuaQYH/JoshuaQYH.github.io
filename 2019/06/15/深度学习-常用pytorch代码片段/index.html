<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>深度学习 | 常用pytorch代码片段  | KnowMyself | QiuYH&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="深度学习">
    <meta name="description" content="点赞收藏：PyTorch常用代码段整理合集转自机器之心：https://www.jiqizhixin.com/articles/2019-04-25-8 众所周知，程序猿在写代码时通常会在网上搜索大量资料，其中大部分是代码段。然而，这项工作常常令人心累身疲，耗费大量时间。所以，今天小编转载了知乎上的一篇文章，介绍了一些常用PyTorch代码段，希望能够为奋战在电脑桌前的众多程序猿们提供帮助！ 本文">
<meta name="keywords" content="深度学习">
<meta property="og:type" content="article">
<meta property="og:title" content="深度学习 | 常用pytorch代码片段 ">
<meta property="og:url" content="https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/index.html">
<meta property="og:site_name" content="KnowMyself">
<meta property="og:description" content="点赞收藏：PyTorch常用代码段整理合集转自机器之心：https://www.jiqizhixin.com/articles/2019-04-25-8 众所周知，程序猿在写代码时通常会在网上搜索大量资料，其中大部分是代码段。然而，这项工作常常令人心累身疲，耗费大量时间。所以，今天小编转载了知乎上的一篇文章，介绍了一些常用PyTorch代码段，希望能够为奋战在电脑桌前的众多程序猿们提供帮助！ 本文">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-15T01:21:20.283Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深度学习 | 常用pytorch代码片段 ">
<meta name="twitter:description" content="点赞收藏：PyTorch常用代码段整理合集转自机器之心：https://www.jiqizhixin.com/articles/2019-04-25-8 众所周知，程序猿在写代码时通常会在网上搜索大量资料，其中大部分是代码段。然而，这项工作常常令人心累身疲，耗费大量时间。所以，今天小编转载了知乎上的一篇文章，介绍了一些常用PyTorch代码段，希望能够为奋战在电脑桌前的众多程序猿们提供帮助！ 本文">
    
        <link rel="alternate" type="application/atom+xml" title="KnowMyself" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Qiuyihao</h5>
          <a href="mailto:576261090@qq.com" title="576261090@qq.com" class="mail">576261090@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/JoshuaQYH" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">深度学习 | 常用pytorch代码片段 </div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="検索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">深度学习 | 常用pytorch代码片段 </h1>
        <h5 class="subtitle">
            
                <time datetime="2019-06-15T01:20:18.000Z" itemprop="datePublished" class="page-time">
  2019-06-15
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#点赞收藏：PyTorch常用代码段整理合集"><span class="post-toc-number">1.</span> <span class="post-toc-text">点赞收藏：PyTorch常用代码段整理合集</span></a></li></ol>
        </nav>
    </aside>


<article id="post-深度学习-常用pytorch代码片段" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">深度学习 | 常用pytorch代码片段 </h1>
        <div class="post-meta">
            <time class="post-time" title="2019-06-15 09:20:18" datetime="2019-06-15T01:20:18.000Z" itemprop="datePublished">2019-06-15</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="点赞收藏：PyTorch常用代码段整理合集"><a href="#点赞收藏：PyTorch常用代码段整理合集" class="headerlink" title="点赞收藏：PyTorch常用代码段整理合集"></a>点赞收藏：PyTorch常用代码段整理合集</h1><p>转自机器之心：<a href="https://www.jiqizhixin.com/articles/2019-04-25-8" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2019-04-25-8</a></p>
<p>众所周知，程序猿在写代码时通常会在网上搜索大量资料，其中大部分是代码段。然而，这项工作常常令人心累身疲，耗费大量时间。所以，今天小编转载了知乎上的一篇文章，介绍了一些常用PyTorch代码段，希望能够为奋战在电脑桌前的众多程序猿们提供帮助！</p>
<p>本文代码基于 PyTorch 1.0 版本，需要用到以下包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import collections</span><br><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line">import tqdm</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import PIL.Image</span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br></pre></td></tr></table></figure>
<p>基础配置</p>
<p><strong>检查 PyTorch 版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.__version__               # PyTorch version</span><br><span class="line">torch.version.cuda              # Corresponding CUDA version</span><br><span class="line">torch.backends.cudnn.version()  # Corresponding cuDNN version</span><br><span class="line">torch.cuda.get_device_name(0)   # GPU type</span><br></pre></td></tr></table></figure>
<p><strong>更新 PyTorch</strong></p>
<p>PyTorch 将被安装在 anaconda3/lib/python3.7/site-packages/torch/目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update pytorch torchvision -c pytorch</span><br></pre></td></tr></table></figure>
<p><strong>固定随机种子</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.manual_seed(0)</span><br><span class="line">torch.cuda.manual_seed_all(0)</span><br></pre></td></tr></table></figure>
<p><strong>指定程序运行在特定 GPU 卡上</strong></p>
<p>在命令行指定环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=0,1 python train.py</span><br></pre></td></tr></table></figure>
<p>或在代码中指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.environ[&apos;CUDA_VISIBLE_DEVICES&apos;] = &apos;0,1&apos;</span><br></pre></td></tr></table></figure>
<p>判断是否有 CUDA 支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>
<p><strong>设置为 cuDNN benchmark 模式</strong></p>
<p>Benchmark 模式会提升计算速度，但是由于计算中有随机性，每次网络前馈结果略有差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.backends.cudnn.benchmark = True</span><br></pre></td></tr></table></figure>
<p>如果想要避免这种结果波动，设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.backends.cudnn.deterministic = True</span><br></pre></td></tr></table></figure>
<p><strong>清除 GPU 存储</strong></p>
<p>有时 Control-C 中止运行后 GPU 存储没有及时释放，需要手动清空。在 PyTorch 内部可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.empty_cache()</span><br></pre></td></tr></table></figure>
<p>或在命令行可以先使用 ps 找到程序的 PID，再使用 kill 结束该进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep pythonkill -9 [pid]</span><br></pre></td></tr></table></figure>
<p>或者直接重置没有被清空的 GPU</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi --gpu-reset -i [gpu_id]</span><br></pre></td></tr></table></figure>
<p><strong>张量处理</strong></p>
<p><strong>张量基本信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor.type()   # Data type</span><br><span class="line">tensor.size()   # Shape of the tensor. It is a subclass of Python tuple</span><br><span class="line">tensor.dim()    # Number of dimensions.</span><br></pre></td></tr></table></figure>
<p><strong>数据类型转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Set default tensor type. Float in PyTorch is much faster than double.</span><br><span class="line">torch.set_default_tensor_type(torch.FloatTensor)</span><br><span class="line"></span><br><span class="line"># Type convertions.</span><br><span class="line">tensor = tensor.cuda()</span><br><span class="line">tensor = tensor.cpu()</span><br><span class="line">tensor = tensor.float()</span><br><span class="line">tensor = tensor.long()</span><br></pre></td></tr></table></figure>
<p><strong>torch.Tensor 与 np.ndarray 转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># torch.Tensor -&gt; np.ndarray.</span><br><span class="line">ndarray = tensor.cpu().numpy()</span><br><span class="line"></span><br><span class="line"># np.ndarray -&gt; torch.Tensor.</span><br><span class="line">tensor = torch.from_numpy(ndarray).float()</span><br><span class="line">tensor = torch.from_numpy(ndarray.copy()).float()  # If ndarray has negative stride</span><br></pre></td></tr></table></figure>
<p><strong>torch.Tensor 与 PIL.Image 转换</strong></p>
<p>PyTorch 中的张量默认采用 N×D×H×W 的顺序，并且数据范围在 [0, 1]，需要进行转置和规范化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># torch.Tensor -&gt; PIL.Image.</span><br><span class="line">image = PIL.Image.fromarray(torch.clamp(tensor * 255, min=0, max=255</span><br><span class="line">    ).byte().permute(1, 2, 0).cpu().numpy())</span><br><span class="line">image = torchvision.transforms.functional.to_pil_image(tensor)  # Equivalently way</span><br><span class="line"></span><br><span class="line"># PIL.Image -&gt; torch.Tensor.</span><br><span class="line">tensor = torch.from_numpy(np.asarray(PIL.Image.open(path))</span><br><span class="line">    ).permute(2, 0, 1).float() / 255</span><br><span class="line">tensor = torchvision.transforms.functional.to_tensor(PIL.Image.open(path))  # Equivalently way</span><br></pre></td></tr></table></figure>
<p><strong>np.ndarray 与 PIL.Image 转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># np.ndarray -&gt; PIL.Image.</span><br><span class="line">image = PIL.Image.fromarray(ndarray.astypde(np.uint8))</span><br><span class="line"></span><br><span class="line"># PIL.Image -&gt; np.ndarray.</span><br><span class="line">ndarray = np.asarray(PIL.Image.open(path))</span><br></pre></td></tr></table></figure>
<p><strong>从只包含一个元素的张量中提取值</strong></p>
<p>这在训练时统计 loss 的变化过程中特别有用。否则这将累积计算图，使 GPU 存储占用量越来越大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = tensor.item()</span><br></pre></td></tr></table></figure>
<p><strong>张量形变</strong></p>
<p>张量形变常常需要用于将卷积层特征输入全连接层的情形。相比 torch.view，torch.reshape 可以自动处理输入张量不连续的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.reshape(tensor, shape)</span><br></pre></td></tr></table></figure>
<p><strong>打乱顺序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor = tensor[torch.randperm(tensor.size(0))]  # Shuffle the first dimension</span><br></pre></td></tr></table></figure>
<p><strong>水平翻转</strong></p>
<p>PyTorch 不支持 tensor[::-1] 这样的负步长操作，水平翻转可以用张量索引实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Assume tensor has shape N*D*H*W.tensor = tensor[:, :, :, torch.arange(tensor.size(3) - 1, -1, -1).long()]</span><br></pre></td></tr></table></figure>
<p><strong>复制张量</strong></p>
<p>有三种复制的方式，对应不同的需求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Operation                 |  New/Shared memory | Still in computation graph |</span><br><span class="line">tensor.clone()            # |        New         |          Yes               |</span><br><span class="line">tensor.detach()           # |      Shared        |          No                |</span><br><span class="line">tensor.detach.clone()()   # |        New         |          No                |</span><br></pre></td></tr></table></figure>
<p><strong>拼接张量</strong></p>
<p>注意 torch.cat 和 torch.stack 的区别在于 torch.cat 沿着给定的维度拼接，而 torch.stack 会新增一维。例如当参数是 3 个 10×5 的张量，torch.cat 的结果是 30×5 的张量，而 torch.stack 的结果是 3×10×5 的张量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.cat(list_of_tensors, dim=0)</span><br><span class="line">tensor = torch.stack(list_of_tensors, dim=0)</span><br></pre></td></tr></table></figure>
<p><strong>将整数标记转换成独热（one-hot）编码</strong></p>
<p>PyTorch 中的标记默认从 0 开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N = tensor.size(0)</span><br><span class="line">one_hot = torch.zeros(N, num_classes).long()</span><br><span class="line">one_hot.scatter_(dim=1, index=torch.unsqueeze(tensor, dim=1), src=torch.ones(N, num_classes).long())</span><br></pre></td></tr></table></figure>
<p><strong>得到非零/零元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.nonzero(tensor)               # Index of non-zero elements</span><br><span class="line">torch.nonzero(tensor == 0)          # Index of zero elements</span><br><span class="line">torch.nonzero(tensor).size(0)       # Number of non-zero elements</span><br><span class="line">torch.nonzero(tensor == 0).size(0)  # Number of zero elements</span><br></pre></td></tr></table></figure>
<p><strong>张量扩展</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Expand tensor of shape 64*512 to shape 64*512*7*7.</span><br><span class="line">torch.reshape(tensor, (64, 512, 1, 1)).expand(64, 512, 7, 7)</span><br></pre></td></tr></table></figure>
<p><strong>矩阵乘法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Matrix multiplication: (m*n) * (n*p) -&gt; (m*p).</span><br><span class="line">result = torch.mm(tensor1, tensor2)</span><br><span class="line"></span><br><span class="line"># Batch matrix multiplication: (b*m*n) * (b*n*p) -&gt; (b*m*p).</span><br><span class="line">result = torch.bmm(tensor1, tensor2)</span><br><span class="line"></span><br><span class="line"># Element-wise multiplication.</span><br><span class="line">result = tensor1 * tensor2</span><br></pre></td></tr></table></figure>
<p><strong>计算两组数据之间的两两欧式距离</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># X1 is of shape m*d.</span><br><span class="line">X1 = torch.unsqueeze(X1, dim=1).expand(m, n, d)</span><br><span class="line"># X2 is of shape n*d.</span><br><span class="line">X2 = torch.unsqueeze(X2, dim=0).expand(m, n, d)</span><br><span class="line"># dist is of shape m*n, where dist[i][j] = sqrt(|X1[i, :] - X[j, :]|^2)</span><br><span class="line">dist = torch.sqrt(torch.sum((X1 - X2) ** 2, dim=2))</span><br></pre></td></tr></table></figure>
<p><strong>模型定义</strong></p>
<p><strong>卷积层</strong></p>
<p>最常用的卷积层配置是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv = torch.nn.Conv2d(in_channels, out_channels, kernel_size=3, stride=1, padding=1, bias=True)conv = torch.nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=True)</span><br></pre></td></tr></table></figure>
<p>如果卷积层配置比较复杂，不方便计算输出大小时，可以利用如下可视化工具辅助</p>
<p>链接：<a href="https://ezyang.github.io/convolution-visualizer/index.html" target="_blank" rel="noopener">https://ezyang.github.io/convolution-visualizer/index.html</a></p>
<p><strong>0GAP（Global average pooling）层</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gap = torch.nn.AdaptiveAvgPool2d(output_size=1)</span><br></pre></td></tr></table></figure>
<p><strong>双线性汇合（bilinear pooling）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.reshape(N, D, H * W)                        # Assume X has shape N*D*H*W</span><br><span class="line">X = torch.bmm(X, torch.transpose(X, 1, 2)) / (H * W)  # Bilinear pooling</span><br><span class="line">assert X.size() == (N, D, D)</span><br><span class="line">X = torch.reshape(X, (N, D * D))</span><br><span class="line">X = torch.sign(X) * torch.sqrt(torch.abs(X) + 1e-5)   # Signed-sqrt normalization</span><br><span class="line">X = torch.nn.functional.normalize(X)                  # L2 normalization</span><br></pre></td></tr></table></figure>
<p><strong>多卡同步 BN（Batch normalization）</strong></p>
<p>当使用 torch.nn.DataParallel 将代码运行在多张 GPU 卡上时，PyTorch 的 BN 层默认操作是各卡上数据独立地计算均值和标准差，同步 BN 使用所有卡上的数据一起计算 BN 层的均值和标准差，缓解了当批量大小（batch size）比较小时对均值和标准差估计不准的情况，是在目标检测等任务中一个有效的提升性能的技巧。</p>
<p>链接：<a href="https://github.com/vacancy/Synchronized-BatchNorm-PyTorch" target="_blank" rel="noopener">https://github.com/vacancy/Synchronized-BatchNorm-PyTorch</a></p>
<p><strong>类似 BN 滑动平均</strong></p>
<p>如果要实现类似 BN 滑动平均的操作，在 forward 函数中要使用原地（inplace）操作给滑动平均赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BN(torch.nn.Module)</span><br><span class="line">    def __init__(self):</span><br><span class="line">        ...</span><br><span class="line">        self.register_buffer(&apos;running_mean&apos;, torch.zeros(num_features))</span><br><span class="line"></span><br><span class="line">    def forward(self, X):</span><br><span class="line">        ...</span><br><span class="line">        self.running_mean += momentum * (current - self.running_mean)</span><br></pre></td></tr></table></figure>
<p><strong>计算模型整体参数量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_parameters = sum(torch.numel(parameter) for parameter in model.parameters())</span><br></pre></td></tr></table></figure>
<p><strong>类似 Keras 的 model.summary() 输出模型信息</strong></p>
<p>链接：<a href="https://github.com/sksq96/pytorch-summary" target="_blank" rel="noopener">https://github.com/sksq96/pytorch-summary</a></p>
<p><strong>模型权值初始化</strong></p>
<p>注意 model.modules() 和 model.children() 的区别：model.modules() 会迭代地遍历模型的所有子层，而 model.children() 只会遍历模型下的一层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Common practise for initialization.</span><br><span class="line">for layer in model.modules():</span><br><span class="line">    if isinstance(layer, torch.nn.Conv2d):</span><br><span class="line">        torch.nn.init.kaiming_normal_(layer.weight, mode=&apos;fan_out&apos;,</span><br><span class="line">                                      nonlinearity=&apos;relu&apos;)</span><br><span class="line">        if layer.bias is not None:</span><br><span class="line">            torch.nn.init.constant_(layer.bias, val=0.0)</span><br><span class="line">    elif isinstance(layer, torch.nn.BatchNorm2d):</span><br><span class="line">        torch.nn.init.constant_(layer.weight, val=1.0)</span><br><span class="line">        torch.nn.init.constant_(layer.bias, val=0.0)</span><br><span class="line">    elif isinstance(layer, torch.nn.Linear):</span><br><span class="line">        torch.nn.init.xavier_normal_(layer.weight)</span><br><span class="line">        if layer.bias is not None:</span><br><span class="line">            torch.nn.init.constant_(layer.bias, val=0.0)</span><br><span class="line"></span><br><span class="line"># Initialization with given tensor.</span><br><span class="line">layer.weight = torch.nn.Parameter(tensor)</span><br></pre></td></tr></table></figure>
<p><strong>部分层使用预训练模型</strong></p>
<p>注意如果保存的模型是 torch.nn.DataParallel，则当前的模型也需要是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.load_state_dict(torch.load(&apos;model,pth&apos;), strict=False)</span><br></pre></td></tr></table></figure>
<p><strong>将在 GPU 保存的模型加载到 CPU</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.load_state_dict(torch.load(&apos;model,pth&apos;, map_location=&apos;cpu&apos;))</span><br></pre></td></tr></table></figure>
<p><strong>数据准备、特征提取与微调</strong></p>
<p><strong>得到视频数据基本信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">video = cv2.VideoCapture(mp4_path)</span><br><span class="line">height = int(video.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">width = int(video.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">num_frames = int(video.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line">fps = int(video.get(cv2.CAP_PROP_FPS))</span><br><span class="line">video.release()</span><br></pre></td></tr></table></figure>
<p><strong>TSN 每段（segment）采样一帧视频</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">K = self._num_segments</span><br><span class="line">if is_train:</span><br><span class="line">    if num_frames &gt; K:</span><br><span class="line">        # Random index for each segment.</span><br><span class="line">        frame_indices = torch.randint(</span><br><span class="line">            high=num_frames // K, size=(K,), dtype=torch.long)</span><br><span class="line">        frame_indices += num_frames // K * torch.arange(K)</span><br><span class="line">    else:</span><br><span class="line">        frame_indices = torch.randint(</span><br><span class="line">            high=num_frames, size=(K - num_frames,), dtype=torch.long)</span><br><span class="line">        frame_indices = torch.sort(torch.cat((</span><br><span class="line">            torch.arange(num_frames), frame_indices)))[0]</span><br><span class="line">else:</span><br><span class="line">    if num_frames &gt; K:</span><br><span class="line">        # Middle index for each segment.</span><br><span class="line">        frame_indices = num_frames / K // 2</span><br><span class="line">        frame_indices += num_frames // K * torch.arange(K)</span><br><span class="line">    else:</span><br><span class="line">        frame_indices = torch.sort(torch.cat((                              </span><br><span class="line">            torch.arange(num_frames), torch.arange(K - num_frames))))[0]</span><br><span class="line">assert frame_indices.size() == (K,)</span><br><span class="line">return [frame_indices[i] for i in range(K)]</span><br></pre></td></tr></table></figure>
<p><strong>提取 ImageNet 预训练模型某层的卷积特征</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># VGG-16 relu5-3 feature.</span><br><span class="line">model = torchvision.models.vgg16(pretrained=True).features[:-1]</span><br><span class="line"># VGG-16 pool5 feature.</span><br><span class="line">model = torchvision.models.vgg16(pretrained=True).features</span><br><span class="line"># VGG-16 fc7 feature.</span><br><span class="line">model = torchvision.models.vgg16(pretrained=True)</span><br><span class="line">model.classifier = torch.nn.Sequential(*list(model.classifier.children())[:-3])</span><br><span class="line"># ResNet GAP feature.</span><br><span class="line">model = torchvision.models.resnet18(pretrained=True)</span><br><span class="line">model = torch.nn.Sequential(collections.OrderedDict(</span><br><span class="line">    list(model.named_children())[:-1]))</span><br><span class="line"></span><br><span class="line">with torch.no_grad():</span><br><span class="line">    model.eval()</span><br><span class="line">    conv_representation = model(image)</span><br></pre></td></tr></table></figure>
<p><strong>提取 ImageNet 预训练模型多层的卷积特征</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class FeatureExtractor(torch.nn.Module):</span><br><span class="line">    &quot;&quot;&quot;Helper class to extract several convolution features from the given</span><br><span class="line">    pre-trained model.</span><br><span class="line"></span><br><span class="line">    Attributes:</span><br><span class="line">        _model, torch.nn.Module.</span><br><span class="line">        _layers_to_extract, list&lt;str&gt; or set&lt;str&gt;</span><br><span class="line"></span><br><span class="line">    Example:</span><br><span class="line">        &gt;&gt;&gt; model = torchvision.models.resnet152(pretrained=True)</span><br><span class="line">        &gt;&gt;&gt; model = torch.nn.Sequential(collections.OrderedDict(</span><br><span class="line">                list(model.named_children())[:-1]))</span><br><span class="line">        &gt;&gt;&gt; conv_representation = FeatureExtractor(</span><br><span class="line">                pretrained_model=model,</span><br><span class="line">                layers_to_extract=&#123;&apos;layer1&apos;, &apos;layer2&apos;, &apos;layer3&apos;, &apos;layer4&apos;&#125;)(image)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, pretrained_model, layers_to_extract):</span><br><span class="line">        torch.nn.Module.__init__(self)</span><br><span class="line">        self._model = pretrained_model</span><br><span class="line">        self._model.eval()</span><br><span class="line">        self._layers_to_extract = set(layers_to_extract)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        with torch.no_grad():</span><br><span class="line">            conv_representation = []</span><br><span class="line">            for name, layer in self._model.named_children():</span><br><span class="line">                x = layer(x)</span><br><span class="line">                if name in self._layers_to_extract:</span><br><span class="line">                    conv_representation.append(x)</span><br><span class="line">            return conv_representation</span><br></pre></td></tr></table></figure>
<p><strong>其他预训练模型</strong></p>
<p>链接：<a href="https://github.com/Cadene/pretrained-models.pytorch" target="_blank" rel="noopener">https://github.com/Cadene/pretrained-models.pytorch</a></p>
<p><strong>微调全连接层</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = torchvision.models.resnet18(pretrained=True)</span><br><span class="line">for param in model.parameters():</span><br><span class="line">    param.requires_grad = False</span><br><span class="line">model.fc = nn.Linear(512, 100)  # Replace the last fc layer</span><br><span class="line">optimizer = torch.optim.SGD(model.fc.parameters(), lr=1e-2, momentum=0.9, weight_decay=1e-4)</span><br></pre></td></tr></table></figure>
<p><strong>以较大学习率微调全连接层，较小学习率微调卷积层</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = torchvision.models.resnet18(pretrained=True)</span><br><span class="line">finetuned_parameters = list(map(id, model.fc.parameters()))</span><br><span class="line">conv_parameters = (p for p in model.parameters() if id(p) not in finetuned_parameters)</span><br><span class="line">parameters = [&#123;&apos;params&apos;: conv_parameters, &apos;lr&apos;: 1e-3&#125;, </span><br><span class="line">              &#123;&apos;params&apos;: model.fc.parameters()&#125;]</span><br><span class="line">optimizer = torch.optim.SGD(parameters, lr=1e-2, momentum=0.9, weight_decay=1e-4)</span><br></pre></td></tr></table></figure>
<p><strong>模型训练</strong></p>
<p><strong>常用训练和验证数据预处理</strong></p>
<p>其中 ToTensor 操作会将 PIL.Image 或形状为 H×W×D，数值范围为 [0, 255] 的 np.ndarray 转换为形状为 D×H×W，数值范围为 [0.0, 1.0] 的 torch.Tensor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">train_transform = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.RandomResizedCrop(size=224,</span><br><span class="line">                                             scale=(0.08, 1.0)),</span><br><span class="line">    torchvision.transforms.RandomHorizontalFlip(),</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    torchvision.transforms.Normalize(mean=(0.485, 0.456, 0.406),</span><br><span class="line">                                     std=(0.229, 0.224, 0.225)),</span><br><span class="line"> ])</span><br><span class="line"> val_transform = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.Resize(224),</span><br><span class="line">    torchvision.transforms.CenterCrop(224),</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    torchvision.transforms.Normalize(mean=(0.485, 0.456, 0.406),</span><br><span class="line">                                     std=(0.229, 0.224, 0.225)),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><strong>训练基本代码框架</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for t in epoch(80):</span><br><span class="line">    for images, labels in tqdm.tqdm(train_loader, desc=&apos;Epoch %3d&apos; % (t + 1)):</span><br><span class="line">        images, labels = images.cuda(), labels.cuda()</span><br><span class="line">        scores = model(images)</span><br><span class="line">        loss = loss_function(scores, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>
<p><strong>标记平滑（label smoothing）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for images, labels in train_loader:</span><br><span class="line">    images, labels = images.cuda(), labels.cuda()</span><br><span class="line">    N = labels.size(0)</span><br><span class="line">    # C is the number of classes.</span><br><span class="line">    smoothed_labels = torch.full(size=(N, C), fill_value=0.1 / (C - 1)).cuda()</span><br><span class="line">    smoothed_labels.scatter_(dim=1, index=torch.unsqueeze(labels, dim=1), value=0.9)</span><br><span class="line"></span><br><span class="line">    score = model(images)</span><br><span class="line">    log_prob = torch.nn.functional.log_softmax(score, dim=1)</span><br><span class="line">    loss = -torch.sum(log_prob * smoothed_labels) / N</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>
<p><strong>Mixup</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">beta_distribution = torch.distributions.beta.Beta(alpha, alpha)</span><br><span class="line">for images, labels in train_loader:</span><br><span class="line">    images, labels = images.cuda(), labels.cuda()</span><br><span class="line"></span><br><span class="line">    # Mixup images.</span><br><span class="line">    lambda_ = beta_distribution.sample([]).item()</span><br><span class="line">    index = torch.randperm(images.size(0)).cuda()</span><br><span class="line">    mixed_images = lambda_ * images + (1 - lambda_) * images[index, :]</span><br><span class="line"></span><br><span class="line">    # Mixup loss.    </span><br><span class="line">    scores = model(mixed_images)</span><br><span class="line">    loss = (lambda_ * loss_function(scores, labels) </span><br><span class="line">            + (1 - lambda_) * loss_function(scores, labels[index]))</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>
<p><strong>L1 正则化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l1_regularization = torch.nn.L1Loss(reduction=&apos;sum&apos;)</span><br><span class="line">loss = ...  # Standard cross-entropy loss</span><br><span class="line">for param in model.parameters():</span><br><span class="line">    loss += torch.sum(torch.abs(param))</span><br><span class="line">loss.backward()</span><br></pre></td></tr></table></figure>
<p><strong>不对偏置项进行 L2 正则化/权值衰减（weight decay）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bias_list = (param for name, param in model.named_parameters() if name[-4:] == &apos;bias&apos;)</span><br><span class="line">others_list = (param for name, param in model.named_parameters() if name[-4:] != &apos;bias&apos;)</span><br><span class="line">parameters = [&#123;&apos;parameters&apos;: bias_list, &apos;weight_decay&apos;: 0&#125;,                </span><br><span class="line">              &#123;&apos;parameters&apos;: others_list&#125;]</span><br><span class="line">optimizer = torch.optim.SGD(parameters, lr=1e-2, momentum=0.9, weight_decay=1e-4)</span><br></pre></td></tr></table></figure>
<p><strong>梯度裁剪（gradient clipping）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=20)</span><br></pre></td></tr></table></figure>
<p><strong>计算 Softmax 输出的准确率</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">score = model(images)</span><br><span class="line">prediction = torch.argmax(score, dim=1)</span><br><span class="line">num_correct = torch.sum(prediction == labels).item()</span><br><span class="line">accuruacy = num_correct / labels.size(0)</span><br></pre></td></tr></table></figure>
<p><strong>可视化模型前馈的计算图</strong></p>
<p>链接：<a href="https://github.com/szagoruyko/pytorchviz" target="_blank" rel="noopener">https://github.com/szagoruyko/pytorchviz</a></p>
<p><strong>可视化学习曲线</strong></p>
<p>有 Facebook 自己开发的 Visdom 和 Tensorboard 两个选择。</p>
<p><a href="https://github.com/facebookresearch/visdom" target="_blank" rel="noopener">https://github.com/facebookresearch/visdom</a></p>
<p><a href="https://github.com/lanpa/tensorboardX" target="_blank" rel="noopener">https://github.com/lanpa/tensorboardX</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Example using Visdom.</span><br><span class="line">vis = visdom.Visdom(env=&apos;Learning curve&apos;, use_incoming_socket=False)</span><br><span class="line">assert self._visdom.check_connection()</span><br><span class="line">self._visdom.close()</span><br><span class="line">options = collections.namedtuple(&apos;Options&apos;, [&apos;loss&apos;, &apos;acc&apos;, &apos;lr&apos;])(</span><br><span class="line">    loss=&#123;&apos;xlabel&apos;: &apos;Epoch&apos;, &apos;ylabel&apos;: &apos;Loss&apos;, &apos;showlegend&apos;: True&#125;,</span><br><span class="line">    acc=&#123;&apos;xlabel&apos;: &apos;Epoch&apos;, &apos;ylabel&apos;: &apos;Accuracy&apos;, &apos;showlegend&apos;: True&#125;,</span><br><span class="line">    lr=&#123;&apos;xlabel&apos;: &apos;Epoch&apos;, &apos;ylabel&apos;: &apos;Learning rate&apos;, &apos;showlegend&apos;: True&#125;)</span><br><span class="line"></span><br><span class="line">for t in epoch(80):</span><br><span class="line">    tran(...)</span><br><span class="line">    val(...)</span><br><span class="line">    vis.line(X=torch.Tensor([t + 1]), Y=torch.Tensor([train_loss]),</span><br><span class="line">             name=&apos;train&apos;, win=&apos;Loss&apos;, update=&apos;append&apos;, opts=options.loss)</span><br><span class="line">    vis.line(X=torch.Tensor([t + 1]), Y=torch.Tensor([val_loss]),</span><br><span class="line">             name=&apos;val&apos;, win=&apos;Loss&apos;, update=&apos;append&apos;, opts=options.loss)</span><br><span class="line">    vis.line(X=torch.Tensor([t + 1]), Y=torch.Tensor([train_acc]),</span><br><span class="line">             name=&apos;train&apos;, win=&apos;Accuracy&apos;, update=&apos;append&apos;, opts=options.acc)</span><br><span class="line">    vis.line(X=torch.Tensor([t + 1]), Y=torch.Tensor([val_acc]),</span><br><span class="line">             name=&apos;val&apos;, win=&apos;Accuracy&apos;, update=&apos;append&apos;, opts=options.acc)</span><br><span class="line">    vis.line(X=torch.Tensor([t + 1]), Y=torch.Tensor([lr]),</span><br><span class="line">             win=&apos;Learning rate&apos;, update=&apos;append&apos;, opts=options.lr)</span><br></pre></td></tr></table></figure>
<p><strong>得到当前学习率</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># If there is one global learning rate (which is the common case).</span><br><span class="line">lr = next(iter(optimizer.param_groups))[&apos;lr&apos;]</span><br><span class="line"></span><br><span class="line"># If there are multiple learning rates for different layers.</span><br><span class="line">all_lr = []</span><br><span class="line">for param_group in optimizer.param_groups:</span><br><span class="line">    all_lr.append(param_group[&apos;lr&apos;])</span><br></pre></td></tr></table></figure>
<p><strong>学习率衰减</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Reduce learning rate when validation accuarcy plateau.</span><br><span class="line">scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=&apos;max&apos;, patience=5, verbose=True)</span><br><span class="line">for t in range(0, 80):</span><br><span class="line">    train(...); val(...)</span><br><span class="line">    scheduler.step(val_acc)</span><br><span class="line"></span><br><span class="line"># Cosine annealing learning rate.</span><br><span class="line">scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=80)</span><br><span class="line"># Reduce learning rate by 10 at given epochs.</span><br><span class="line">scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[50, 70], gamma=0.1)</span><br><span class="line">for t in range(0, 80):</span><br><span class="line">    scheduler.step()    </span><br><span class="line">    train(...); val(...)</span><br><span class="line"></span><br><span class="line"># Learning rate warmup by 10 epochs.</span><br><span class="line">scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda=lambda t: t / 10)</span><br><span class="line">for t in range(0, 10):</span><br><span class="line">    scheduler.step()</span><br><span class="line">    train(...); val(...)</span><br></pre></td></tr></table></figure>
<p><strong>保存与加载断点</strong></p>
<p>注意为了能够恢复训练，我们需要同时保存模型和优化器的状态，以及当前的训练轮数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Save checkpoint.</span><br><span class="line">is_best = current_acc &gt; best_acc</span><br><span class="line">best_acc = max(best_acc, current_acc)</span><br><span class="line">checkpoint = &#123;</span><br><span class="line">    &apos;best_acc&apos;: best_acc,    </span><br><span class="line">    &apos;epoch&apos;: t + 1,</span><br><span class="line">    &apos;model&apos;: model.state_dict(),</span><br><span class="line">    &apos;optimizer&apos;: optimizer.state_dict(),</span><br><span class="line">&#125;</span><br><span class="line">model_path = os.path.join(&apos;model&apos;, &apos;checkpoint.pth.tar&apos;)</span><br><span class="line">torch.save(checkpoint, model_path)</span><br><span class="line">if is_best:</span><br><span class="line">    shutil.copy(&apos;checkpoint.pth.tar&apos;, model_path)</span><br><span class="line"></span><br><span class="line"># Load checkpoint.</span><br><span class="line">if resume:</span><br><span class="line">    model_path = os.path.join(&apos;model&apos;, &apos;checkpoint.pth.tar&apos;)</span><br><span class="line">    assert os.path.isfile(model_path)</span><br><span class="line">    checkpoint = torch.load(model_path)</span><br><span class="line">    best_acc = checkpoint[&apos;best_acc&apos;]</span><br><span class="line">    start_epoch = checkpoint[&apos;epoch&apos;]</span><br><span class="line">    model.load_state_dict(checkpoint[&apos;model&apos;])</span><br><span class="line">    optimizer.load_state_dict(checkpoint[&apos;optimizer&apos;])</span><br><span class="line">    print(&apos;Load checkpoint at epoch %d.&apos; % start_epoch)</span><br></pre></td></tr></table></figure>
<p><strong>计算准确率、查准率（precision）、查全率（recall）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># data[&apos;label&apos;] and data[&apos;prediction&apos;] are groundtruth label and prediction </span><br><span class="line"># for each image, respectively.</span><br><span class="line">accuracy = np.mean(data[&apos;label&apos;] == data[&apos;prediction&apos;]) * 100</span><br><span class="line"></span><br><span class="line"># Compute recision and recall for each class.</span><br><span class="line">for c in range(len(num_classes)):</span><br><span class="line">    tp = np.dot((data[&apos;label&apos;] == c).astype(int),</span><br><span class="line">                (data[&apos;prediction&apos;] == c).astype(int))</span><br><span class="line">    tp_fp = np.sum(data[&apos;prediction&apos;] == c)</span><br><span class="line">    tp_fn = np.sum(data[&apos;label&apos;] == c)</span><br><span class="line">    precision = tp / tp_fp * 100</span><br><span class="line">    recall = tp / tp_fn * 100</span><br></pre></td></tr></table></figure>
<p><strong>PyTorch 其他注意事项</strong></p>
<p><strong>模型定义</strong></p>
<ul>
<li>建议有参数的层和汇合（pooling）层使用 torch.nn 模块定义，激活函数直接使用 torch.nn.functional。torch.nn 模块和 torch.nn.functional 的区别在于，torch.nn 模块在计算时底层调用了 torch.nn.functional，但 torch.nn 模块包括该层参数，还可以应对训练和测试两种网络状态。使用 torch.nn.functional 时要注意网络状态，如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def forward(self, x):</span><br><span class="line">    ...</span><br><span class="line">    x = torch.nn.functional.dropout(x, p=0.5, training=self.training)</span><br></pre></td></tr></table></figure>
<ul>
<li>model(x) 前用 model.train() 和 model.eval() 切换网络状态。</li>
<li>不需要计算梯度的代码块用 with torch.no_grad() 包含起来。model.eval() 和 torch.no_grad() 的区别在于，model.eval() 是将网络切换为测试状态，例如 BN 和随机失活（dropout）在训练和测试阶段使用不同的计算方法。torch.no_grad() 是关闭 PyTorch 张量的自动求导机制，以减少存储使用和加速计算，得到的结果无法进行 loss.backward()。</li>
<li>torch.nn.CrossEntropyLoss 的输入不需要经过 Softmax。torch.nn.CrossEntropyLoss 等价于 torch.nn.functional.log_softmax + torch.nn.NLLLoss。</li>
<li>loss.backward() 前用 optimizer.zero_grad() 清除累积梯度。optimizer.zero_grad() 和 model.zero_grad() 效果一样。</li>
</ul>
<p><strong>PyTorch 性能与调试</strong></p>
<ul>
<li>torch.utils.data.DataLoader 中尽量设置 pin_memory=True，对特别小的数据集如 MNIST 设置 pin_memory=False 反而更快一些。num_workers 的设置需要在实验中找到最快的取值。</li>
<li>用 del 及时删除不用的中间变量，节约 GPU 存储。</li>
<li>使用 inplace 操作可节约 GPU 存储，如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = torch.nn.functional.relu(x, inplace=True)</span><br></pre></td></tr></table></figure>
<ul>
<li>减少 CPU 和 GPU 之间的数据传输。例如如果你想知道一个 epoch 中每个 mini-batch 的 loss 和准确率，先将它们累积在 GPU 中等一个 epoch 结束之后一起传输回 CPU 会比每个 mini-batch 都进行一次 GPU 到 CPU 的传输更快。</li>
<li>使用半精度浮点数 half() 会有一定的速度提升，具体效率依赖于 GPU 型号。需要小心数值精度过低带来的稳定性问题。</li>
<li>时常使用 assert tensor.size() == (N, D, H, W) 作为调试手段，确保张量维度和你设想中一致。</li>
<li>除了标记 y 外，尽量少使用一维张量，使用 n*1 的二维张量代替，可以避免一些意想不到的一维张量计算结果。</li>
<li>统计代码各部分耗时</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with torch.autograd.profiler.profile(enabled=True, use_cuda=False) as profile:</span><br><span class="line">    ...</span><br><span class="line">print(profile)</span><br></pre></td></tr></table></figure>
<p>或者在命令行运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m torch.utils.bottleneck main.py</span><br></pre></td></tr></table></figure>
<p><strong>致谢</strong></p>
<p>感谢 @些许流年和@El tnoto的勘误。由于作者才疏学浅，更兼时间和精力所限，代码中错误之处在所难免，敬请读者批评指正。</p>
<p><strong>参考资料</strong></p>
<ul>
<li>PyTorch 官方代码：pytorch/examples (<a href="https://link.zhihu.com/?target=https%3A//github.com/pytorch/examples" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//github.com/pytorch/examples</a>)</li>
<li>PyTorch 论坛：PyTorch Forums (<a href="https://link.zhihu.com/?target=https%3A//discuss.pytorch.org/latest%3Forder%3Dviews" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//discuss.pytorch.org/latest%3Forder%3Dviews</a>)</li>
<li>PyTorch 文档：<a href="http://pytorch.org/docs/stable/index.html" target="_blank" rel="noopener">http://pytorch.org/docs/stable/index.html</a> (<a href="https://link.zhihu.com/?target=http%3A//pytorch.org/docs/stable/index.html" target="_blank" rel="noopener">https://link.zhihu.com/?target=http%3A//pytorch.org/docs/stable/index.html</a>)</li>
<li>其他基于 PyTorch 的公开实现代码，无法一一列举 </li>
</ul>
<p>张皓：南京大学计算机系机器学习与数据挖掘所（LAMDA）硕士生，研究方向为计算机视觉和机器学习，特别是视觉识别和深度学习。个人主页：<a href="http://lamda.nju.edu.cn/zhangh/" target="_blank" rel="noopener">http://lamda.nju.edu.cn/zhangh/</a></p>
<p><em>原知乎链接：</em><a href="https://zhuanlan.zhihu.com/p/59205847" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59205847</a>?</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最終更新：<time datetime="2019-06-15T01:21:20.283Z" itemprop="dateUpdated">2019-06-15 09:21:20</time>
</span><br>


        
        Thanks for your reading  :) | URL <a href="/2019/06/15/深度学习-常用pytorch代码片段/" target="_blank" rel="external">https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/</a>
        
    </div>
    
    <footer>
        <a href="https://joshuaqyh.github.io">
            <img src="/img/avatar.jpg" alt="Qiuyihao">
            Qiuyihao
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/深度学习/">深度学习</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/&title=《深度学习 | 常用pytorch代码片段 》 — KnowMyself&pic=https://joshuaqyh.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/&title=《深度学习 | 常用pytorch代码片段 》 — KnowMyself&source=Here are some records for life and study." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《深度学习 | 常用pytorch代码片段 》 — KnowMyself&url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/&via=https://joshuaqyh.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/06/14/软件工程-学习系统顺序图/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">软件工程 | 学习系统顺序图</h4>
      </a>
    </div>
  
</nav>



    

















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>このブログの内容物は<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja">クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスの下に提供されています</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Qiuyihao &copy; 2017 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/&title=《深度学习 | 常用pytorch代码片段 》 — KnowMyself&pic=https://joshuaqyh.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/&title=《深度学习 | 常用pytorch代码片段 》 — KnowMyself&source=Here are some records for life and study." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《深度学习 | 常用pytorch代码片段 》 — KnowMyself&url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/&via=https://joshuaqyh.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://joshuaqyh.github.io/2019/06/15/深度学习-常用pytorch代码片段/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACqklEQVR42u3awW4bMQwEUP//T7vXHmpnhpQcF3h7Chx3d58KSMyQj0d8PV9cf/82+VfvP391h/dPOXDh4eHhHXr1Vy80Y7z6/uw+yTvj4eHh3eblm/Kp77/6bbIcyTvg4eHh/S+8vPBNvrlZYjw8PLzv4bWY99t6W1jj4eHhfQ9vE9S2kcEmwriYteDh4eHFvLb8/Yafr/T38PDw8NZd9bYd1W7ZeajxHF14eHh4N3htnNqWuW08sQ+I8fDw8D7Dax+cjwK0w1Vnq2I8PDy8G7zk8W3RvB9EGJbO7WmGh4eHd43Xtqn2pfD+rfDw8PA+w8uDhrxVljDeHw+zp+Dh4eH9Fu9UO2oziJB/EvX38PDw8I7yks133yprA478SMDDw8P7PC9vUyXjAsX2XRb3RZCBh4eHd4F3Y1PedKAewZUvJR4eHt5tXh7gtvjZi+bLEbXB8PDw8C7w8lGAZCH2La7ZE4dtMDw8PLySlzel2tZUPnbQBhP14YSHh4d3jdfGqW3weqpYb2MRPDw8vFO8ZPvOI4C2JTYbICjuj4eHh3eB15a8+dDAbDlmcfAPhTgeHh7eUd5sEGoW+L7f+tv7H/grAQ8PD2/Ea8Pc2dBA2xhrW3TFQYKHh4d3iFf8YR9j8kJ8E0ZE/w14eHh4H+dthgw2zbA28oiGBvDw8PCO8mYPbqPeWZCxGQjDw8PD+wzv1AHQhhRtzBEtEB4eHt5R3rO82pGCtmRvg4zh6AAeHh7egtdutfkr5jFrfjCcCprx8PDw9rx8ECpfrTaSyJ9bDxDg4eHhXePlm3I7NNAyNsnKP+6Dh4eH95W8NiY4GxD/EEPg4eHhfTEvJ+WHR3vPKyU1Hh4e3iKMyOOAWVCb36c4WvDw8PAu8OoprfjzWbw7DB02Fx4eHl7K+wNEBJxxflGJMAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '唉要去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
